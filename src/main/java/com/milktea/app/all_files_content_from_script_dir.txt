--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\all_files_content_from_script_dir.txt ---


--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\find.py ---
import os

def read_files_in_directory(directory_path, output_file):
    """
    读取指定目录及其子目录中的所有文件内容，并保存到单个文本文件中。

    Args:
        directory_path (str): 要扫描的根目录路径。
        output_file (str): 保存所有文件内容的输出文本文件路径。
    """
    with open(output_file, 'w', encoding='utf-8') as outfile:
        for root, dirs, files in os.walk(directory_path):
            for file in files:
                file_path = os.path.join(root, file)
                try:
                    with open(file_path, 'r', encoding='utf-8') as infile:
                        content = infile.read()
                        outfile.write(f"--- 文件名: {file_path} ---\n")
                        outfile.write(content)
                        outfile.write("\n\n") # 添加空行以分隔文件内容
                except Exception as e:
                    print(f"读取文件 {file_path} 时出错: {e}")

if __name__ == "__main__":
    # 获取当前脚本文件所在的目录
    script_directory = os.path.dirname(os.path.abspath(__file__))
    target_directory = script_directory # 将扫描目标设置为脚本所在目录

    # 替换为你想要保存的输出文件名
    output_text_file = 'all_files_content_from_script_dir.txt'

    if os.path.isdir(target_directory):
        read_files_in_directory(target_directory, output_text_file)
        print(f"所有文件内容已成功保存到: {output_text_file}")
    else:
        print(f"错误: 目录 '{target_directory}' 不存在。这不应该发生，因为它是脚本所在的目录。")

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\MilkteaBackendApplication.java ---
package com.milktea.app; 
 
import org.springframework.boot.SpringApplication; 
import org.springframework.boot.autoconfigure.SpringBootApplication; 
import org.springframework.context.annotation.EnableAspectJAutoProxy; 
import org.springframework.scheduling.annotation.EnableScheduling; 
 
@SpringBootApplication 
@EnableAspectJAutoProxy 
@EnableScheduling 
public class MilkteaBackendApplication { 
 
   public static void main(String[] args) { 
       SpringApplication.run(MilkteaBackendApplication.class, args); 
   } 
} 


--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\common\ApiResponse.java ---
// File: milktea-backend/src/main/java/com.milktea.app/common/ApiResponse.java
package com.milktea.app.common;

import com.milktea.app.common.constant.ErrorCode;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant; // Added for timestamp

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ApiResponse<T> {
    private int code;
    private String message;
    private T data;
    private Long timestamp; // Added for consistent response structure

    public static <T> ApiResponse<T> success(T data) {
        return ApiResponse.<T>builder()
                .code(ErrorCode.SUCCESS)
                .message("success")
                .data(data)
                .timestamp(Instant.now().toEpochMilli()) // Set current timestamp
                .build();
    }

    public static <T> ApiResponse<T> success() {
        return success(null);
    }

    public static <T> ApiResponse<T> error(int code, String message) {
        return ApiResponse.<T>builder()
                .code(code)
                .message(message)
                .data(null)
                .timestamp(Instant.now().toEpochMilli()) // Set current timestamp
                .build();
    }

    public static <T> ApiResponse<T> error(int code, String message, T data) {
        return ApiResponse.<T>builder()
                .code(code)
                .message(message)
                .data(data)
                .timestamp(Instant.now().toEpochMilli()) // Set current timestamp
                .build();
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\common\constant\ErrorCode.java ---
// File: milktea-backend/src/main/java/com/milktea/app/common/constant/ErrorCode.java
package com.milktea.app.common.constant;

public final class ErrorCode {
    // General Errors
    public static final int SUCCESS = 0;
    public static final int SYSTEM_ERROR = 10000;
    public static final int INVALID_PARAM = 10001;
    public static final int UNAUTHORIZED = 10002;
    public static final int FORBIDDEN = 10003;
    public static final int NOT_FOUND = 10004;
    public static final int CONFLICT = 10005; // Resource conflict (e.g., duplicate entry)

    // Auth Errors
    public static final int WECHAT_LOGIN_FAILED = 20001;
    public static final int ACCOUNT_LOGIN_FAILED = 20002;
    public static final int INVALID_CREDENTIALS = 20003;
    public static final int USER_NOT_EXIST = 20004;
    public static final int USER_ALREADY_EXISTS = 20005;
    public static final int INVALID_VERIFICATION_CODE = 20006;
    public static final int VERIFICATION_CODE_EXPIRED = 20007;

    // User Profile Errors
    public static final int PHONE_ALREADY_BOUND = 30001;
    public static final int ADDRESS_NOT_FOUND = 30002;
    public static final int DEFAULT_ADDRESS_CANNOT_DELETE = 30003;

    // Product Errors
    public static final int PRODUCT_NOT_FOUND = 40001;
    public static final int PRODUCT_OFFLINE = 40002;
    public static final int PRODUCT_STOCK_INSUFFICIENT = 40003;

    // Cart Errors
    public static final int CART_ITEM_NOT_FOUND = 50001;
    public static final int CART_ITEM_INVALID = 50002;
    public static final int CART_EMPTY = 50003;

    // Order Errors
    public static final int ORDER_NOT_FOUND = 60001;
    public static final int ORDER_STATUS_INVALID = 60002;
    public static final int ORDER_CANNOT_CANCEL = 60003;
    public static final int ORDER_CANNOT_REFUND = 60004;
    public static final int PAYMENT_FAILED = 60005;
    public static final int PAYMENT_EXPIRED = 60006;
    public static final int PAYMENT_METHOD_NOT_SUPPORTED = 60007;
    public static final int CHECKOUT_VALIDATION_FAILED = 60008;

    // Store Errors
    public static final int STORE_NOT_FOUND = 70001;
    public static final int STORE_CLOSED = 70002;
    public static final int STORE_BUSY = 70003;
    public static final int STORE_OUT_OF_DELIVERY_RANGE = 70004;
    public static final int MINIMUM_ORDER_AMOUNT_NOT_MET = 70005;

    // Coupon Errors
    public static final int COUPON_NOT_FOUND = 80001;
    public static final int COUPON_EXPIRED = 80002;
    public static final int COUPON_USED = 80003;
    public static final int COUPON_NOT_APPLICABLE = 80004;
    public static final int COUPON_ACQUIRE_LIMIT_REACHED = 80005;
    public static final int COUPON_OUT_OF_STOCK = 80006;

    // Point Errors
    public static final int INSUFFICIENT_POINTS = 90001;
    public static final int POINT_EXCHANGE_ITEM_NOT_FOUND = 90002;
    public static final int POINT_EXCHANGE_ITEM_OUT_OF_STOCK = 90003;

    // File Upload Errors
    public static final int FILE_UPLOAD_FAILED = 11001;
    public static final int INVALID_FILE_TYPE = 11002;
    public static final int FILE_SIZE_EXCEEDS_LIMIT = 11003;

    private ErrorCode() {
        // Private constructor to prevent instantiation
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\common\enums\CouponType.java ---
// File: milktea-backend/src/main/java/com/milktea/app/common/enums/CouponType.java
package com.milktea.app.common.enums;

public enum CouponType {
    DISCOUNT("discount"), // 满减
    PERCENTAGE("percentage"), // 折扣
    FIXED("fixed"); // 固定金额

    private final String code;

    CouponType(String code) {
        this.code = code;
    }

    public String getCode() {
        return code;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\common\enums\OrderStatus.java ---
// File: milktea-backend/src/main/java/com/milktea/app/common/enums/OrderStatus.java
package com.milktea.app.common.enums;

public enum OrderStatus {
    CREATED("created", "订单已创建"),
    PAID("paid", "支付成功"),
    MAKING("making", "制作中"),
    READY("ready", "待取餐/待配送"),
    DELIVERING("delivering", "配送中"), // For delivery type
    COMPLETED("completed", "订单完成"),
    CANCELLED("cancelled", "订单已取消"),
    REFUNDED("refunded", "订单已退款");

    private final String code;
    private final String description;

    OrderStatus(String code, String description) {
        this.code = code;
        this.description = description;
    }

    public String getCode() {
        return code;
    }

    public String getDescription() {
        return description;
    }

    public static OrderStatus fromCode(String code) {
        for (OrderStatus status : OrderStatus.values()) {
            if (status.getCode().equalsIgnoreCase(code)) {
                return status;
            }
        }
        throw new IllegalArgumentException("Unknown order status code: " + code);
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\common\enums\PayStatus.java ---
// File: milktea-backend/src/main/java/com/milktea/app/common/enums/PayStatus.java
package com.milktea.app.common.enums;

public enum PayStatus {
    UNPAID("unpaid", "未支付"),
    PAID("paid", "已支付"),
    FAILED("failed", "支付失败"),
    CANCELLED("cancelled", "支付已取消");

    private final String code;
    private final String description;

    PayStatus(String code, String description) {
        this.code = code;
        this.description = description;
    }

    public String getCode() {
        return code;
    }

    public String getDescription() {
        return description;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\common\enums\ShareType.java ---
// File: milktea-backend/src/main/java/com/milktea/app/common/enums/ShareType.java
package com.milktea.app.common.enums;

public enum ShareType {
    PRODUCT("product"),
    ACTIVITY("activity"),
    INVITE("invite");

    private final String code;

    ShareType(String code) {
        this.code = code;
    }

    public String getCode() {
        return code;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\common\exception\BusinessException.java ---
// File: milktea-backend/src/main/java/com/milktea/app/common/exception/BusinessException.java
package com.milktea.app.common.exception;

import com.milktea.app.common.constant.ErrorCode;
import lombok.Getter;

@Getter
public class BusinessException extends RuntimeException {
    private final int code;

    public BusinessException(String message) {
        super(message);
        this.code = ErrorCode.SYSTEM_ERROR; // Default to system error
    }

    public BusinessException(int code, String message) {
        super(message);
        this.code = code;
    }

    public BusinessException(int code, String message, Throwable cause) {
        super(message, cause);
        this.code = code;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\common\exception\GlobalExceptionHandler.java ---
// File: milktea-backend/src/main/java/com/milktea/app/common/exception/GlobalExceptionHandler.java
package com.milktea.app.common.exception;

import com.milktea.app.common.ApiResponse;
import com.milktea.app.common.constant.ErrorCode;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseStatus;

import java.util.HashMap;
import java.util.Map;

@ControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ApiResponse<Void>> handleBusinessException(BusinessException ex) {
        log.warn("Business Exception: Code={}, Message={}", ex.getCode(), ex.getMessage());
        return ResponseEntity
                .status(HttpStatus.OK) // Business exceptions can still return 200 OK with an error code in the body
                .body(ApiResponse.error(ex.getCode(), ex.getMessage()));
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ResponseEntity<ApiResponse<Map<String, String>>> handleValidationExceptions(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach((error) -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });
        log.warn("Validation Exception: {}", errors);
        return ResponseEntity
                .badRequest()
                .body(ApiResponse.error(ErrorCode.INVALID_PARAM, "Validation failed", errors));
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiResponse<Void>> handleGlobalException(Exception ex) {
        log.error("An unexpected error occurred: ", ex);
        return ResponseEntity
                .status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(ApiResponse.error(ErrorCode.SYSTEM_ERROR, "An unexpected server error occurred."));
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\common\util\DateUtil.java ---
// File: milktea-backend/src/main/java/com/milktea/app/common/util/DateUtil.java
package com.milktea.app.common.util;

import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import java.util.Date;

public class DateUtil {

    private static final DateTimeFormatter ISO_INSTANT_FORMATTER = DateTimeFormatter.ISO_INSTANT;
    private static final DateTimeFormatter ISO_LOCAL_DATE_FORMATTER = DateTimeFormatter.ISO_LOCAL_DATE;
    private static final DateTimeFormatter ISO_LOCAL_DATE_TIME_FORMATTER = DateTimeFormatter.ISO_LOCAL_DATE_TIME;
    private static final DateTimeFormatter DATE_TIME_FORMATTER_WITH_ZONE = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ssXXX");


    public static Instant now() {
        return Instant.now();
    }

    public static Date toDate(Instant instant) {
        return instant == null ? null : Date.from(instant);
    }

    public static Instant toInstant(Date date) {
        return date == null ? null : date.toInstant();
    }

    public static String formatInstant(Instant instant) {
        return instant == null ? null : ISO_INSTANT_FORMATTER.format(instant);
    }

    public static Instant parseInstant(String instantString) {
        return instantString == null ? null : Instant.parse(instantString);
    }

    public static String formatLocalDate(LocalDate localDate) {
        return localDate == null ? null : ISO_LOCAL_DATE_FORMATTER.format(localDate);
    }

    public static LocalDate parseLocalDate(String dateString) {
        return dateString == null ? null : LocalDate.parse(dateString, ISO_LOCAL_DATE_FORMATTER);
    }

    public static String formatLocalDateTime(LocalDateTime localDateTime) {
        return localDateTime == null ? null : ISO_LOCAL_DATE_TIME_FORMATTER.format(localDateTime);
    }

    public static LocalDateTime parseLocalDateTime(String dateTimeString) {
        return dateTimeString == null ? null : LocalDateTime.parse(dateTimeString, ISO_LOCAL_DATE_TIME_FORMATTER);
    }

    /**
     * Converts Instant to a formatted String suitable for DTOs with timezone.
     * E.g., "2023-01-01T00:00:00Z" (ISO-8601 UTC)
     */
    public static String toIsoString(Instant instant) {
        return instant == null ? null : instant.atOffset(ZoneOffset.UTC).format(ISO_INSTANT_FORMATTER);
    }

    /**
     * Converts a formatted String (e.g., "2023-01-01T00:00:00Z") to Instant.
     */
    public static Instant fromIsoString(String isoString) {
        return isoString == null ? null : Instant.parse(isoString);
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\common\util\GeoUtil.java ---
// File: milktea-backend/src/main/java/com/milktea/app/common/util/GeoUtil.java
package com.milktea.app.common.util;

public class GeoUtil {

    private static final double EARTH_RADIUS = 6371000; // meters

    /**
     * Calculates the distance between two points on Earth using the Haversine formula.
     *
     * @param lat1 Latitude of point 1
     * @param lon1 Longitude of point 1
     * @param lat2 Latitude of point 2
     * @param lon2 Longitude of point 2
     * @return Distance in meters
     */
    public static double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
        double latDistance = Math.toRadians(lat2 - lat1);
        double lonDistance = Math.toRadians(lon2 - lon1);
        double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)
                + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))
                * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);
        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return EARTH_RADIUS * c; // Result in meters
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\common\util\PaginationUtil.java ---
// File: milktea-backend/src/main/java/com/milktea/app/common/util/PaginationUtil.java
package com.milktea.app.common.util;

import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;

public class PaginationUtil {

    public static Pageable createPageable(Integer page, Integer limit, String sortProperty, Sort.Direction direction) {
        int pageNumber = (page != null && page > 0) ? page - 1 : 0;
        int pageSize = (limit != null && limit > 0) ? limit : 10; // Default limit to 10

        if (sortProperty != null && !sortProperty.isEmpty()) {
            return PageRequest.of(pageNumber, pageSize, Sort.by(direction, sortProperty));
        } else {
            return PageRequest.of(pageNumber, pageSize);
        }
    }

    public static Pageable createPageable(Integer page, Integer limit) {
        return createPageable(page, limit, null, null);
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\config\AppConfig.java ---
// File: milktea-backend/src/main/java/com/milktea/app/config/AppConfig.java
package com.milktea.app.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.client.RestTemplate;

@Configuration
public class AppConfig {

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\config\WebSecurityConfig.java ---
// File: milktea-backend/src/main/java/com/milktea/app/config/WebSecurityConfig.java
package com.milktea.app.config;

import com.milktea.app.jwt.JwtAuthFilter;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class WebSecurityConfig {

    private final JwtAuthFilter jwtAuthFilter;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .csrf(AbstractHttpConfigurer::disable) // Disable CSRF for stateless REST APIs
                .authorizeHttpRequests(authorize -> authorize
                        // Permit all for authentication and file upload endpoints
                        .requestMatchers("/auth/**", "/upload/**", "/websocket/**", "/ws/**").permitAll()
                        // Other requests require authentication
                        .anyRequest().authenticated()
                )
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS) // Use stateless sessions for JWT
                )
                .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class); // Add JWT filter

        return http.build();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\config\WebSocketConfig.java ---
// File: milktea-backend/src/main/java/com.milktea.app/config/WebSocketConfig.java
package com.milktea.app.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;
import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;

@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void configureMessageBroker(MessageBrokerRegistry config) {
        // Use /topic for broadcasting messages to many users (e.g., order status updates)
        // Use /queue for sending messages to a specific user (e.g., direct notifications)
        config.enableSimpleBroker("/topic", "/queue");
        // /app is the prefix for client-to-server messages
        config.setApplicationDestinationPrefixes("/app");
        // /user prefix for user-specific destinations
        config.setUserDestinationPrefix("/user");
    }

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        // Register the /ws/order endpoint for WebSocket connections as per frontend doc
        registry.addEndpoint("/ws/order") // Changed endpoint to match /v1/ws/order from doc
                .setAllowedOriginPatterns("*") // Allow all origins, adjust for production
                .withSockJS(); // Enable SockJS fallback for browsers that don't support WebSockets
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\controller\AuthV1Controller.java ---
// File: milktea-backend/src/main/java/com.milktea.app/controller/AuthV1Controller.java
package com.milktea.app.controller;

import com.milktea.app.common.ApiResponse;
import com.milktea.app.dto.auth.AccountLoginReqDTO;
import com.milktea.app.dto.auth.UserAuthResDTO;
import com.milktea.app.dto.auth.WechatLoginReqDTO;
import com.milktea.app.service.AuthService;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/auth/v1")
@RequiredArgsConstructor
@Slf4j
public class AuthV1Controller {

    private final AuthService authService;

    @PostMapping("/wechat-login") // Updated path to match /auth/wechat-login
    public ApiResponse<UserAuthResDTO> wechatLogin(@Valid @RequestBody WechatLoginReqDTO reqDTO) {
        // 这是微信实现的
        log.info("WeChat login request received: {}", reqDTO.getCode());
        UserAuthResDTO resDTO = authService.wechatLogin(reqDTO);
        return ApiResponse.success(resDTO);
    }

    @PostMapping("/login") // Updated path to match /auth/login
    public ApiResponse<UserAuthResDTO> accountLogin(@Valid @RequestBody AccountLoginReqDTO reqDTO) {
        log.info("Account login request received for username: {}", reqDTO.getUsername());
        UserAuthResDTO resDTO = authService.accountLogin(reqDTO);
        return ApiResponse.success(resDTO);
    }

    @PostMapping("/logout")
    public ApiResponse<Void> logout(HttpServletRequest request) {
        String authHeader = request.getHeader("Authorization");
        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            String token = authHeader.substring(7);
            authService.logout(token);
            log.info("User logged out.");
        }
        return ApiResponse.success();
    }

    // Placeholder for registration, password reset etc.
    // @PostMapping("/register")
    // public ApiResponse<Void> register(@Valid @RequestBody RegisterReqDTO reqDTO) { ... }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\controller\CartV1Controller.java ---
// File: milktea-backend/src/main/java/com.milktea.app/controller/CartV1Controller.java
package com.milktea.app.controller;

import com.milktea.app.common.ApiResponse;
import com.milktea.app.dto.cart.CartBatchOperationReqDTO;
import com.milktea.app.dto.cart.CartItemAddReqDTO;
import com.milktea.app.dto.cart.CartItemUpdateReqDTO;
import com.milktea.app.dto.cart.CartResDTO;
import com.milktea.app.service.CartService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.User;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/cart/v1") // Base path for cart module
@RequiredArgsConstructor
@Slf4j
public class CartV1Controller {

    private final CartService cartService;

    private Long getUserId(@AuthenticationPrincipal User principal) {
        return Long.parseLong(principal.getUsername());
    }

    @GetMapping // Matches /cart
    public ApiResponse<CartResDTO> getCart(@AuthenticationPrincipal User principal) {
        Long userId = getUserId(principal);
        log.info("Getting cart for user: {}", userId);
        CartResDTO resDTO = cartService.getCart(userId);
        return ApiResponse.success(resDTO);
    }

    @PostMapping("/items") // Matches /cart/items
    public ApiResponse<CartResDTO> addCartItem(@AuthenticationPrincipal User principal,
                                               @Valid @RequestBody CartItemAddReqDTO reqDTO) {
        Long userId = getUserId(principal);
        log.info("Adding cart item for user {}: {}", userId, reqDTO.getProductId());
        CartResDTO resDTO = cartService.addCartItem(userId, reqDTO);
        return ApiResponse.success(resDTO);
    }

    @PutMapping("/items/{cartItemId}") // Matches /cart/items/{id}
    public ApiResponse<CartResDTO> updateCartItem(@AuthenticationPrincipal User principal,
                                                  @PathVariable("cartItemId") Long cartItemId, // Renamed path variable for clarity
                                                  @Valid @RequestBody CartItemUpdateReqDTO reqDTO) {
        Long userId = getUserId(principal);
        log.info("Updating cart item {} for user {}: {}", cartItemId, userId, reqDTO.getQuantity());
        CartResDTO resDTO = cartService.updateCartItem(userId, cartItemId, reqDTO);
        return ApiResponse.success(resDTO);
    }

    @DeleteMapping("/items/{cartItemId}") // Matches /cart/items/{id}
    public ApiResponse<CartResDTO> deleteCartItem(@AuthenticationPrincipal User principal,
                                                  @PathVariable("cartItemId") Long cartItemId) { // Renamed path variable for clarity
        Long userId = getUserId(principal);
        log.info("Deleting cart item {} for user {}", cartItemId, userId);
        CartResDTO resDTO = cartService.deleteCartItem(userId, cartItemId);
        return ApiResponse.success(resDTO);
    }

    @PostMapping("/batch") // Matches /cart/batch
    public ApiResponse<CartResDTO> batchOperateCartItems(@AuthenticationPrincipal User principal,
                                                         @Valid @RequestBody CartBatchOperationReqDTO reqDTO) {
        Long userId = getUserId(principal);
        log.info("Batch operation '{}' on cart for user {}", reqDTO.getAction(), userId);
        CartResDTO resDTO = cartService.batchOperateCartItems(userId, reqDTO);
        return ApiResponse.success(resDTO);
    }

    @DeleteMapping // Matches /cart
    public ApiResponse<Void> clearCart(@AuthenticationPrincipal User principal) {
        Long userId = getUserId(principal);
        log.info("Clearing cart for user {}", userId);
        cartService.clearCart(userId);
        return ApiResponse.success();
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\controller\CategoryV1Controller.java ---
// File: milktea-backend/src/main/java/com.milktea.app/controller/CategoryV1Controller.java
package com.milktea.app.controller;

import com.milktea.app.common.ApiResponse;
import com.milktea.app.dto.category.CategoryTreeResDTO;
import com.milktea.app.service.CategoryService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequestMapping("/categories/v1")
@RequiredArgsConstructor
@Slf4j
public class CategoryV1Controller {

    private final CategoryService categoryService;

    @GetMapping("/tree") // Matches /categories/tree
    public ApiResponse<List<CategoryTreeResDTO>> getCategoryTree() {
        log.info("Fetching category tree.");
        List<CategoryTreeResDTO> resDTO = categoryService.getCategoryTree();
        return ApiResponse.success(resDTO);
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\controller\CouponV1Controller.java ---
// File: milktea-backend/src/main/java/com.milktea.app/controller/CouponV1Controller.java
package com.milktea.app.controller;

import com.milktea.app.common.ApiResponse;
import com.milktea.app.common.util.PaginationUtil;
import com.milktea.app.dto.coupon.CouponBatchReceiveReqDTO;
import com.milktea.app.dto.coupon.CouponListResDTO;
import com.milktea.app.dto.coupon.CouponReceiveResDTO;
import com.milktea.app.service.CouponService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Pageable;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.User;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/coupons/v1") // Base path for coupons module
@RequiredArgsConstructor
@Slf4j
public class CouponV1Controller {

    private final CouponService couponService;

    private Long getUserId(@AuthenticationPrincipal User principal) {
        return Long.parseLong(principal.getUsername());
    }

    @GetMapping // Matches /coupons
    public ApiResponse<CouponListResDTO> getUserCoupons(@AuthenticationPrincipal User principal,
                                                        @RequestParam(required = false) String status,
                                                        @RequestParam(defaultValue = "1") Integer page,
                                                        @RequestParam(defaultValue = "10") Integer limit) {
        Long userId = getUserId(principal);
        log.info("Getting coupons for user {} with status {}", userId, status);
        Pageable pageable = PaginationUtil.createPageable(page, limit);
        CouponListResDTO resDTO = couponService.getUserCoupons(userId, status, pageable);
        return ApiResponse.success(resDTO);
    }

    @PostMapping("/{templateId}/receive") // Matches /coupons/{id}/receive
    public ApiResponse<CouponReceiveResDTO> receiveCoupon(@AuthenticationPrincipal User principal,
                                                          @PathVariable("templateId") Long templateId) { // Renamed path variable for clarity
        Long userId = getUserId(principal);
        log.info("User {} receiving coupon template {}", userId, templateId);
        CouponReceiveResDTO resDTO = couponService.receiveCoupon(userId, templateId);
        return ApiResponse.success(resDTO);
    }

    @PostMapping("/batchreceive") // Matches /coupons/batchreceive
    public ApiResponse<CouponReceiveResDTO> batchReceiveCoupons(@AuthenticationPrincipal User principal,
                                                                @Valid @RequestBody CouponBatchReceiveReqDTO reqDTO) {
        Long userId = getUserId(principal);
        log.info("User {} batch receiving coupons: {}", userId, reqDTO.getCouponIds());
        // Note: The response for batch operations might be more detailed in a real app (e.g., list of successful/failed IDs)
        CouponReceiveResDTO resDTO = couponService.batchReceiveCoupons(userId, reqDTO);
        return ApiResponse.success(resDTO);
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\controller\FileV1Controller.java ---
// File: milktea-backend/src/main/java/com.milktea.app/controller/FileV1Controller.java
package com.milktea.app.controller;

import com.milktea.app.common.ApiResponse;
import com.milktea.app.dto.file.FileUploadResDTO;
import com.milktea.app.service.FileService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.User;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

@RestController
@RequestMapping("/upload/v1") // Base path for upload module to match /upload
@RequiredArgsConstructor
@Slf4j
public class FileV1Controller {

    private final FileService fileService;

    private Long getUserId(@AuthenticationPrincipal User principal) {
        return principal != null ? Long.parseLong(principal.getUsername()) : null;
    }

    @PostMapping // Matches /upload (i.e., /upload/v1)
    public ApiResponse<FileUploadResDTO> uploadFile(@AuthenticationPrincipal User principal,
                                                    @RequestParam("file") MultipartFile file,
                                                    @RequestParam(value = "category") String category) {
        // Document has 'type' in request parameters, but it's typically derived from Content-Type or file extension.
        // And 'category' in the doc means purpose, not mime type.
        // The service layer handles inferring file type (image/video/audio) from mime-type.
        Long userId = null;
        if (principal != null) {
            userId = getUserId(principal);
        }
        log.info("File upload request received from user {} for category: {}", userId, category);
        FileUploadResDTO resDTO = fileService.uploadFile(userId, file, category);
        return ApiResponse.success(resDTO);
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\controller\HomeV1Controller.java ---
// File: milktea-backend/src/main/java/com.milktea.app/controller/HomeV1Controller.java
package com.milktea.app.controller;

import com.milktea.app.common.ApiResponse;
import com.milktea.app.dto.home.HomePageResDTO;
import com.milktea.app.dto.product.ProductListResDTO;
import com.milktea.app.service.HomeService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.math.BigDecimal;

@RestController
@RequestMapping("/home/v1") // Base path for home module
@RequiredArgsConstructor
@Slf4j
public class HomeV1Controller {

    private final HomeService homeService;

    @GetMapping("/index") // Matches /home/index
    public ApiResponse<HomePageResDTO> getHomePageData(@RequestParam(required = false) BigDecimal latitude,
                                                       @RequestParam(required = false) BigDecimal longitude) {
        log.info("Fetching home page data for location: ({}, {})", latitude, longitude);
        HomePageResDTO resDTO = homeService.getHomePageData(latitude, longitude);
        return ApiResponse.success(resDTO);
    }

    @GetMapping("/recommend") // Matches /home/recommend
    public ApiResponse<ProductListResDTO> getRecommendedProducts(@RequestParam(defaultValue = "10") Integer limit,
                                                                 @RequestParam(defaultValue = "product") String type) {
        log.info("Fetching recommended products with limit {} and type {}", limit, type);
        ProductListResDTO resDTO = homeService.getRecommendedProducts(limit, type);
        return ApiResponse.success(resDTO);
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\controller\MemberV1Controller.java ---
// File: milktea-backend/src/main/java/com.milktea.app/controller/MemberV1Controller.java
package com.milktea.app.controller;

import com.milktea.app.common.ApiResponse;
import com.milktea.app.dto.member.MemberInfoResDTO;
import com.milktea.app.service.MemberService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.User;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/member/v1") // Base path for member module
@RequiredArgsConstructor
@Slf4j
public class MemberV1Controller {

    private final MemberService memberService;

    private Long getUserId(@AuthenticationPrincipal User principal) {
        return Long.parseLong(principal.getUsername());
    }

    @GetMapping("/info") // Matches /member/info
    public ApiResponse<MemberInfoResDTO> getMemberInfo(@AuthenticationPrincipal User principal) {
        Long userId = getUserId(principal);
        log.info("Getting member info for user: {}", userId);
        MemberInfoResDTO resDTO = memberService.getMemberInfo(userId);
        return ApiResponse.success(resDTO);
    }

    @PostMapping("/birthdaygift/receive") // Matches /member/birthdaygift/receive
    public ApiResponse<Void> receiveBirthdayGift(@AuthenticationPrincipal User principal) {
        Long userId = getUserId(principal);
        log.info("User {} attempting to receive birthday gift", userId);
        memberService.receiveBirthdayGift(userId);
        return ApiResponse.success();
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\controller\NotificationV1Controller.java ---
// File: milktea-backend/src/main/java/com.milktea.app/controller/NotificationV1Controller.java
package com.milktea.app.controller;

import com.milktea.app.common.ApiResponse;
import com.milktea.app.common.util.PaginationUtil;
import com.milktea.app.dto.notification.NotificationBatchReadReqDTO;
import com.milktea.app.dto.notification.NotificationListResDTO;
import com.milktea.app.service.NotificationService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Pageable;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.User;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/notifications/v1") // Base path for notifications module
@RequiredArgsConstructor
@Slf4j
public class NotificationV1Controller {

    private final NotificationService notificationService;

    private Long getUserId(@AuthenticationPrincipal User principal) {
        return Long.parseLong(principal.getUsername());
    }

    @GetMapping // Matches /notifications
    public ApiResponse<NotificationListResDTO> getNotifications(@AuthenticationPrincipal User principal,
                                                                @RequestParam(required = false, defaultValue = "all") String type, // Added type parameter
                                                                @RequestParam(defaultValue = "1") Integer page,
                                                                @RequestParam(defaultValue = "20") Integer limit) { // Changed default limit to 20
        Long userId = getUserId(principal);
        log.info("Getting notifications for user {} with type: {}", userId, type);
        Pageable pageable = PaginationUtil.createPageable(page, limit);
        NotificationListResDTO resDTO = notificationService.getNotifications(userId, type, pageable);
        return ApiResponse.success(resDTO);
    }

    @GetMapping("/unread-count")
    public ApiResponse<Long> getUnreadNotificationCount(@AuthenticationPrincipal User principal) {
        Long userId = getUserId(principal);
        log.info("Getting unread notification count for user: {}", userId);
        Long count = notificationService.getUnreadNotificationCount(userId);
        return ApiResponse.success(count);
    }

    @PutMapping("/{notificationId}/read") // Matches /notifications/{id}/read
    public ApiResponse<Void> markNotificationAsRead(@AuthenticationPrincipal User principal,
                                                    @PathVariable("notificationId") Long notificationId) { // Renamed path variable for clarity
        Long userId = getUserId(principal);
        log.info("Marking notification {} as read for user {}", notificationId, userId);
        notificationService.markNotificationAsRead(userId, notificationId);
        return ApiResponse.success();
    }

    @PostMapping("/batchread") // Matches /notifications/batchread
    public ApiResponse<Void> batchMarkNotificationsAsRead(@AuthenticationPrincipal User principal,
                                                          @Valid @RequestBody NotificationBatchReadReqDTO reqDTO) {
        Long userId = getUserId(principal);
        log.info("Batch marking notifications as read for user {}. All: {}, IDs: {}", userId, reqDTO.getAll(), reqDTO.getIds());
        notificationService.batchMarkNotificationsAsRead(userId, reqDTO);
        return ApiResponse.success();
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\controller\OrderV1Controller.java ---
// File: milktea-backend/src/main/java/com.milktea.app/controller/OrderV1Controller.java
package com.milktea.app.controller;

import com.milktea.app.common.ApiResponse;
import com.milktea.app.common.util.PaginationUtil;
import com.milktea.app.dto.order.*;
import com.milktea.app.service.OrderService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Pageable;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.User;
import org.springframework.web.bind.annotation.*;

import java.time.Instant; // Added for startDate/endDate
import java.time.format.DateTimeParseException; // Added for parsing dates

@RestController
@RequestMapping("/orders/v1") // Base path for order module
@RequiredArgsConstructor
@Slf4j
public class OrderV1Controller {

    private final OrderService orderService;

    private Long getUserId(@AuthenticationPrincipal User principal) {
        return Long.parseLong(principal.getUsername());
    }

    @PostMapping("/checkout") // Matches /cart/checkout
    public ApiResponse<CheckoutResDTO> getCheckoutDetails(@AuthenticationPrincipal User principal,
                                                          @Valid @RequestBody CheckoutReqDTO reqDTO) {
        Long userId = getUserId(principal);
        log.info("Getting checkout details for user {}: {}", userId, reqDTO.getItemIds());
        CheckoutResDTO resDTO = orderService.getCheckoutDetails(userId, reqDTO);
        return ApiResponse.success(resDTO);
    }

    @PostMapping("/validate") // Matches /cart/validate
    public ApiResponse<OrderValidateResDTO> validateOrder(@AuthenticationPrincipal User principal,
                                                          @Valid @RequestBody OrderValidateReqDTO reqDTO) {
        Long userId = getUserId(principal);
        log.info("Validating order for user {}: {}", userId, reqDTO.getItemIds());
        OrderValidateResDTO resDTO = orderService.validateOrder(userId, reqDTO);
        return ApiResponse.success(resDTO);
    }

    @PostMapping // Matches /orders
    public ApiResponse<OrderCreateResDTO> createOrder(@AuthenticationPrincipal User principal,
                                                      @Valid @RequestBody OrderCreateReqDTO reqDTO) {
        Long userId = getUserId(principal);
        log.info("Creating order for user {}: {}", userId, reqDTO.getType());
        OrderCreateResDTO resDTO = orderService.createOrder(userId, reqDTO);
        return ApiResponse.success(resDTO);
    }

    @PostMapping("/buy-now") // New: 4.1.2 立即购买
    public ApiResponse<OrderCreateResDTO> buyNow(@AuthenticationPrincipal User principal,
                                                 @Valid @RequestBody OrderCreateReqDTO reqDTO) { // Uses same DTO as create order
        Long userId = getUserId(principal);
        log.info("Buy now order for user {}: {}", userId, reqDTO.getItems().get(0).getProductId());
        OrderCreateResDTO resDTO = orderService.buyNow(userId, reqDTO);
        return ApiResponse.success(resDTO);
    }

    @PostMapping("/{orderId}/pay") // Matches /orders/{id}/pay
    public ApiResponse<PaymentResDTO> initiatePayment(@AuthenticationPrincipal User principal,
                                                      @PathVariable("orderId") Long orderId, // Renamed path variable for clarity
                                                      @Valid @RequestBody PaymentReqDTO reqDTO) {
        Long userId = getUserId(principal);
        log.info("Initiating payment for order {} by user {}", orderId, userId);
        PaymentResDTO resDTO = orderService.initiatePayment(userId, orderId, reqDTO);
        return ApiResponse.success(resDTO);
    }

    @GetMapping("/{orderId}/pay/status") // Matches /orders/{id}/pay/status
    public ApiResponse<PaymentStatusResDTO> getPaymentStatus(@AuthenticationPrincipal User principal,
                                                             @PathVariable("orderId") Long orderId) { // Renamed path variable for clarity
        Long userId = getUserId(principal);
        log.info("Getting payment status for order {} by user {}", orderId, userId);
        PaymentStatusResDTO resDTO = orderService.getPaymentStatus(userId, orderId);
        return ApiResponse.success(resDTO);
    }

    @PostMapping("/{orderId}/pay/cancel") // New: 4.2.3 取消支付
    public ApiResponse<Void> cancelPayment(@AuthenticationPrincipal User principal,
                                           @PathVariable("orderId") Long orderId) {
        Long userId = getUserId(principal);
        log.info("Cancelling payment for order {} by user {}", orderId, userId);
        orderService.cancelPayment(userId, orderId);
        return ApiResponse.success();
    }

    @GetMapping // Matches /orders
    public ApiResponse<OrderListResDTO> getUserOrders(@AuthenticationPrincipal User principal,
                                                      @RequestParam(required = false, defaultValue = "all") String status,
                                                      @RequestParam(required = false, defaultValue = "all") String type, // Added type parameter
                                                      @RequestParam(required = false) String startDate, // Added startDate
                                                      @RequestParam(required = false) String endDate,   // Added endDate
                                                      @RequestParam(defaultValue = "1") Integer page,
                                                      @RequestParam(defaultValue = "10") Integer limit) {
        Long userId = getUserId(principal);
        log.info("Getting orders for user {} with status {}, type {}, startDate {}, endDate {}", userId, status, type, startDate, endDate);

        Instant startInstant = null;
        Instant endInstant = null;
        try {
            if (startDate != null) {
                startInstant = Instant.parse(startDate + "T00:00:00Z"); // Assuming start of day UTC
            }
            if (endDate != null) {
                endInstant = Instant.parse(endDate + "T23:59:59Z"); // Assuming end of day UTC
            }
        } catch (DateTimeParseException e) {
            log.error("Error parsing date parameters: {}", e.getMessage());
            throw new BusinessException(com.milktea.app.common.constant.ErrorCode.INVALID_PARAM, "Invalid date format. Expected YYYY-MM-DD.");
        }


        Pageable pageable = PaginationUtil.createPageable(page, limit);
        OrderListResDTO resDTO = orderService.getUserOrders(userId, status, type, startInstant, endInstant, pageable);
        return ApiResponse.success(resDTO);
    }

    @GetMapping("/{orderId}") // Matches /orders/{id}
    public ApiResponse<OrderDetailResDTO> getOrderDetail(@AuthenticationPrincipal User principal,
                                                         @PathVariable("orderId") Long orderId) { // Renamed path variable for clarity
        Long userId = getUserId(principal);
        log.info("Getting order detail for order {} by user {}", orderId, userId);
        OrderDetailResDTO resDTO = orderService.getOrderDetail(userId, orderId);
        return ApiResponse.success(resDTO);
    }

    @PostMapping("/{orderId}/cancel") // Matches /orders/{id}/cancel
    public ApiResponse<Void> cancelOrder(@AuthenticationPrincipal User principal,
                                         @PathVariable("orderId") Long orderId, // Renamed path variable for clarity
                                         @RequestBody(required = false) OrderCancelReqDTO reqDTO) {
        Long userId = getUserId(principal);
        log.info("Cancelling order {} by user {}", orderId, userId);
        orderService.cancelOrder(userId, orderId, reqDTO);
        return ApiResponse.success();
    }

    @PostMapping("/{orderId}/confirm") // Matches /orders/{id}/confirm
    public ApiResponse<Void> confirmOrder(@AuthenticationPrincipal User principal,
                                          @PathVariable("orderId") Long orderId) { // Renamed path variable for clarity
        Long userId = getUserId(principal);
        log.info("Confirming order {} by user {}", orderId, userId);
        orderService.confirmOrder(userId, orderId);
        return ApiResponse.success();
    }

    @PostMapping("/{orderId}/remind") // New: 4.3.3.3 催单提醒
    public ApiResponse<Void> remindOrder(@AuthenticationPrincipal User principal,
                                         @PathVariable("orderId") Long orderId) {
        Long userId = getUserId(principal);
        log.info("Reminding order {} by user {}", orderId, userId);
        orderService.remindOrder(userId, orderId);
        return ApiResponse.success();
    }

    @PostMapping("/{orderId}/refund/apply") // Matches /orders/{id}/refund/apply
    public ApiResponse<Void> applyOrderRefund(@AuthenticationPrincipal User principal,
                                              @PathVariable("orderId") Long orderId, // Renamed path variable for clarity
                                              @Valid @RequestBody OrderRefundApplyReqDTO reqDTO) {
        Long userId = getUserId(principal);
        log.info("Applying refund for order {} by user {}", orderId, userId);
        orderService.applyOrderRefund(userId, orderId, reqDTO);
        return ApiResponse.success();
    }

    @PostMapping("/{orderId}/rate") // Matches /orders/{id}/rate
    public ApiResponse<Void> addOrderReview(@AuthenticationPrincipal User principal,
                                            @PathVariable("orderId") Long orderId, // Renamed path variable for clarity
                                            @Valid @RequestBody OrderReviewReqDTO reqDTO) {
        Long userId = getUserId(principal);
        log.info("Adding review for order {} by user {}", orderId, userId);
        orderService.addOrderReview(userId, orderId, reqDTO);
        return ApiResponse.success();
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\controller\PointV1Controller.java ---
// File: milktea-backend/src/main/java/com.milktea.app/controller/PointV1Controller.java
package com.milktea.app.controller;

import com.milktea.app.common.ApiResponse;
import com.milktea.app.common.util.PaginationUtil;
import com.milktea.app.dto.point.PointExchangeReqDTO;
import com.milktea.app.dto.point.PointTransactionListResDTO;
import com.milktea.app.service.PointService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Pageable;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.User;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/points/v1") // Base path for points module
@RequiredArgsConstructor
@Slf4j
public class PointV1Controller {

    private final PointService pointService;

    private Long getUserId(@AuthenticationPrincipal User principal) {
        return Long.parseLong(principal.getUsername());
    }

    @GetMapping("/transactions") // Matches /points/transactions
    public ApiResponse<PointTransactionListResDTO> getPointTransactions(@AuthenticationPrincipal User principal,
                                                                        @RequestParam(required = false, defaultValue = "all") String type, // Added type parameter
                                                                        @RequestParam(defaultValue = "1") Integer page,
                                                                        @RequestParam(defaultValue = "20") Integer limit) { // Changed default limit to 20
        Long userId = getUserId(principal);
        log.info("Getting point transactions for user {} with type: {}", userId, type);
        Pageable pageable = PaginationUtil.createPageable(page, limit);
        PointTransactionListResDTO resDTO = pointService.getPointTransactions(userId, type, pageable);
        return ApiResponse.success(resDTO);
    }

    @PostMapping("/exchange") // Matches /points/exchange
    public ApiResponse<Void> exchangePoints(@AuthenticationPrincipal User principal,
                                            @Valid @RequestBody PointExchangeReqDTO reqDTO) {
        Long userId = getUserId(principal);
        log.info("User {} exchanging points for item {}: quantity {}", userId, reqDTO.getItemId(), reqDTO.getQuantity());
        pointService.exchangePoints(userId, reqDTO);
        return ApiResponse.success();
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\controller\ProductV1Controller.java ---
// File: milktea-backend/src/main/java/com.milktea.app/controller/ProductV1Controller.java
package com.milktea.app.controller;

import com.milktea.app.common.ApiResponse;
import com.milktea.app.common.util.PaginationUtil;
import com.milktea.app.dto.product.ProductDetailResDTO;
import com.milktea.app.dto.product.ProductFavoriteStatusResDTO;
import com.milktea.app.dto.product.ProductListReqDTO;
import com.milktea.app.dto.product.ProductListResDTO;
import com.milktea.app.service.ProductService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.User;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/products/v1") // Base path for product module
@RequiredArgsConstructor
@Slf4j
public class ProductV1Controller {

    private final ProductService productService;

    private Long getUserId(@AuthenticationPrincipal User principal) {
        return principal != null ? Long.parseLong(principal.getUsername()) : null;
    }

    @GetMapping // Matches /products (used for generic list with filters)
    public ApiResponse<ProductListResDTO> getProducts(@Valid @ModelAttribute ProductListReqDTO reqDTO,
                                                      @RequestParam(defaultValue = "1") Integer page,
                                                      @RequestParam(defaultValue = "20") Integer limit) {
        log.info("Fetching product list with filters: {}", reqDTO);
        Sort.Direction direction = (reqDTO.getSort() != null && reqDTO.getSort().endsWith("_desc")) ? Sort.Direction.DESC : Sort.Direction.ASC;
        String sortProperty = (reqDTO.getSort() != null && reqDTO.getSort().contains("_")) ? reqDTO.getSort().substring(0, reqDTO.getSort().indexOf("_")) : reqDTO.getSort();
        Pageable pageable = PaginationUtil.createPageable(page, limit, sortProperty, direction);
        ProductListResDTO resDTO = productService.getProducts(reqDTO, pageable);
        return ApiResponse.success(resDTO);
    }

    @GetMapping("/categories/{categoryId}/products") // New: 2.2.2 获取分类商品
    public ApiResponse<ProductListResDTO> getCategoryProducts(@PathVariable Long categoryId,
                                                              @Valid @ModelAttribute ProductListReqDTO reqDTO, // Reuse ProductListReqDTO for sort/filter
                                                              @RequestParam(defaultValue = "1") Integer page,
                                                              @RequestParam(defaultValue = "20") Integer limit) {
        log.info("Fetching products for category {} with filters: {}", categoryId, reqDTO);
        Sort.Direction direction = (reqDTO.getSort() != null && reqDTO.getSort().endsWith("_desc")) ? Sort.Direction.DESC : Sort.Direction.ASC;
        String sortProperty = (reqDTO.getSort() != null && reqDTO.getSort().contains("_")) ? reqDTO.getSort().substring(0, reqDTO.getSort().indexOf("_")) : reqDTO.getSort();
        Pageable pageable = PaginationUtil.createPageable(page, limit, sortProperty, direction);
        ProductListResDTO resDTO = productService.getCategoryProducts(categoryId, reqDTO, pageable);
        return ApiResponse.success(resDTO);
    }

    @GetMapping("/{productId}") // Matches /products/{id}
    public ApiResponse<ProductDetailResDTO> getProductDetail(@AuthenticationPrincipal User principal,
                                                             @PathVariable Long productId) {
        Long userId = getUserId(principal);
        log.info("Fetching product detail for ID {} by user {}", productId, userId);
        ProductDetailResDTO resDTO = productService.getProductDetail(userId, productId);
        return ApiResponse.success(resDTO);
    }

    @PostMapping("/{productId}/favorite") // Matches /products/{id}/favorite
    public ApiResponse<Void> addFavoriteProduct(@AuthenticationPrincipal User principal,
                                                @PathVariable Long productId) {
        Long userId = getUserId(principal);
        log.info("User {} adding product {} to favorites", userId, productId);
        productService.addFavoriteProduct(userId, productId);
        return ApiResponse.success();
    }

    @DeleteMapping("/{productId}/favorite") // Matches /products/{id}/favorite
    public ApiResponse<Void> removeFavoriteProduct(@AuthenticationPrincipal User principal,
                                                   @PathVariable Long productId) {
        Long userId = getUserId(principal);
        log.info("User {} removing product {} from favorites", userId, productId);
        productService.removeFavoriteProduct(userId, productId);
        return ApiResponse.success();
    }

    @GetMapping("/{productId}/favorite/status") // New: 2.3.4 获取收藏状态
    public ApiResponse<ProductFavoriteStatusResDTO> getProductFavoriteStatus(@AuthenticationPrincipal User principal,
                                                                             @PathVariable Long productId) {
        Long userId = getUserId(principal);
        log.info("Checking if product {} is favorited by user {}", productId, userId);
        ProductFavoriteStatusResDTO resDTO = productService.getProductFavoriteStatus(userId, productId);
        return ApiResponse.success(resDTO);
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\controller\SearchV1Controller.java ---
// File: milktea-backend/src/main/java/com.milktea.app/controller/SearchV1Controller.java
package com.milktea.app.controller;

import com.milktea.app.common.ApiResponse;
import com.milktea.app.common.util.PaginationUtil;
import com.milktea.app.dto.search.ProductSearchReqDTO;
import com.milktea.app.dto.search.ProductSearchResDTO;
import com.milktea.app.dto.search.SearchHistoryReqDTO;
import com.milktea.app.dto.search.SearchHotKeywordsResDTO;
import com.milktea.app.dto.search.SearchSuggestResDTO;
import com.milktea.app.service.SearchService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.User;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/search/v1") // Base path for search module
@RequiredArgsConstructor
@Slf4j
public class SearchV1Controller {

    private final SearchService searchService;

    private Long getUserId(@AuthenticationPrincipal User principal) {
        return principal != null ? Long.parseLong(principal.getUsername()) : null;
    }

    @GetMapping("/products") // Matches /search/products
    public ApiResponse<ProductSearchResDTO> searchProducts(@AuthenticationPrincipal User principal,
                                                           @Valid @ModelAttribute ProductSearchReqDTO reqDTO,
                                                           @RequestParam(defaultValue = "1") Integer page,
                                                           @RequestParam(defaultValue = "20") Integer limit) {
        Long userId = getUserId(principal);
        log.info("Searching products for user {} with keyword: {}", userId, reqDTO.getKeyword());
        Sort.Direction direction = (reqDTO.getSort() != null && reqDTO.getSort().endsWith("_desc")) ? Sort.Direction.DESC : Sort.Direction.ASC;
        String sortProperty = (reqDTO.getSort() != null && reqDTO.getSort().contains("_")) ? reqDTO.getSort().substring(0, reqDTO.getSort().indexOf("_")) : reqDTO.getSort();
        Pageable pageable = PaginationUtil.createPageable(page, limit, sortProperty, direction);
        ProductSearchResDTO resDTO = searchService.searchProducts(userId, reqDTO, pageable);
        return ApiResponse.success(resDTO);
    }

    @GetMapping("/hot") // Matches /search/hot
    public ApiResponse<SearchHotKeywordsResDTO> getHotKeywordsAndHistory(@AuthenticationPrincipal User principal,
                                                                         @RequestParam(defaultValue = "10") Integer limit) { // Added limit param
        Long userId = getUserId(principal);
        log.info("Getting hot keywords and search history for user: {} with limit {}", userId, limit);
        SearchHotKeywordsResDTO resDTO = searchService.getHotKeywordsAndHistory(userId, limit);
        return ApiResponse.success(resDTO);
    }

    @GetMapping("/suggest") // Matches /search/suggest
    public ApiResponse<SearchSuggestResDTO> getSearchSuggestions(@RequestParam("keyword") String keyword, // Renamed param to keyword
                                                                 @RequestParam(defaultValue = "5") Integer limit) { // Added limit param
        log.info("Getting search suggestions for keyword: {} with limit {}", keyword, limit);
        SearchSuggestResDTO resDTO = searchService.getSearchSuggestions(keyword, limit);
        return ApiResponse.success(resDTO);
    }

    @PostMapping("/history") // Matches /search/history
    public ApiResponse<Void> addSearchHistory(@AuthenticationPrincipal User principal,
                                              @Valid @RequestBody SearchHistoryReqDTO reqDTO) {
        Long userId = getUserId(principal);
        log.info("Adding search history for user {}: {}", userId, reqDTO.getKeyword());
        searchService.addSearchHistory(userId, reqDTO);
        return ApiResponse.success();
    }

    @DeleteMapping("/history") // Matches /search/history
    public ApiResponse<Void> clearSearchHistory(@AuthenticationPrincipal User principal) {
        Long userId = getUserId(principal);
        log.info("Clearing search history for user {}", userId);
        searchService.clearSearchHistory(userId);
        return ApiResponse.success();
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\controller\StoreV1Controller.java ---
// File: milktea-backend/src/main/java/com.milktea.app/controller/StoreV1Controller.java
package com.milktea.app.controller;

import com.milktea.app.common.ApiResponse;
import com.milktea.app.dto.store.StoreDetailResDTO;
import com.milktea.app.dto.store.StoreNearbyReqDTO;
import com.milktea.app.dto.store.StoreNearbyResDTO;
import com.milktea.app.service.StoreService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.User;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/stores/v1") // Base path for stores module
@RequiredArgsConstructor
@Slf4j
public class StoreV1Controller {

    private final StoreService storeService;

    private Long getUserId(@AuthenticationPrincipal User principal) {
        return principal != null ? Long.parseLong(principal.getUsername()) : null;
    }

    @GetMapping("/nearby") // Matches /stores/nearby
    public ApiResponse<StoreNearbyResDTO> getNearbyStores(@AuthenticationPrincipal User principal,
                                                          @Valid @ModelAttribute StoreNearbyReqDTO reqDTO) {
        Long userId = getUserId(principal);
        log.info("Getting nearby stores for user {} at ({}, {}) radius {}", userId, reqDTO.getLatitude(), reqDTO.getLongitude(), reqDTO.getRadius());
        StoreNearbyResDTO resDTO = storeService.getNearbyStores(userId, reqDTO);
        return ApiResponse.success(resDTO);
    }

    @GetMapping("/{storeId}") // Matches /stores/{id}
    public ApiResponse<StoreDetailResDTO> getStoreDetail(@AuthenticationPrincipal User principal,
                                                         @PathVariable("storeId") Long storeId) { // Renamed path variable for clarity
        Long userId = getUserId(principal);
        log.info("Getting store detail for ID {} by user {}", storeId, userId);
        StoreDetailResDTO resDTO = storeService.getStoreDetail(userId, storeId);
        return ApiResponse.success(resDTO);
    }

    @PostMapping("/{storeId}/favorite") // Matches /stores/{id}/favorite
    public ApiResponse<Void> addFavoriteStore(@AuthenticationPrincipal User principal,
                                              @PathVariable("storeId") Long storeId) { // Renamed path variable for clarity
        Long userId = getUserId(principal);
        log.info("User {} adding store {} to favorites", userId, storeId);
        storeService.addFavoriteStore(userId, storeId);
        return ApiResponse.success();
    }

    @DeleteMapping("/{storeId}/favorite") // Matches /stores/{id}/favorite
    public ApiResponse<Void> removeFavoriteStore(@AuthenticationPrincipal User principal,
                                                 @PathVariable("storeId") Long storeId) { // Renamed path variable for clarity
        Long userId = getUserId(principal);
        log.info("User {} removing store {} from favorites", userId, storeId);
        storeService.removeFavoriteStore(userId, storeId);
        return ApiResponse.success();
    }

    // 接口文档未明确提供获取门店收藏状态的接口，但通常会有。
    // 如果需要，可以添加一个 @GetMapping("/{storeId}/is-favorite")

}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\controller\SystemV1Controller.java ---
// File: milktea-backend/src/main/java/com.milktea.app/controller/SystemV1Controller.java
package com.milktea.app.controller;

import com.milktea.app.common.ApiResponse;
import com.milktea.app.dto.system.PageConfigResDTO;
import com.milktea.app.dto.system.SystemConfigResDTO;
import com.milktea.app.service.SystemService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/system/v1") // Base path for system module
@RequiredArgsConstructor
@Slf4j
public class SystemV1Controller {

    private final SystemService systemService;

    @GetMapping("/config") // Matches /system/config
    public ApiResponse<SystemConfigResDTO> getSystemConfigs() {
        log.info("Fetching system configurations.");
        SystemConfigResDTO resDTO = systemService.getSystemConfigs();
        return ApiResponse.success(resDTO);
    }

    @GetMapping("/pageconfig/{pageName}") // Matches /system/pageconfig/{page}
    public ApiResponse<PageConfigResDTO> getPageConfigs(@PathVariable("pageName") String pageName) { // Renamed path variable
        log.info("Fetching page configurations for page: {}", pageName);
        PageConfigResDTO resDTO = systemService.getPageConfigs(pageName);
        return ApiResponse.success(resDTO);
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\controller\UserV1Controller.java ---
// File: milktea-backend/src/main/java/com.milktea.app/controller/UserV1Controller.java
package com.milktea.app.controller;

import com.milktea.app.common.ApiResponse;
import com.milktea.app.common.util.PaginationUtil;
import com.milktea.app.dto.user.*;
import com.milktea.app.service.UserService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Pageable;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.User;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/user/v1")
@RequiredArgsConstructor
@Slf4j
public class UserV1Controller {

    private final UserService userService;

    private Long getUserId(@AuthenticationPrincipal User principal) {
        return Long.parseLong(principal.getUsername());
    }

    @GetMapping("/profile")
    public ApiResponse<UserProfileResDTO> getUserProfile(@AuthenticationPrincipal User principal) {
        Long userId = getUserId(principal);
        log.info("Getting user profile for user: {}", userId);
        UserProfileResDTO resDTO = userService.getUserProfile(userId);
        return ApiResponse.success(resDTO);
    }

    @PutMapping("/profile")
    public ApiResponse<UserProfileResDTO> updateProfile(@AuthenticationPrincipal User principal,
                                                        @Valid @RequestBody UserProfileUpdateReqDTO reqDTO) {
        Long userId = getUserId(principal);
        log.info("Updating profile for user: {}", userId);
        UserProfileResDTO resDTO = userService.updateProfile(userId, reqDTO);
        return ApiResponse.success(resDTO);
    }

    @PutMapping("/phone")
    public ApiResponse<Void> updatePhone(@AuthenticationPrincipal User principal,
                                         @Valid @RequestBody UserPhoneUpdateReqDTO reqDTO) {
        Long userId = getUserId(principal);
        log.info("Updating phone for user {} to: {}", userId, reqDTO.getPhone());
        userService.updatePhone(userId, reqDTO);
        return ApiResponse.success();
    }

    @GetMapping("/addresses")
    public ApiResponse<UserAddressResDTO> getUserAddresses(@AuthenticationPrincipal User principal,
                                                           @RequestParam(defaultValue = "1") Integer page,
                                                           @RequestParam(defaultValue = "10") Integer limit) {
        Long userId = getUserId(principal);
        log.info("Getting addresses for user: {}", userId);
        Pageable pageable = PaginationUtil.createPageable(page, limit);
        UserAddressResDTO resDTO = userService.getUserAddresses(userId, pageable);
        return ApiResponse.success(resDTO);
    }

    @GetMapping("/addresses/{addressId}")
    public ApiResponse<UserAddressResDTO.AddressDTO> getUserAddressDetail(@AuthenticationPrincipal User principal,
                                                                          @PathVariable Long addressId) {
        Long userId = getUserId(principal);
        log.info("Getting address detail {} for user {}", addressId, userId);
        UserAddressResDTO.AddressDTO resDTO = userService.getUserAddressDetail(userId, addressId);
        return ApiResponse.success(resDTO);
    }

    @PostMapping("/addresses")
    public ApiResponse<UserAddressResDTO.AddressDTO> createUserAddress(@AuthenticationPrincipal User principal,
                                                                       @Valid @RequestBody UserAddressCreateReqDTO reqDTO) {
        Long userId = getUserId(principal);
        log.info("Creating address for user {}: {}", userId, reqDTO.getDetail());
        UserAddressResDTO.AddressDTO resDTO = userService.createUserAddress(userId, reqDTO);
        return ApiResponse.success(resDTO);
    }

    @PutMapping("/addresses/{addressId}")
    public ApiResponse<UserAddressResDTO.AddressDTO> updateUserAddress(@AuthenticationPrincipal User principal,
                                                                       @PathVariable Long addressId,
                                                                       @Valid @RequestBody UserAddressCreateReqDTO reqDTO) {
        Long userId = getUserId(principal);
        log.info("Updating address {} for user {}: {}", addressId, userId, reqDTO.getDetail());
        UserAddressResDTO.AddressDTO resDTO = userService.updateUserAddress(userId, addressId, reqDTO);
        return ApiResponse.success(resDTO);
    }

    @DeleteMapping("/addresses/{addressId}")
    public ApiResponse<Void> deleteUserAddress(@AuthenticationPrincipal User principal,
                                               @PathVariable Long addressId) {
        Long userId = getUserId(principal);
        log.info("Deleting address {} for user {}", addressId, userId);
        userService.deleteUserAddress(userId, addressId);
        return ApiResponse.success();
    }

    @PutMapping("/addresses/{addressId}/default")
    public ApiResponse<Void> setDefaultUserAddress(@AuthenticationPrincipal User principal,
                                                   @PathVariable Long addressId) {
        Long userId = getUserId(principal);
        log.info("Setting address {} as default for user {}", addressId, userId);
        userService.setDefaultUserAddress(userId, addressId);
        return ApiResponse.success();
    }

    @GetMapping("/share-info")
    public ApiResponse<ShareInfoResDTO> getShareInfo(@AuthenticationPrincipal User principal) {
        Long userId = getUserId(principal);
        log.info("Getting share info for user: {}", userId);
        ShareInfoResDTO resDTO = userService.getShareInfo(userId);
        return ApiResponse.success(resDTO);
    }

    @PostMapping("/generate-poster")
    public ApiResponse<GeneratePosterResDTO> generateSharePoster(@AuthenticationPrincipal User principal,
                                                                 @Valid @RequestBody GeneratePosterReqDTO reqDTO) {
        Long userId = getUserId(principal);
        log.info("Generating share poster for user: {}", userId);
        GeneratePosterResDTO resDTO = userService.generateSharePoster(userId, reqDTO);
        return ApiResponse.success(resDTO);
    }

    @PostMapping("/share-record")
    public ApiResponse<Void> recordShare(@AuthenticationPrincipal User principal,
                                         @Valid @RequestBody ShareRecordReqDTO reqDTO) {
        Long userId = getUserId(principal);
        log.info("Recording share for user {}: type={}, targetId={}, channel={}", userId, reqDTO.getType(), reqDTO.getTargetId(), reqDTO.getChannel());
        userService.recordShare(userId, reqDTO);
        return ApiResponse.success();
    }

    @PostMapping("/send-verification-code")
    public ApiResponse<Void> sendVerificationCode(@RequestParam String phone,
                                                  @RequestParam String type) {
        log.info("Sending verification code to phone {} for type {}", phone, type);
        userService.sendVerificationCode(phone, type);
        return ApiResponse.success();
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\controller\websocket\OrderWebSocketHandler.java ---
// File: milktea-backend/src/main/java/com.milktea.app/controller/websocket/OrderWebSocketHandler.java
package com.milktea.app.controller.websocket;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.milktea.app.dto.order.OrderStatusChangedWsDTO;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.stereotype.Component;

import java.util.Collections;
import java.util.Map;

@Component
@RequiredArgsConstructor
@Slf4j
public class OrderWebSocketHandler {

    private final SimpMessagingTemplate messagingTemplate;
    private final ObjectMapper objectMapper;

    /**
     * Sends an order status update to a specific user.
     * The destination pattern is /user/{userId}/queue/orders/status
     *
     * @param userId The ID of the user to send the message to.
     * @param dto The DTO containing the order status changed information.
     */
    public void sendOrderStatusUpdate(Long userId, OrderStatusChangedWsDTO dto) {
        String destination = "/queue/orders/status"; // Relative to /user/{userId}
        log.info("Sending order status update to user {} at destination {}: {}", userId, destination, dto.getData().getNewStatus());
        // SimpMessagingTemplate automatically prepends /user/{userId} when sending to /queue
        messagingTemplate.convertAndSendToUser(String.valueOf(userId), destination, dto);
    }

    /**
     * Sends an order status update to a general topic (e.g., for admin dashboards).
     * The destination pattern is /topic/orders/status
     *
     * @param dto The DTO containing the order status changed information.
     */
    public void broadcastOrderStatusUpdate(OrderStatusChangedWsDTO dto) {
        String destination = "/topic/orders/status";
        log.info("Broadcasting order status update to destination {}: {}", destination, dto.getData().getNewStatus());
        messagingTemplate.convertAndSend(destination, dto);
    }

    // You can also add methods to send general notifications, messages etc.
    // For example:
    // public void sendUserNotification(Long userId, String message) {
    //     messagingTemplate.convertAndSendToUser(String.valueOf(userId), "/queue/notifications", message);
    // }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\auth\AccountLoginReqDTO.java ---
// File: milktea-backend/src/main/java/com/milktea.app/dto/auth/AccountLoginReqDTO.java
package com.milktea.app.dto.auth;

import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class AccountLoginReqDTO {
    @NotBlank(message = "用户名/手机号/邮箱不能为空")
    private String username;
    @NotBlank(message = "密码不能为空")
    private String password;
    private String captcha; // Optional
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\auth\UserAuthResDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/auth/UserAuthResDTO.java
package com.milktea.app.dto.auth;

import com.milktea.app.dto.user.UserProfileResDTO;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserAuthResDTO {
    private String token;
    private UserProfileResDTO.UserDetailDTO user; // Nested UserProfileResDTO
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\auth\WechatLoginReqDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/auth/WechatLoginReqDTO.java
package com.milktea.app.dto.auth;

import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class WechatLoginReqDTO {
    @NotBlank(message = "微信登录码不能为空")
    private String code;
    private UserInfo userInfo; // Optional, if mini-program provides it
    private String encryptedData; // Optional for data decryption
    private String iv; // Optional for data decryption

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class UserInfo {
        private String nickName;
        private String avatarUrl;
        private Integer gender; // 0:未知, 1:男, 2:女
        private String country;
        private String province;
        private String city;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\cart\CartBatchOperationReqDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/cart/CartBatchOperationReqDTO.java
package com.milktea.app.dto.cart;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotEmpty;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CartBatchOperationReqDTO {
    @NotBlank(message = "操作类型不能为空")
    private String action; // select_all, unselect_all, delete_selected
    @NotEmpty(message = "购物车项ID列表不能为空", groups = {SpecificOperation.class}) // For delete_selected etc.
    private List<Long> itemIds;

    // Validation groups
    public interface SpecificOperation {}
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\cart\CartItemAddReqDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/cart/CartItemAddReqDTO.java
package com.milktea.app.dto.cart;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CartItemAddReqDTO {
    @NotNull(message = "商品ID不能为空")
    private Long productId;
    @Min(value = 1, message = "购买数量不能小于1")
    private Integer quantity;
    private Customization choices; // Renamed from customizations to avoid conflict with method

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class Customization {
        private String sweetness;
        private String temperature;
        private List<ToppingItem> toppings;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ToppingItem {
        private String id;
        @Min(value = 1, message = "加料数量不能小于1")
        private Integer quantity;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\cart\CartItemUpdateReqDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/cart/CartItemUpdateReqDTO.java
package com.milktea.app.dto.cart;

import jakarta.validation.constraints.Min;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CartItemUpdateReqDTO {
    @Min(value = 1, message = "购买数量不能小于1")
    private Integer quantity;
    private Customization choices; // Renamed from customizations to avoid conflict with method

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class Customization {
        private String sweetness;
        private String temperature;
        private List<CartItemAddReqDTO.ToppingItem> toppings;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\cart\CartResDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/cart/CartResDTO.java
package com.milktea.app.dto.cart;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CartResDTO {
    private List<CartItemDTO> items;
    private CartSummaryDTO summary;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class CartItemDTO {
        private Long id;
        private Long productId;
        private String productName;
        private String productImage;
        private BigDecimal price;
        private BigDecimal originalPrice;
        private Integer quantity;
        private Integer maxQuantity;
        private Integer stock;
        private CustomizationsDTO customizations;
        private BigDecimal subtotal;
        private Boolean isSelected;
        private Boolean isValid;
        private String invalidReason;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class CustomizationsDTO {
        private OptionDTO sweetness;
        private OptionDTO temperature;
        private List<ToppingDTO> toppings;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class OptionDTO {
        private String value;
        private String label;
        private BigDecimal price;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ToppingDTO {
        private String id;
        private String name;
        private BigDecimal price;
        private Integer quantity;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class CartSummaryDTO {
        private Integer totalQuantity;
        private Integer selectedQuantity;
        private BigDecimal totalAmount;
        private BigDecimal selectedAmount;
        private BigDecimal totalDiscount;
        private BigDecimal deliveryFee;
        private BigDecimal finalAmount;
        private Integer validItemCount;
        private Integer invalidItemCount;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\category\CategoryTreeResDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/category/CategoryTreeResDTO.java
package com.milktea.app.dto.category;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CategoryTreeResDTO {
    private Long id;
    private Long parentId; // Null for top-level categories
    private String name;
    private String icon;
    private String image;
    private Integer sort;
    private String description;
    private Integer productCount;
    private List<CategoryTreeResDTO> children;
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\coupon\CouponBatchReceiveReqDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/coupon/CouponBatchReceiveReqDTO.java
package com.milktea.app.dto.coupon;

import jakarta.validation.constraints.NotEmpty;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CouponBatchReceiveReqDTO {
    @NotEmpty(message = "优惠券ID列表不能为空")
    private List<Long> couponIds;
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\coupon\CouponListResDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/coupon/CouponListResDTO.java
package com.milktea.app.dto.coupon;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CouponListResDTO {
    private List<CouponDTO> coupons;
    private Integer total;
    private Integer page;
    private Integer limit;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class CouponDTO {
        private Long id;
        private String name;
        private String type; // discount, percentage, fixed
        private BigDecimal value;
        private BigDecimal minAmount;
        private String description;
        private String usage; // all, category, product
        private List<String> targetIds;
        private String status; // available, used, expired
        private Instant receivedAt;
        private Instant expireAt;
        private Instant usedAt;
        private Long orderId;
        private Boolean canUse;
        private String unusableReason;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\coupon\CouponReceiveResDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/coupon/CouponReceiveResDTO.java
package com.milktea.app.dto.coupon;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CouponReceiveResDTO {
    private Boolean success;
    private Long couponId;
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\file\FileUploadResDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/file/FileUploadResDTO.java
package com.milktea.app.dto.file;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class FileUploadResDTO {
    private String url;
    private String path;
    private Integer size;
    private String type;
    private Integer width;
    private Integer height;
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\home\HomePageResDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/home/HomePageResDTO.java
package com.milktea.app.dto.home;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class HomePageResDTO {
    private List<BannerDTO> banners;
    private List<QuickEntryDTO> quickEntries;
    private RecommendProductsDTO recommendProducts;
    private List<CategoryDTO> categories;
    private List<HotProductDTO> hotProducts;
    private List<PromotionDTO> promotions;
    private NearbyStoreDTO nearbyStore;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class BannerDTO {
        private String id;
        private String image;
        private String title;
        private String subtitle;
        private String type;
        private String targetId;
        private String url;
        private String backgroundColor;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class QuickEntryDTO {
        private String id;
        private String icon;
        private String name;
        private String type;
        private String targetId;
        private String badge;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class RecommendProductsDTO {
        private String title;
        private List<ProductItemDTO> products;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ProductItemDTO {
        private String id;
        private String name;
        private String image;
        private BigDecimal price;
        private BigDecimal originalPrice;
        private Integer sales;
        private List<String> tags;
        private String description;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class CategoryDTO {
        private String id;
        private String name;
        private String icon;
        private String image;
        private Integer productCount;
        private String description;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class HotProductDTO {
        private String id;
        private Integer rank;
        private String name;
        private String image;
        private BigDecimal price;
        private BigDecimal rating;
        private Integer monthlySales;
        private BigDecimal increaseRate;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class PromotionDTO {
        private String id;
        private String title;
        private String subtitle;
        private String image;
        private String type;
        private BigDecimal value;
        private Instant startTime;
        private Instant endTime;
        private String buttonText;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class NearbyStoreDTO {
        private String id;
        private String name;
        private String address;
        private Integer distance;
        private String businessHours;
        private String status;
        private String phone;
        private List<String> services;
        private BigDecimal deliveryFee;
        private BigDecimal minimumOrderAmount;
        private BigDecimal rating;
        private List<String> tags;
        private List<String> images;
        private Integer currentWaitTime;
        private Boolean isFavorite;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\member\MemberInfoResDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/member/MemberInfoResDTO.java
package com.milktea.app.dto.member;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDate;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class MemberInfoResDTO {
    private String level;
    private String levelName;
    private Integer growthValue;
    private String nextLevel;
    private String nextLevelName;
    private Integer needGrowthValue;
    private LocalDate expireDate;
    private List<PrivilegeDTO> privileges;
    private BirthdayGiftDTO birthdayGift;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class PrivilegeDTO {
        private String id;
        private String name;
        private String icon;
        private String description;
        private String status;
        private LocalDate availableDate;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class BirthdayGiftDTO {
        private Boolean available;
        private List<GiftItemDTO> gifts;
        private LocalDate expireDate;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class GiftItemDTO {
        private String type;
        private String name;
        private String value;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\notification\NotificationBatchReadReqDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/notification/NotificationBatchReadReqDTO.java
package com.milktea.app.dto.notification;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class NotificationBatchReadReqDTO {
    private List<Long> ids;
    private Boolean all;
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\notification\NotificationListResDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/notification/NotificationListResDTO.java
package com.milktea.app.dto.notification;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;
import java.util.Map;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class NotificationListResDTO {
    private List<NotificationDTO> notifications;
    private Integer unreadCount;
    private Integer total;
    private Integer page;
    private Integer limit;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class NotificationDTO {
        private Long id;
        private String type;
        private String title;
        private String content;
        private Map<String, Object> data; // For additional JSON data
        private Boolean isRead;
        private Instant createdAt;
        private Instant readAt;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\order\CheckoutReqDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/order/CheckoutReqDTO.java
package com.milktea.app.dto.order;

import jakarta.validation.constraints.NotEmpty;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CheckoutReqDTO {
    @NotEmpty(message = "购物车项ID列表不能为空")
    private List<Long> itemIds;
    private Long addressId;
    private Long couponId;
    private String remark;
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\order\CheckoutResDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/order/CheckoutResDTO.java
package com.milktea.app.dto.order;

import com.milktea.app.dto.coupon.CouponListResDTO;
import com.milktea.app.dto.home.HomePageResDTO;
import com.milktea.app.dto.user.UserAddressResDTO;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CheckoutResDTO {
    private List<OrderItemSummaryDTO> orderItems;
    private UserAddressResDTO.AddressDTO address;
    private List<CouponListResDTO.CouponDTO> availableCoupons;
    private CouponListResDTO.CouponDTO selectedCoupon;
    private OrderSummaryDTO summary;
    private Integer availablePoints;
    private Integer pointsRate;
    private BigDecimal balance;
    private DeliveryTimeDTO deliveryTime;
    private HomePageResDTO.NearbyStoreDTO store;
    private BigDecimal minimumOrderAmount;
    private String remark;
    private List<WarningDTO> warnings;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class OrderItemSummaryDTO {
        private Long productId;
        private String productName;
        private String productImage;
        private Integer quantity;
        private BigDecimal price;
        private CustomizationsDTO customizations;
        private BigDecimal subtotal;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class CustomizationsDTO {
        private String sweetness;
        private String temperature;
        private List<String> toppings;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class OrderSummaryDTO {
        private BigDecimal productAmount;
        private BigDecimal deliveryFee;
        private BigDecimal packageFee;
        private BigDecimal discount;
        private BigDecimal totalAmount;
        private BigDecimal pointsDiscount;
        private BigDecimal balanceDiscount;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class DeliveryTimeDTO {
        private LocalDate date;
        private String timeRange;
        private Boolean isToday;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class WarningDTO {
        private String type;
        private String message;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\order\OrderCancelReqDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/order/OrderCancelReqDTO.java
package com.milktea.app.dto.order;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderCancelReqDTO {
    private String reason;
    private String remark;
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\order\OrderCreateReqDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/order/OrderCreateReqDTO.java
package com.milktea.app.dto.order;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderCreateReqDTO {
    @NotBlank(message = "订单类型不能为空")
    private String type; // delivery, pickup
    @NotEmpty(message = "订单商品列表不能为空")
    private List<OrderItemCreateDTO> items;
    private Long addressId; // Required for delivery
    private Long storeId; // Required for pickup
    private Long couponId;
    private Integer points;
    private BigDecimal balance;
    private Instant deliveryTime; // Expected delivery time
    private String remark;
    private InvoiceDTO invoice;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class OrderItemCreateDTO {
        @NotNull(message = "商品ID不能为空")
        private Long productId;
        @NotNull(message = "商品数量不能为空")
        private Integer quantity;
        private Customization customizations;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class Customization {
        private String sweetness;
        private String temperature;
        private List<ToppingItem> toppings;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ToppingItem {
        private String id;
        private Integer quantity;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class InvoiceDTO {
        @NotBlank(message = "发票类型不能为空")
        private String type; // personal, company
        @NotBlank(message = "发票抬头不能为空")
        private String title;
        private String taxNumber; // Required for company
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\order\OrderCreateResDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/order/OrderCreateResDTO.java
package com.milktea.app.dto.order;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.Instant;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderCreateResDTO {
    private Long orderId;
    private String orderNo;
    private BigDecimal totalAmount;
    private BigDecimal payAmount;
    private Integer pointsUsed;
    private BigDecimal balanceUsed;
    private BigDecimal couponAmount;
    private Boolean needPay;
    private PayInfoDTO payInfo;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class PayInfoDTO {
        private String payId;
        private String payType;
        private BigDecimal payAmount;
        private Instant expireTime;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\order\OrderDetailResDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/order/OrderDetailResDTO.java
package com.milktea.app.dto.order;

import com.milktea.app.dto.coupon.CouponListResDTO;
import com.milktea.app.dto.home.HomePageResDTO;
import com.milktea.app.dto.user.UserAddressResDTO;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderDetailResDTO {
    private Long id;
    private String orderNo;
    private String status;
    private String statusText;
    private List<OrderStatusTimelineDTO> statusTimeline;
    private String type;
    private List<OrderItemDetailDTO> items;
    private OrderSummaryDetailDTO summary;
    private UserAddressResDTO.AddressDTO address;
    private HomePageResDTO.NearbyStoreDTO store;
    private DeliveryInfoDTO deliveryInfo;
    private PickupInfoDTO pickupInfo;
    private PaymentDetailDTO payment;
    private CouponListResDTO.CouponDTO coupon;
    private Integer pointsUsed;
    private BigDecimal balanceUsed;
    private String remark;
    private InvoiceDetailDTO invoice;
    private Instant createdAt;
    private Instant updatedAt;
    private List<String> actions;
    private Instant cancelDeadline;
    private Instant refundDeadline;
    private Instant rateDeadline;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class OrderStatusTimelineDTO {
        private String status;
        private String text;
        private Instant time;
        private Boolean completed;
        private Boolean current;
        private Instant estimatedTime;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class OrderItemDetailDTO {
        private Long productId;
        private String productName;
        private String productImage;
        private Integer quantity;
        private BigDecimal price;
        private BigDecimal originalPrice;
        private CustomizationsDetailDTO customizations;
        private BigDecimal subtotal;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class CustomizationsDetailDTO {
        private String sweetness;
        private String temperature;
        private List<ToppingDetailDTO> toppings;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ToppingDetailDTO {
        private String name;
        private BigDecimal price;
        private Integer quantity;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class OrderSummaryDetailDTO {
        private BigDecimal productAmount;
        private BigDecimal deliveryFee;
        private BigDecimal packageFee;
        private BigDecimal discount;
        private Integer pointsDiscount;
        private BigDecimal balanceDiscount;
        private BigDecimal totalAmount;
        private BigDecimal payAmount;
        private Integer pointsEarned;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class DeliveryInfoDTO {
        private Instant deliveryTime;
        private Instant estimatedArrival;
        private String riderName;
        private String riderPhone;
        private RiderLocationDTO riderLocation;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class RiderLocationDTO {
        private BigDecimal longitude;
        private BigDecimal latitude;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class PickupInfoDTO {
        private String pickupCode;
        private Instant pickupTime;
        private Instant estimatedReadyTime;
        private String counterNumber;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class PaymentDetailDTO {
        private String payType;
        private BigDecimal payAmount;
        private Instant payTime;
        private String transactionId;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class InvoiceDetailDTO {
        private String type;
        private String title;
        private String status;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\order\OrderListResDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/order/OrderListResDTO.java
package com.milktea.app.dto.order;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;
import java.util.Map;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderListResDTO {
    private List<OrderSummaryDTO> orders;
    private Integer total;
    private Integer page;
    private Integer limit;
    private OrderStatsDTO stats;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class OrderSummaryDTO {
        private Long id;
        private String orderNo;
        private String status;
        private String statusText;
        private String type;
        private BigDecimal totalAmount;
        private BigDecimal payAmount;
        private Integer itemCount;
        private List<OrderItemBriefDTO> items;
        private String storeName;
        private String address;
        private Instant deliveryTime;
        private Instant createdAt;
        private Boolean needAction;
        private List<String> actions;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class OrderItemBriefDTO {
        private String productName;
        private String productImage;
        private Integer quantity;
        private BigDecimal price;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class OrderStatsDTO {
        private Integer all;
        private Integer pending;
        private Integer paid;
        private Integer making;
        private Integer ready;
        private Integer completed;
        private Integer cancelled;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\order\OrderRefundApplyReqDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/order/OrderRefundApplyReqDTO.java
package com.milktea.app.dto.order;

import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderRefundApplyReqDTO {
    @NotBlank(message = "退款原因不能为空")
    private String reason;
    private String description;
    private List<String> images;
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\order\OrderReviewReqDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/order/OrderReviewReqDTO.java
package com.milktea.app.dto.order;

import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderReviewReqDTO {
    @NotNull(message = "评分不能为空")
    @Min(value = 1, message = "评分不能小于1")
    @Max(value = 5, message = "评分不能大于5")
    private Integer rating;
    private String content;
    private List<String> images;
    private List<String> tags;
    private Boolean anonymous;
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\order\OrderStatusChangedWsDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/order/OrderStatusChangedWsDTO.java
package com.milktea.app.dto.order;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderStatusChangedWsDTO {
    private String type; // Should be "order_status_changed"
    private OrderStatusChangedData data;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class OrderStatusChangedData {
        private Long orderId;
        private String orderNo;
        private String oldStatus;
        private String newStatus;
        private String statusText;
        private Long timestamp; // Unix timestamp in milliseconds
        private Instant estimatedReadyTime;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\order\OrderValidateReqDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/order/OrderValidateReqDTO.java
package com.milktea.app.dto.order;

import jakarta.validation.constraints.NotEmpty;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderValidateReqDTO {
    @NotEmpty(message = "购物车项ID列表不能为空")
    private List<Long> itemIds;
    private Long addressId;
    private Long couponId;
    private String remark;
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\order\OrderValidateResDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/order/OrderValidateResDTO.java
package com.milktea.app.dto.order;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderValidateResDTO {
    private Boolean isValid;
    private List<InvalidItemDTO> invalidItems;
    private List<WarningDTO> warnings;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class InvalidItemDTO {
        private Long itemId;
        private String reason; // stock_out, price_changed, product_offline
        private String message;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class WarningDTO {
        private String type; // time_limit
        private String message;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\order\PaymentReqDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/order/PaymentReqDTO.java
package com.milktea.app.dto.order;

import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class PaymentReqDTO {
    @NotBlank(message = "支付方式不能为空")
    private String payType; // alipay, wechat
    @NotBlank(message = "支付渠道不能为空")
    private String channel; // miniprogram, app, h5
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\order\PaymentResDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/order/PaymentResDTO.java
package com.milktea.app.dto.order;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.util.Map;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class PaymentResDTO {
    private String payId;
    private String orderNo;
    private BigDecimal payAmount;
    private String payType;
    private Map<String, String> payParams; // Varies by payment gateway
    private Boolean alipaySandbox; // Specific for Alipay
    private String paymentUrl; // For H5 payments
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\order\PaymentStatusResDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/order/PaymentStatusResDTO.java
package com.milktea.app.dto.order;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.Instant;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class PaymentStatusResDTO {
    private Long orderId;
    private String payStatus; // unpaid, paid, failed
    private Instant payTime;
    private BigDecimal payAmount;
    private String transactionId;
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\point\PointExchangeReqDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/point/PointExchangeReqDTO.java
package com.milktea.app.dto.point;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class PointExchangeReqDTO {
    @NotNull(message = "兑换项ID不能为空")
    private Long itemId;
    @Min(value = 1, message = "兑换数量不能小于1")
    private Integer quantity;
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\point\PointTransactionListResDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/point/PointTransactionListResDTO.java
package com.milktea.app.dto.point;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;
import java.time.LocalDate;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class PointTransactionListResDTO {
    private List<PointTransactionDTO> transactions;
    private Integer total;
    private Integer page;
    private Integer limit;
    private PointSummaryDTO summary;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class PointTransactionDTO {
        private Long id;
        private String type;
        private Integer points;
        private Integer balance;
        private String description;
        private String relatedId;
        private String relatedType;
        private Instant createdAt;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class PointSummaryDTO {
        private Integer totalPoints;
        private Integer availablePoints;
        private Integer frozenPoints;
        private Integer expiringPoints;
        private LocalDate expireDate;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\product\ProductDetailResDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/product/ProductDetailResDTO.java
package com.milktea.app.dto.product;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProductDetailResDTO {
    private Long id;
    private String name;
    private String subtitle;
    private List<String> images;
    private String mainImage;
    private Long categoryId;
    private String categoryName;
    private BigDecimal price;
    private BigDecimal originalPrice;
    private String unit;
    private Integer stock;
    private Integer sales;
    private Integer monthlySales;
    private BigDecimal rating;
    private Integer ratingCount;
    private Integer favoriteCount;
    private Boolean isHot;
    private Boolean isNew;
    private Boolean isRecommend;
    private List<String> tags;
    private String description;
    private String detailHtml;
    private CustomizationsDTO customizations;
    private List<NutritionDTO> nutrition;
    private List<String> ingredients;
    private List<String> allergens;
    private String storage;
    private String shelfLife;
    private List<RelatedProductDTO> relatedProducts;
    private Instant createdAt;
    private Instant updatedAt;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class CustomizationsDTO {
        private CustomizationTypeDTO sweetness;
        private CustomizationTypeDTO temperature;
        private ToppingsCustomizationDTO toppings;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class CustomizationTypeDTO {
        private Boolean enabled;
        private Boolean required;
        private List<OptionDTO> options;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ToppingsCustomizationDTO {
        private Boolean enabled;
        private Boolean required;
        private Integer max;
        private List<ToppingOptionDTO> options;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class OptionDTO {
        private String value;
        private String label;
        private BigDecimal price;
        private Boolean isDefault;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ToppingOptionDTO {
        private String id;
        private String name;
        private BigDecimal price;
        private Integer stock;
        private String icon;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class NutritionDTO {
        private String name;
        private String value;
        private String unit;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class RelatedProductDTO {
        private Long id;
        private String name;
        private String image;
        private BigDecimal price;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\product\ProductFavoriteStatusResDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/product/ProductFavoriteStatusResDTO.java
package com.milktea.app.dto.product;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProductFavoriteStatusResDTO {
    private Boolean isFavorite;
    private Long favoriteId; // The ID of the UserFavoriteProductEntity if favorited
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\product\ProductListReqDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/product/ProductListReqDTO.java
package com.milktea.app.dto.product;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProductListReqDTO {
    private Integer page;
    private Integer limit;
    private String sort; // sales, price_asc, price_desc, newest
    private String filter; // sugar_free, hot, ice
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\product\ProductListResDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/product/ProductListResDTO.java
package com.milktea.app.dto.product;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProductListResDTO {
    private List<ProductItemDTO> products;
    private Integer total;
    private Integer page;
    private Integer limit;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ProductItemDTO {
        private Long id;
        private String name;
        private String image;
        private BigDecimal price;
        private BigDecimal originalPrice;
        private Integer sales;
        private List<String> tags;
        private String description;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\search\ProductSearchReqDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/search/ProductSearchReqDTO.java
package com.milktea.app.dto.search;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProductSearchReqDTO {
    private String keyword;
    private Long categoryId;
    private BigDecimal minPrice;
    private BigDecimal maxPrice;
    private String sort; // relevance, sales, price_asc, price_desc
    private Integer page;
    private Integer limit;
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\search\ProductSearchResDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/search/ProductSearchResDTO.java
package com.milktea.app.dto.search;

import com.milktea.app.dto.category.CategoryTreeResDTO;
import com.milktea.app.dto.product.ProductListResDTO;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProductSearchResDTO {
    private List<ProductListResDTO.ProductItemDTO> products;
    private Integer total;
    private List<String> suggestions;
    private List<CategoryTreeResDTO> relatedCategories;
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\search\SearchHistoryReqDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/search/SearchHistoryReqDTO.java
package com.milktea.app.dto.search;

import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class SearchHistoryReqDTO {
    @NotBlank(message = "搜索词不能为空")
    private String keyword;
    private String type; // product, category
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\search\SearchHotKeywordsResDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/search/SearchHotKeywordsResDTO.java
package com.milktea.app.dto.search;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class SearchHotKeywordsResDTO {
    private List<KeywordDTO> keywords;
    private List<String> history;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class KeywordDTO {
        private String word;
        private Integer count;
        private String type; // hot, new
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\search\SearchSuggestResDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/search/SearchSuggestResDTO.java
package com.milktea.app.dto.search;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class SearchSuggestResDTO {
    private List<String> suggestions;
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\store\StoreDetailResDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/store/StoreDetailResDTO.java
package com.milktea.app.dto.store;

import com.milktea.app.dto.home.HomePageResDTO;
import lombok.Data; // @Data 包含 getter/setter/toString/equals/hashCode

@Data
// @NoArgsConstructor // 移除
// @AllArgsConstructor // 移除
public class StoreDetailResDTO extends HomePageResDTO.NearbyStoreDTO {

    // 手动添加一个无参构造器，并显式调用父类的无参构造器 (如果父类有)
    // 如果父类没有 public 无参构造器，这个地方就需要调整了
    public StoreDetailResDTO() {
        super(); // 假设父类有 public 的无参构造器
    }

    // 如果需要有参构造器（根据父类和其他字段决定）
    // public StoreDetailResDTO(FieldType field1, ...) {
    //     super(parentField1, ...);
    //     this.field1 = field1;
    //     ...
    // }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\store\StoreNearbyReqDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/store/StoreNearbyReqDTO.java
package com.milktea.app.dto.store;

import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class StoreNearbyReqDTO {
    @NotNull(message = "经度不能为空")
    private BigDecimal longitude;
    @NotNull(message = "纬度不能为空")
    private BigDecimal latitude;
    @Min(value = 100, message = "查询半径不能小于100米")
    @Max(value = 100000, message = "查询半径不能大于100公里")
    private Integer radius; // In meters
    @Min(value = 1, message = "查询数量不能小于1")
    private Integer limit;
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\store\StoreNearbyResDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/store/StoreNearbyResDTO.java
package com.milktea.app.dto.store;

import com.milktea.app.dto.home.HomePageResDTO;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class StoreNearbyResDTO {
    private List<HomePageResDTO.NearbyStoreDTO> stores;
    private CurrentLocationDTO currentLocation;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class CurrentLocationDTO {
        private BigDecimal longitude;
        private BigDecimal latitude;
        private String address;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\system\PageConfigResDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/system/PageConfigResDTO.java
package com.milktea.app.dto.system;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class PageConfigResDTO {
    private String pageName;
    private List<ConfigItemDTO> configItems;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ConfigItemDTO {
        private String key;
        private String value;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\system\SystemConfigResDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/system/SystemConfigResDTO.java
package com.milktea.app.dto.system;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class SystemConfigResDTO {
    private String appName;
    private String version;
    private String apiVersion;
    private Boolean maintenance;
    private String maintenanceMessage;
    private CustomerServiceConfigDTO customerService;
    private PointsConfigDTO pointsConfig;
    private DeliveryConfigDTO deliveryConfig;
    private PaymentConfigDTO paymentConfig;
    private NotificationConfigDTO notificationConfig;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class CustomerServiceConfigDTO {
        private String phone;
        private String wechat;
        private String workTime;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class PointsConfigDTO {
        private Integer rate;
        private BigDecimal earnRate;
        private BigDecimal maxUseRatio;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class DeliveryConfigDTO {
        private BigDecimal defaultFee;
        private BigDecimal freeThreshold;
        private Integer maxDistance;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class PaymentConfigDTO {
        private List<String> supportedMethods;
        private String defaultMethod;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class NotificationConfigDTO {
        private Boolean orderStatus;
        private Boolean promotion;
        private Boolean system;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\user\GeneratePosterReqDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/user/GeneratePosterReqDTO.java
package com.milktea.app.dto.user;

import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class GeneratePosterReqDTO {
    private String templateId;
    @NotBlank(message = "小程序路径不能为空")
    private String qrCodeContent;
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\user\GeneratePosterResDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/user/GeneratePosterResDTO.java
package com.milktea.app.dto.user;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class GeneratePosterResDTO {
    private String posterUrl;
    private Instant expireAt;
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\user\ShareInfoResDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/user/ShareInfoResDTO.java
package com.milktea.app.dto.user;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ShareInfoResDTO {
    private String title;
    private String description;
    private String image;
    private String path;
    private String inviteCode;
    private Integer inviteCount;
    private Integer rewardPoints;
    private RewardCouponDTO rewardCoupon;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class RewardCouponDTO {
        private String id;
        private String name;
        private BigDecimal amount;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\user\ShareRecordReqDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/user/ShareRecordReqDTO.java
package com.milktea.app.dto.user;

import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ShareRecordReqDTO {
    @NotBlank(message = "分享类型不能为空")
    private String type; // product, activity, invite
    @NotBlank(message = "目标ID不能为空")
    private String targetId;
    @NotBlank(message = "分享渠道不能为空")
    private String channel; // wechat, moments, qq
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\user\UserAddressCreateReqDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/user/UserAddressCreateReqDTO.java
package com.milktea.app.dto.user;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserAddressCreateReqDTO {
    @NotBlank(message = "收货人姓名不能为空")
    private String name;
    @NotBlank(message = "手机号不能为空")
    @Pattern(regexp = "^(13[0-9]|14[01456879]|15[0-35-9]|16[2567]|17[0-8]|18[0-9]|19[0-35-9])\\d{8}$", message = "手机号格式不正确")
    private String phone;
    @NotBlank(message = "省份不能为空")
    private String province;
    @NotBlank(message = "城市不能为空")
    private String city;
    private String district;
    @NotBlank(message = "详细地址不能为空")
    private String detail;
    private String postalCode;
    @NotNull(message = "是否默认地址不能为空")
    private Boolean isDefault;
    private String type; // home, company, school, other
    private String label;
    private BigDecimal longitude;
    private BigDecimal latitude;
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\user\UserAddressResDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/user/UserAddressResDTO.java
package com.milktea.app.dto.user;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserAddressResDTO {
    private List<AddressDTO> list;
    private Integer total;
    private Integer page;
    private Integer limit;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class AddressDTO {
        private Long id;
        private String name;
        private String phone;
        private String province;
        private String city;
        private String district;
        private String detail;
        private String postalCode;
        private Boolean isDefault;
        private String type;
        private String label;
        private BigDecimal longitude;
        private BigDecimal latitude;
        private Instant createdAt;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\user\UserPhoneUpdateReqDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/user/UserPhoneUpdateReqDTO.java
package com.milktea.app.dto.user;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserPhoneUpdateReqDTO {
    @NotBlank(message = "新手机号不能为空")
    @Pattern(regexp = "^(13[0-9]|14[01456879]|15[0-35-9]|16[2567]|17[0-8]|18[0-9]|19[0-35-9])\\d{8}$", message = "手机号格式不正确")
    private String phone;
    @NotBlank(message = "短信验证码不能为空")
    private String captcha;
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\user\UserProfileResDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/user/UserProfileResDTO.java
package com.milktea.app.dto.user;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserProfileResDTO {
    private Long id;
    private String nickname;
    private String avatar;
    private String phone;
    private String email;
    private Integer gender; // 1:男,2:女, 0:未知
    private LocalDate birthday;
    private String level; // gold
    private String levelName; // 黄金会员
    private Integer points;
    private BigDecimal balance;
    private Integer growthValue;
    private Integer nextLevelPoints;
    private Integer couponCount;
    private Integer unreadMessageCount;
    private MemberCardDTO memberCard;
    private Instant createdAt;

    // Separate DTO for the nested 'user' object in UserAuthResDTO
    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class UserDetailDTO {
        private String id; // Changed to String as per JSON spec, although Long in DB
        private String nickname;
        private String avatar;
        private String phone;
        private String level; // 0:普通, 1:黄金,2:钻石 (JSON spec says "gold" but then 0,1,2. I'll stick to string for DTO and map logic.)
        private Integer points;
        private BigDecimal balance;
        private LocalDate birthday;
        private Instant createdAt;
        private String levelName;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class MemberCardDTO {
        private String cardNo;
        private String status;
        private LocalDate expireDate;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\dto\user\UserProfileUpdateReqDTO.java ---
// File: milktea-backend/src/main/java/com.milktea.app/dto/user/UserProfileUpdateReqDTO.java
package com.milktea.app.dto.user;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDate;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserProfileUpdateReqDTO {
    @NotBlank(message = "昵称不能为空")
    private String nickname;
    private String avatar;
    private Integer gender;
    private LocalDate birthday;
    @Email(message = "邮箱格式不正确")
    private String email;
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\AllergenEntity.java ---
// File: milktea-backend/src/main/java/com/milktea/app/entity/AllergenEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;

@Entity
@Table(name = "allergens")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class AllergenEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "name", nullable = false, unique = true, length = 50)
    private String name;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\BannerEntity.java ---
// File: milktea-backend/src/main/java/com/milktea/app/entity/BannerEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;

@Entity
@Table(name = "banners")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class BannerEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "image_url", nullable = false)
    private String imageUrl;

    @Column(name = "title", length = 100)
    private String title;

    @Column(name = "subtitle", length = 100)
    private String subtitle;

    @Column(name = "type", nullable = false, length = 20)
    private String type; // product, activity, url

    @Column(name = "target_id", length = 50)
    private String targetId; // Corresponds to product_id, activity_id etc.

    @Column(name = "url")
    private String url;

    @Column(name = "background_color", length = 20)
    private String backgroundColor;

    @Column(name = "sort_order")
    private Integer sortOrder;

    @Column(name = "is_active", nullable = false)
    private Boolean isActive;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
        if (updatedAt == null) {
            updatedAt = Instant.now();
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = Instant.now();
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\CartItemCustomizationEntity.java ---
// File: milktea-backend/src/main/java/com/milktea/app/entity/CartItemCustomizationEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.Instant;

@Entity
@Table(name = "cart_item_customizations")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class CartItemCustomizationEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "cart_item_id", nullable = false)
    private CartItemEntity cartItem;

    @Column(name = "customization_type_name", nullable = false, length = 50)
    private String customizationTypeName; // sweetness, temperature, toppings

    @Column(name = "option_value", nullable = false, length = 50)
    private String optionValue; // no_sugar, no_ice, topping_1

    @Column(name = "option_label", nullable = false, length = 50)
    private String optionLabel;

    @Column(name = "price_adjustment_at_add", nullable = false, precision = 10, scale = 2)
    private BigDecimal priceAdjustmentAtAdd;

    @Column(name = "quantity", nullable = false)
    private Integer quantity;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\CartItemEntity.java ---
// File: milktea-backend/src/main/java/com/milktea/app/entity/CartItemEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;

@Entity
@Table(name = "cart_items", uniqueConstraints = {
        @UniqueConstraint(columnNames = {"user_id", "product_id"})
})
@Data
@NoArgsConstructor
@AllArgsConstructor
public class CartItemEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private UserEntity user;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    private ProductEntity product;

    @Column(name = "quantity", nullable = false)
    private Integer quantity;

    @Column(name = "is_selected", nullable = false)
    private Boolean isSelected;

    @Column(name = "is_valid", nullable = false)
    private Boolean isValid;

    @Column(name = "invalid_reason")
    private String invalidReason;

    @Column(name = "price_at_add", nullable = false, precision = 10, scale = 2)
    private BigDecimal priceAtAdd;

    @Column(name = "original_price_at_add", precision = 10, scale = 2)
    private BigDecimal originalPriceAtAdd;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;

    @OneToMany(mappedBy = "cartItem", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private List<CartItemCustomizationEntity> customizations;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
        if (updatedAt == null) {
            updatedAt = Instant.now();
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = Instant.now();
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\CategoryEntity.java ---
// File: milktea-backend/src/main/java/com/milktea/app/entity/CategoryEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;
import java.util.List;

@Entity
@Table(name = "categories")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class CategoryEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "parent_id")
    private CategoryEntity parent;

    @Column(name = "name", nullable = false, length = 50)
    private String name;

    @Column(name = "icon_url")
    private String iconUrl;

    @Column(name = "image_url")
    private String imageUrl;

    @Column(name = "description")
    private String description;

    @Column(name = "sort_order")
    private Integer sortOrder;

    @Column(name = "is_active", nullable = false)
    private Boolean isActive;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;

    @OneToMany(mappedBy = "parent", fetch = FetchType.LAZY)
    private List<CategoryEntity> children;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
        if (updatedAt == null) {
            updatedAt = Instant.now();
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = Instant.now();
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\CouponTemplateEntity.java ---
// File: milktea-backend/src/main/java/com/milktea/app/entity/CouponTemplateEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;

import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;

@Entity
@Table(name = "coupon_templates")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class CouponTemplateEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "name", nullable = false, length = 100)
    private String name;

    @Column(name = "type", nullable = false, length = 20)
    private String type; // discount, percentage, fixed

    @Column(name = "value", nullable = false, precision = 10, scale = 2)
    private BigDecimal value;

    @Column(name = "min_amount", nullable = false, precision = 10, scale = 2)
    private BigDecimal minAmount;

    @Column(name = "description")
    private String description;

    @Column(name = "usage_scope", nullable = false, length = 20)
    private String usageScope; // all, category, product

    @Column(name = "target_ids")
    @JdbcTypeCode(SqlTypes.JSON) // Use JdbcTypeCode for JSONB mapping
    private String targetIds; // JSON array of IDs

    @Column(name = "total_quantity", nullable = false)
    private Integer totalQuantity;

    @Column(name = "remaining_quantity", nullable = false)
    private Integer remainingQuantity;

    @Column(name = "validity_type", nullable = false, length = 20)
    private String validityType; // fixed_days, fixed_date_range

    @Column(name = "valid_days")
    private Integer validDays;

    @Column(name = "start_date")
    private LocalDate startDate;

    @Column(name = "end_date")
    private LocalDate endDate;

    @Column(name = "acquire_limit", nullable = false)
    private Integer acquireLimit;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;

    @Column(name = "is_active", nullable = false)
    private Boolean isActive;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
        if (updatedAt == null) {
            updatedAt = Instant.now();
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = Instant.now();
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\FileEntity.java ---
// File: milktea-backend/src/main/java/com/milktea/app/entity/FileEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;

@Entity
@Table(name = "files")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class FileEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private UserEntity user;

    @Column(name = "url", nullable = false)
    private String url;

    @Column(name = "path", nullable = false)
    private String path;

    @Column(name = "size")
    private Integer size; // in bytes

    @Column(name = "type", nullable = false, length = 20)
    private String type; // image, video, audio

    @Column(name = "category", length = 50)
    private String category; // avatar, comment, refund

    @Column(name = "width")
    private Integer width;

    @Column(name = "height")
    private Integer height;

    @Column(name = "mime_type", length = 50)
    private String mimeType;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\IngredientEntity.java ---
// File: milktea-backend/src/main/java/com/milktea/app/entity/IngredientEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;

@Entity
@Table(name = "ingredients")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class IngredientEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "name", nullable = false, unique = true, length = 50)
    private String name;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\MemberLevelEntity.java ---
// File: milktea-backend/src/main/java/com/milktea/app/entity/MemberLevelEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;

import java.time.Instant;

@Entity
@Table(name = "member_levels")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class MemberLevelEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "name", nullable = false, unique = true, length = 50)
    private String name;

    @Column(name = "min_growth_value", nullable = false)
    private Integer minGrowthValue;

    @Column(name = "description")
    private String description;

    @Column(name = "privileges_json")
    @JdbcTypeCode(SqlTypes.JSON) // Use JdbcTypeCode for JSONB mapping
    private String privilegesJson; // Store as JSON string

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
        if (updatedAt == null) {
            updatedAt = Instant.now();
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = Instant.now();
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\NotificationEntity.java ---
// File: milktea-backend/src/main/java/com/milktea/app/entity/NotificationEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;

import java.time.Instant;

@Entity
@Table(name = "notifications")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class NotificationEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private UserEntity user;

    @Column(name = "type", nullable = false, length = 20)
    private String type; // order, promotion, system

    @Column(name = "title", nullable = false, length = 100)
    private String title;

    @Column(name = "content", nullable = false)
    private String content;

    @Column(name = "data_json")
    @JdbcTypeCode(SqlTypes.JSON) // Use JdbcTypeCode for JSONB mapping
    private String dataJson; // Additional data as JSON string

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @Column(name = "is_read", nullable = false)
    private Boolean isRead;

    @Column(name = "read_at")
    private Instant readAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\OrderEntity.java ---
// File: milktea-backend/src/main/java/com/milktea/app/entity/OrderEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;

@Entity
@Table(name = "orders")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private UserEntity user;

    @Column(name = "order_no", nullable = false, unique = true, length = 50)
    private String orderNo;

    @Column(name = "type", nullable = false, length = 20)
    private String type; // delivery, pickup

    @Column(name = "status", nullable = false, length = 20)
    private String status; // created, paid, making, ready, completed, cancelled, refunded

    @Column(name = "status_text", length = 50)
    private String statusText;

    @Column(name = "total_amount", nullable = false, precision = 10, scale = 2)
    private BigDecimal totalAmount;

    @Column(name = "pay_amount", nullable = false, precision = 10, scale = 2)
    private BigDecimal payAmount;

    @Column(name = "product_amount", nullable = false, precision = 10, scale = 2)
    private BigDecimal productAmount;

    @Column(name = "delivery_fee", nullable = false, precision = 10, scale = 2)
    private BigDecimal deliveryFee;

    @Column(name = "package_fee", nullable = false, precision = 10, scale = 2)
    private BigDecimal packageFee;

    @Column(name = "discount_amount", nullable = false, precision = 10, scale = 2)
    private BigDecimal discountAmount;

    @Column(name = "points_discount_amount", nullable = false, precision = 10, scale = 2)
    private BigDecimal pointsDiscountAmount;

    @Column(name = "balance_discount_amount", nullable = false, precision = 10, scale = 2)
    private BigDecimal balanceDiscountAmount;

    @Column(name = "points_used", nullable = false)
    private Integer pointsUsed;

    @Column(name = "balance_used", nullable = false, precision = 10, scale = 2)
    private BigDecimal balanceUsed;

    @Column(name = "coupon_id")
    private Long couponId; // Note: DDL mentions avoiding FK here due to potential circular dependency

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "delivery_address_id")
    private UserAddressEntity deliveryAddress;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "pickup_store_id")
    private StoreEntity pickupStore;

    @Column(name = "delivery_time_expected")
    private Instant deliveryTimeExpected;

    @Column(name = "remark")
    private String remark;

    @Column(name = "invoice_type", length = 20)
    private String invoiceType;

    @Column(name = "invoice_title", length = 100)
    private String invoiceTitle;

    @Column(name = "invoice_tax_number", length = 50)
    private String invoiceTaxNumber;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;

    @Column(name = "estimated_ready_time")
    private Instant estimatedReadyTime;

    @Column(name = "estimated_arrival_time")
    private Instant estimatedArrivalTime;

    @Column(name = "rider_name", length = 50)
    private String riderName;

    @Column(name = "rider_phone", length = 20)
    private String riderPhone;

    @Column(name = "rider_longitude", precision = 10, scale = 7)
    private BigDecimal riderLongitude;

    @Column(name = "rider_latitude", precision = 10, scale = 7)
    private BigDecimal riderLatitude;

    @Column(name = "pickup_code", length = 20)
    private String pickupCode;

    @Column(name = "pickup_time_actual")
    private Instant pickupTimeActual;

    @Column(name = "counter_number", length = 20)
    private String counterNumber;

    @Column(name = "cancel_deadline")
    private Instant cancelDeadline;

    @Column(name = "refund_deadline")
    private Instant refundDeadline;

    @Column(name = "rate_deadline")
    private Instant rateDeadline;

    @Column(name = "is_rated", nullable = false)
    private Boolean isRated;

    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private List<OrderItemEntity> items;

    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private List<OrderStatusTimelineEntity> statusTimelines;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
        if (updatedAt == null) {
            updatedAt = Instant.now();
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = Instant.now();
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\OrderItemCustomizationEntity.java ---
// File: milktea-backend/src/main/java/com/milktea/app/entity/OrderItemCustomizationEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.Instant;

@Entity
@Table(name = "order_item_customizations")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderItemCustomizationEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "order_item_id", nullable = false)
    private OrderItemEntity orderItem;

    @Column(name = "customization_type_name", nullable = false, length = 50)
    private String customizationTypeName;

    @Column(name = "option_value", nullable = false, length = 50)
    private String optionValue;

    @Column(name = "option_label", nullable = false, length = 50)
    private String optionLabel;

    @Column(name = "price_adjustment_at_order", nullable = false, precision = 10, scale = 2)
    private BigDecimal priceAdjustmentAtOrder;

    @Column(name = "quantity", nullable = false)
    private Integer quantity;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\OrderItemEntity.java ---
// File: milktea-backend/src/main/java/com/milktea/app/entity/OrderItemEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;

@Entity
@Table(name = "order_items")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderItemEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "order_id", nullable = false)
    private OrderEntity order;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false, foreignKey = @ForeignKey(name = "fk_order_items_product_id_restrict"))
    private ProductEntity product;

    @Column(name = "product_name", nullable = false, length = 100)
    private String productName;

    @Column(name = "product_image_url")
    private String productImageUrl;

    @Column(name = "quantity", nullable = false)
    private Integer quantity;

    @Column(name = "price_at_order", nullable = false, precision = 10, scale = 2)
    private BigDecimal priceAtOrder;

    @Column(name = "original_price_at_order", precision = 10, scale = 2)
    private BigDecimal originalPriceAtOrder;

    @Column(name = "subtotal", nullable = false, precision = 10, scale = 2)
    private BigDecimal subtotal;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @OneToMany(mappedBy = "orderItem", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private List<OrderItemCustomizationEntity> customizations;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\OrderRefundEntity.java ---
// File: milktea-backend/src/main/java/com/milktea/app/entity/OrderRefundEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;

@Entity
@Table(name = "order_refunds")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderRefundEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "order_id", nullable = false)
    private OrderEntity order;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private UserEntity user;

    @Column(name = "reason", nullable = false, length = 100)
    private String reason;

    @Column(name = "description")
    private String description;

    @Column(name = "status", nullable = false, length = 20)
    private String status; // pending, approved, rejected, refunded

    @Column(name = "refund_amount", precision = 10, scale = 2)
    private BigDecimal refundAmount;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;

    @OneToMany(mappedBy = "refund", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private List<OrderRefundImageEntity> images;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
        if (updatedAt == null) {
            updatedAt = Instant.now();
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = Instant.now();
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\OrderRefundImageEntity.java ---
// File: milktea-backend/src/main/java/com/milktea/app/entity/OrderRefundImageEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;

@Entity
@Table(name = "order_refund_images")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderRefundImageEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "refund_id", nullable = false)
    private OrderRefundEntity refund;

    @Column(name = "image_url", nullable = false)
    private String imageUrl;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\OrderReviewEntity.java ---
// File: milktea-backend/src/main/java/com/milktea/app/entity/OrderReviewEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;
import java.util.List;

@Entity
@Table(name = "order_reviews", uniqueConstraints = {
        @UniqueConstraint(columnNames = {"order_id"})
})
@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderReviewEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "order_id", nullable = false)
    private OrderEntity order;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private UserEntity user;

    @Column(name = "rating", nullable = false)
    private Short rating; // 1-5

    @Column(name = "content")
    private String content;

    @Column(name = "is_anonymous", nullable = false)
    private Boolean isAnonymous;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;

    @OneToMany(mappedBy = "review", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private List<OrderReviewImageEntity> images;

    @ManyToMany
    @JoinTable(
            name = "order_review_tags_map",
            joinColumns = @JoinColumn(name = "review_id"),
            inverseJoinColumns = @JoinColumn(name = "tag_id")
    )
    private List<ReviewTagEntity> tags;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
        if (updatedAt == null) {
            updatedAt = Instant.now();
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = Instant.now();
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\OrderReviewImageEntity.java ---
// File: milktea-backend/src/main/java/com.milktea.app/entity/OrderReviewImageEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;

@Entity
@Table(name = "order_review_images")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderReviewImageEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "review_id", nullable = false)
    private OrderReviewEntity review;

    @Column(name = "image_url", nullable = false)
    private String imageUrl;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\OrderStatusTimelineEntity.java ---
// File: milktea-backend/src/main/java/com.milktea.app/entity/OrderStatusTimelineEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;

@Entity
@Table(name = "order_status_timelines")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderStatusTimelineEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "order_id", nullable = false)
    private OrderEntity order;

    @Column(name = "status", nullable = false, length = 20)
    private String status;

    @Column(name = "status_text", nullable = false, length = 50)
    private String statusText;

    @Column(name = "time", nullable = false)
    private Instant time;

    @Column(name = "is_current", nullable = false)
    private Boolean isCurrent;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\PageConfigEntity.java ---
// File: milktea-backend/src/main/java/com.milktea.app/entity/PageConfigEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;

@Entity
@Table(name = "page_configs", uniqueConstraints = {
        @UniqueConstraint(columnNames = {"page_name", "key"})
})
@Data
@NoArgsConstructor
@AllArgsConstructor
public class PageConfigEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "page_name", nullable = false, length = 50)
    private String pageName;

    @Column(name = "key", nullable = false, length = 100)
    private String key;

    @Column(name = "value")
    private String value; // Can store JSON string

    @Column(name = "description")
    private String description;

    @Column(name = "value_type", nullable = false, length = 20)
    private String valueType; // string, boolean, json, number

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
        if (updatedAt == null) {
            updatedAt = Instant.now();
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = Instant.now();
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\PaymentEntity.java ---
// File: milktea-backend/src/main/java/com.milktea.app/entity/PaymentEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.Instant;

@Entity
@Table(name = "payments")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class PaymentEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "order_id", nullable = false)
    private OrderEntity order;

    @Column(name = "pay_id", length = 100)
    private String payId; // Third-party payment order ID

    @Column(name = "transaction_id", length = 100)
    private String transactionId; // Payment platform transaction ID

    @Column(name = "pay_type", nullable = false, length = 20)
    private String payType; // alipay, wechat, balance

    @Column(name = "channel", length = 20)
    private String channel; // miniprogram, app, h5

    @Column(name = "pay_amount", nullable = false, precision = 10, scale = 2)
    private BigDecimal payAmount;

    @Column(name = "pay_status", nullable = false, length = 20)
    private String payStatus; // unpaid, paid, failed, cancelled

    @Column(name = "pay_time")
    private Instant payTime;

    @Column(name = "expire_time")
    private Instant expireTime;

    @Column(name = "is_sandbox", nullable = false)
    private Boolean isSandbox;

    @Column(name = "payment_url")
    private String paymentUrl;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
        if (updatedAt == null) {
            updatedAt = Instant.now();
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = Instant.now();
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\PointExchangeItemEntity.java ---
// File: milktea-backend/src/main/java/com.milktea.app/entity/PointExchangeItemEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;

@Entity
@Table(name = "point_exchange_items")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class PointExchangeItemEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "name", nullable = false, length = 100)
    private String name;

    @Column(name = "points_cost", nullable = false)
    private Integer pointsCost;

    @Column(name = "target_type", nullable = false, length = 20)
    private String targetType; // product, coupon_template

    @Column(name = "target_id")
    private Long targetId;

    @Column(name = "stock")
    private Integer stock;

    @Column(name = "image_url")
    private String imageUrl;

    @Column(name = "description")
    private String description;

    @Column(name = "is_active", nullable = false)
    private Boolean isActive;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
        if (updatedAt == null) {
            updatedAt = Instant.now();
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = Instant.now();
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\PointTransactionEntity.java ---
// File: milktea-backend/src/main/java/com.milktea.app/entity/PointTransactionEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;

@Entity
@Table(name = "point_transactions")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class PointTransactionEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private UserEntity user;

    @Column(name = "points_change", nullable = false)
    private Integer pointsChange;

    @Column(name = "balance_after_transaction", nullable = false)
    private Integer balanceAfterTransaction;

    @Column(name = "type", nullable = false, length = 20)
    private String type; // earn, use

    @Column(name = "description", nullable = false)
    private String description;

    @Column(name = "related_id", length = 50)
    private String relatedId;

    @Column(name = "related_type", length = 20)
    private String relatedType; // order, exchange_item

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\ProductAllergensMapEntity.java ---
// File: milktea-backend/src/main/java/com.milktea.app/entity/ProductAllergensMapEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

@Entity
@Table(name = "product_allergens_map")
@Data
@NoArgsConstructor
@AllArgsConstructor
@IdClass(ProductAllergensMapEntity.ProductAllergensMapId.class)
public class ProductAllergensMapEntity {

    @Id
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    private ProductEntity product;

    @Id
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "allergen_id", nullable = false)
    private AllergenEntity allergen;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ProductAllergensMapId implements Serializable {
        private Long product;
        private Long allergen;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\ProductCustomizationOptionEntity.java ---
// File: milktea-backend/src/main/java/com.milktea.app/entity/ProductCustomizationOptionEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.Instant;

@Entity
@Table(name = "product_customization_options")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProductCustomizationOptionEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "customization_type_id", nullable = false)
    private ProductCustomizationTypeEntity customizationType;

    @Column(name = "value", nullable = false, length = 50)
    private String value; // no_sugar, no_ice, topping_1

    @Column(name = "label", nullable = false, length = 50)
    private String label; // 无糖, 去冰, 珍珠

    @Column(name = "price_adjustment", nullable = false, precision = 10, scale = 2)
    private BigDecimal priceAdjustment;

    @Column(name = "is_default", nullable = false)
    private Boolean isDefault;

    @Column(name = "stock")
    private Integer stock;

    @Column(name = "icon_url")
    private String iconUrl;

    @Column(name = "sort_order")
    private Integer sortOrder;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
        if (updatedAt == null) {
            updatedAt = Instant.now();
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = Instant.now();
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\ProductCustomizationTypeEntity.java ---
// File: milktea-backend/src/main/java/com.milktea.app/entity/ProductCustomizationTypeEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;
import java.util.List;

@Entity
@Table(name = "product_customization_types")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProductCustomizationTypeEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    private ProductEntity product;

    @Column(name = "type_name", nullable = false, length = 50)
    private String typeName; // sweetness, temperature, toppings

    @Column(name = "label", length = 50)
    private String label; // 甜度, 温度, 加料

    @Column(name = "is_enabled", nullable = false)
    private Boolean isEnabled;

    @Column(name = "is_required", nullable = false)
    private Boolean isRequired;

    @Column(name = "max_quantity")
    private Integer maxQuantity;

    @Column(name = "sort_order")
    private Integer sortOrder;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;

    @OneToMany(mappedBy = "customizationType", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private List<ProductCustomizationOptionEntity> options;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
        if (updatedAt == null) {
            updatedAt = Instant.now();
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = Instant.now();
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\ProductEntity.java ---
// File: milktea-backend/src/main/java/com.milktea.app/entity/ProductEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;

@Entity
@Table(name = "products")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProductEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "category_id")
    private CategoryEntity category;

    @Column(name = "name", nullable = false, length = 100)
    private String name;

    @Column(name = "subtitle")
    private String subtitle;

    @Column(name = "main_image_url")
    private String mainImageUrl;

    @Column(name = "description")
    private String description;

    @Column(name = "detail_html")
    private String detailHtml;

    @Column(name = "price", nullable = false, precision = 10, scale = 2)
    private BigDecimal price;

    @Column(name = "original_price", precision = 10, scale = 2)
    private BigDecimal originalPrice;

    @Column(name = "unit", length = 20)
    private String unit;

    @Column(name = "stock", nullable = false)
    private Integer stock;

    @Column(name = "sales", nullable = false)
    private Integer sales;

    @Column(name = "monthly_sales", nullable = false)
    private Integer monthlySales;

    @Column(name = "rating", nullable = false, precision = 2, scale = 1)
    private BigDecimal rating;

    @Column(name = "rating_count", nullable = false)
    private Integer ratingCount;

    @Column(name = "favorite_count", nullable = false)
    private Integer favoriteCount;

    @Column(name = "is_hot", nullable = false)
    private Boolean isHot;

    @Column(name = "is_new", nullable = false)
    private Boolean isNew;

    @Column(name = "is_recommend", nullable = false)
    private Boolean isRecommend;

    @Column(name = "tags")
    @JdbcTypeCode(SqlTypes.JSON) // Use JdbcTypeCode for JSONB mapping
    private String tags; // JSON array of strings, e.g., ["招牌", "人气"]

    @Column(name = "storage_method", length = 100)
    private String storageMethod;

    @Column(name = "shelf_life", length = 50)
    private String shelfLife;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;

    @Column(name = "is_active", nullable = false)
    private Boolean isActive;

    @OneToMany(mappedBy = "product", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private List<ProductImageEntity> images;

    @OneToMany(mappedBy = "product", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private List<ProductCustomizationTypeEntity> customizationTypes;

    @OneToMany(mappedBy = "product", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private List<ProductNutritionEntity> nutritions;

    @ManyToMany
    @JoinTable(
            name = "product_ingredients_map",
            joinColumns = @JoinColumn(name = "product_id"),
            inverseJoinColumns = @JoinColumn(name = "ingredient_id")
    )
    private List<IngredientEntity> ingredients;

    @ManyToMany
    @JoinTable(
            name = "product_allergens_map",
            joinColumns = @JoinColumn(name = "product_id"),
            inverseJoinColumns = @JoinColumn(name = "allergen_id")
    )
    private List<AllergenEntity> allergens;

    @ManyToMany
    @JoinTable(
            name = "product_related_map",
            joinColumns = @JoinColumn(name = "main_product_id"),
            inverseJoinColumns = @JoinColumn(name = "related_product_id")
    )
    private List<ProductEntity> relatedProducts;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
        if (updatedAt == null) {
            updatedAt = Instant.now();
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = Instant.now();
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\ProductImageEntity.java ---
// File: milktea-backend/src/main/java/com.milktea.app/entity/ProductImageEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;

@Entity
@Table(name = "product_images")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProductImageEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    private ProductEntity product;

    @Column(name = "image_url", nullable = false)
    private String imageUrl;

    @Column(name = "sort_order")
    private Integer sortOrder;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\ProductIngredientsMapEntity.java ---
// File: milktea-backend/src/main/java/com.milktea.app/entity/ProductIngredientsMapEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

@Entity
@Table(name = "product_ingredients_map")
@Data
@NoArgsConstructor
@AllArgsConstructor
@IdClass(ProductIngredientsMapEntity.ProductIngredientsMapId.class)
public class ProductIngredientsMapEntity {

    @Id
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    private ProductEntity product;

    @Id
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "ingredient_id", nullable = false)
    private IngredientEntity ingredient;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ProductIngredientsMapId implements Serializable {
        private Long product;
        private Long ingredient;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\ProductNutritionEntity.java ---
// File: milktea-backend/src/main/java/com.milktea.app/entity/ProductNutritionEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;

@Entity
@Table(name = "product_nutritions")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProductNutritionEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    private ProductEntity product;

    @Column(name = "name", nullable = false, length = 50)
    private String name;

    @Column(name = "value", nullable = false, length = 50)
    private String value;

    @Column(name = "unit", length = 20)
    private String unit;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
        if (updatedAt == null) {
            updatedAt = Instant.now();
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = Instant.now();
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\ProductRelatedMapEntity.java ---
// File: milktea-backend/src/main/java/com.milktea.app/entity/ProductRelatedMapEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

@Entity
@Table(name = "product_related_map")
@Data
@NoArgsConstructor
@AllArgsConstructor
@IdClass(ProductRelatedMapEntity.ProductRelatedMapId.class)
public class ProductRelatedMapEntity {

    @Id
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "main_product_id", nullable = false)
    private ProductEntity mainProduct;

    @Id
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "related_product_id", nullable = false)
    private ProductEntity relatedProduct;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ProductRelatedMapId implements Serializable {
        private Long mainProduct;
        private Long relatedProduct;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\PromotionEntity.java ---
// File: milktea-backend/src/main/java/com.milktea.app/entity/PromotionEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.Instant;

@Entity
@Table(name = "promotions")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class PromotionEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "title", nullable = false, length = 100)
    private String title;

    @Column(name = "subtitle")
    private String subtitle;

    @Column(name = "image_url")
    private String imageUrl;

    @Column(name = "type", nullable = false, length = 20)
    private String type; // discount, coupon, points

    @Column(name = "value", precision = 10, scale = 2)
    private BigDecimal value;

    @Column(name = "start_time", nullable = false)
    private Instant startTime;

    @Column(name = "end_time", nullable = false)
    private Instant endTime;

    @Column(name = "button_text", length = 50)
    private String buttonText;

    @Column(name = "is_active", nullable = false)
    private Boolean isActive;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
        if (updatedAt == null) {
            updatedAt = Instant.now();
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = Instant.now();
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\QuickEntryEntity.java ---
// File: milktea-backend/src/main/java/com.milktea.app/entity/QuickEntryEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;

@Entity
@Table(name = "quick_entries")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class QuickEntryEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "icon_url", nullable = false)
    private String iconUrl;

    @Column(name = "name", nullable = false, length = 50)
    private String name;

    @Column(name = "type", nullable = false, length = 20)
    private String type; // category, url

    @Column(name = "target_id")
    private Long targetId; // category_id

    @Column(name = "url")
    private String url;

    @Column(name = "badge", length = 20)
    private String badge; // hot, new, null

    @Column(name = "sort_order")
    private Integer sortOrder;

    @Column(name = "is_active", nullable = false)
    private Boolean isActive;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
        if (updatedAt == null) {
            updatedAt = Instant.now();
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = Instant.now();
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\ReviewTagEntity.java ---
// File: milktea-backend/src/main/java/com.milktea.app/entity/ReviewTagEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "review_tags")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ReviewTagEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "name", nullable = false, unique = true, length = 50)
    private String name;
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\SearchKeywordEntity.java ---
// File: milktea-backend/src/main/java/com.milktea.app/entity/SearchKeywordEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;

@Entity
@Table(name = "search_keywords")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class SearchKeywordEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "keyword", nullable = false, unique = true, length = 100)
    private String keyword;

    @Column(name = "count", nullable = false)
    private Integer count;

    @Column(name = "type", length = 20)
    private String type; // hot, new

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
        if (updatedAt == null) {
            updatedAt = Instant.now();
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = Instant.now();
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\StoreEntity.java ---
// File: milktea-backend/src/main/java/com.milktea.app/entity/StoreEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;

@Entity
@Table(name = "stores")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class StoreEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "name", nullable = false, length = 100)
    private String name;

    @Column(name = "address", nullable = false)
    private String address;

    @Column(name = "phone", length = 20)
    private String phone;

    @Column(name = "business_hours", length = 100)
    private String businessHours;

    @Column(name = "status", nullable = false, length = 20)
    private String status; // open, closed, busy

    @Column(name = "longitude", nullable = false, precision = 10, scale = 7)
    private BigDecimal longitude;

    @Column(name = "latitude", nullable = false, precision = 10, scale = 7)
    private BigDecimal latitude;

    @Column(name = "delivery_fee", nullable = false, precision = 10, scale = 2)
    private BigDecimal deliveryFee;

    @Column(name = "minimum_order_amount", nullable = false, precision = 10, scale = 2)
    private BigDecimal minimumOrderAmount;

    @Column(name = "rating", nullable = false, precision = 2, scale = 1)
    private BigDecimal rating;

    @Column(name = "current_wait_time", nullable = false)
    private Integer currentWaitTime;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;

    @Column(name = "is_active", nullable = false)
    private Boolean isActive;

    @OneToMany(mappedBy = "store", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private List<StoreImageEntity> images;

    @ManyToMany
    @JoinTable(
            name = "store_services",
            joinColumns = @JoinColumn(name = "store_id"),
            inverseJoinColumns = @JoinColumn(name = "service_type")
    )
    private List<StoreServiceEntity> services; // Note: This is an example, typically you'd map to an enum/string and not another entity for such simple cross-table.

    @ManyToMany
    @JoinTable(
            name = "store_tags",
            joinColumns = @JoinColumn(name = "store_id"),
            inverseJoinColumns = @JoinColumn(name = "tag_name")
    )
    private List<StoreTagEntity> tags; // Similar to services, direct mapping might be simpler if tags are just strings.

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
        if (updatedAt == null) {
            updatedAt = Instant.now();
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = Instant.now();
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\StoreImageEntity.java ---
// File: milktea-backend/src/main/java/com.milktea.app/entity/StoreImageEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;

@Entity
@Table(name = "store_images")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class StoreImageEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "store_id", nullable = false)
    private StoreEntity store;

    @Column(name = "image_url", nullable = false)
    private String imageUrl;

    @Column(name = "sort_order")
    private Integer sortOrder;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\StoreServiceEntity.java ---
// File: milktea-backend/src/main/java/com.milktea.app/entity/StoreServiceEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

@Entity
@Table(name = "store_services")
@Data
@NoArgsConstructor
@AllArgsConstructor
@IdClass(StoreServiceEntity.StoreServiceId.class)
public class StoreServiceEntity {

    @Id
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "store_id", nullable = false)
    private StoreEntity store;

    @Id
    @Column(name = "service_type", nullable = false, length = 20)
    private String serviceType; // delivery, pickup

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class StoreServiceId implements Serializable {
        private Long store;
        private String serviceType;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\StoreTagEntity.java ---
// File: milktea-backend/src/main/java/com.milktea.app/entity/StoreTagEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

@Entity
@Table(name = "store_tags")
@Data
@NoArgsConstructor
@AllArgsConstructor
@IdClass(StoreTagEntity.StoreTagId.class)
public class StoreTagEntity {

    @Id
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "store_id", nullable = false)
    private StoreEntity store;

    @Id
    @Column(name = "tag_name", nullable = false, length = 50)
    private String tagName; // 人气门店, 支持自取

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class StoreTagId implements Serializable {
        private Long store;
        private String tagName;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\SystemConfigEntity.java ---
// File: milktea-backend/src/main/java/com.milktea.app/entity/SystemConfigEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;

@Entity
@Table(name = "system_configs")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class SystemConfigEntity {
    @Id
    @Column(name = "key", nullable = false, length = 100)
    private String key;

    @Column(name = "value")
    private String value; // Can store JSON string

    @Column(name = "description")
    private String description;

    @Column(name = "value_type", nullable = false, length = 20)
    private String valueType; // string, boolean, json, number

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
        if (updatedAt == null) {
            updatedAt = Instant.now();
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = Instant.now();
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\UserAddressEntity.java ---
// File: milktea-backend/src/main/java/com.milktea.app/entity/UserAddressEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.Instant;

@Entity
@Table(name = "user_addresses")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserAddressEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private UserEntity user;

    @Column(name = "name", nullable = false, length = 100)
    private String name;

    @Column(name = "phone", nullable = false, length = 20)
    private String phone;

    @Column(name = "province", nullable = false, length = 50)
    private String province;

    @Column(name = "city", nullable = false, length = 50)
    private String city;

    @Column(name = "district", length = 50)
    private String district;

    @Column(name = "detail", nullable = false)
    private String detail;

    @Column(name = "postal_code", length = 10)
    private String postalCode;

    @Column(name = "is_default", nullable = false)
    private Boolean isDefault;

    @Column(name = "type", nullable = false, length = 20)
    private String type; // home, company, school, other

    @Column(name = "label", length = 50)
    private String label;

    @Column(name = "longitude", precision = 10, scale = 7)
    private BigDecimal longitude;

    @Column(name = "latitude", precision = 10, scale = 7)
    private BigDecimal latitude;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
        if (updatedAt == null) {
            updatedAt = Instant.now();
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = Instant.now();
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\UserCouponEntity.java ---
// File: milktea-backend/src/main/java/com.milktea.app/entity/UserCouponEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;

@Entity
@Table(name = "user_coupons")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserCouponEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private UserEntity user;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "coupon_template_id", nullable = false)
    private CouponTemplateEntity couponTemplate;

    @Column(name = "status", nullable = false, length = 20)
    private String status; // available, used, expired

    @Column(name = "received_at", nullable = false)
    private Instant receivedAt;

    @Column(name = "used_at")
    private Instant usedAt;

    @Column(name = "order_id")
    private Long orderId; // Note: DDL mentions avoiding FK here due to potential circular dependency

    @Column(name = "expire_at", nullable = false)
    private Instant expireAt;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
        if (updatedAt == null) {
            updatedAt = Instant.now();
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = Instant.now();
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\UserEntity.java ---
// File: milktea-backend/src/main/java/com.milktea.app/entity/UserEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import com.fasterxml.jackson.annotation.JsonIgnore;

import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;

@Entity
@Table(name = "users")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "wechat_openid", unique = true, length = 64)
    private String wechatOpenid;

    @Column(name = "username", unique = true, length = 50)
    private String username;

    @JsonIgnore // Don't expose password hash in API responses
    @Column(name = "password_hash")
    private String passwordHash;

    @Column(name = "phone", unique = true, length = 20)
    private String phone;

    @Column(name = "email", unique = true, length = 100)
    private String email;

    @Column(name = "nickname", nullable = false, length = 50)
    private String nickname;

    @Column(name = "avatar_url")
    private String avatarUrl;

    @Column(name = "gender")
    private Short gender; // 0:unknown, 1:male, 2:female

    @Column(name = "country", length = 50)
    private String country;

    @Column(name = "province", length = 50)
    private String province;

    @Column(name = "city", length = 50)
    private String city;

    @Column(name = "birthday")
    private LocalDate birthday;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "member_level_id")
    private MemberLevelEntity memberLevel;

    @Column(name = "growth_value", nullable = false)
    private Integer growthValue;

    @Column(name = "points", nullable = false)
    private Integer points;

    @Column(name = "balance", nullable = false, precision = 10, scale = 2)
    private BigDecimal balance;

    @Column(name = "member_card_no", unique = true, length = 50)
    private String memberCardNo;

    @Column(name = "member_card_status", length = 20)
    private String memberCardStatus; // active, expired, inactive

    @Column(name = "member_card_expire_date")
    private LocalDate memberCardExpireDate;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;

    @Column(name = "last_login_at")
    private Instant lastLoginAt;

    @Column(name = "is_active", nullable = false)
    private Boolean isActive;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
        if (updatedAt == null) {
            updatedAt = Instant.now();
        }
        if (gender == null) {
            gender = 0; // Default to unknown
        }
        if (growthValue == null) {
            growthValue = 0;
        }
        if (points == null) {
            points = 0;
        }
        if (balance == null) {
            balance = BigDecimal.ZERO;
        }
        if (memberCardStatus == null) {
            memberCardStatus = "inactive";
        }
        if (isActive == null) {
            isActive = true;
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = Instant.now();
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\UserFavoriteProductEntity.java ---
// File: milktea-backend/src/main/java/com.milktea.app/entity/UserFavoriteProductEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;

@Entity
@Table(name = "user_favorite_products", uniqueConstraints = {
        @UniqueConstraint(columnNames = {"user_id", "product_id"})
})
@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserFavoriteProductEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private UserEntity user;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    private ProductEntity product;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\UserFavoriteStoreEntity.java ---
// File: milktea-backend/src/main/java/com.milktea.app/entity/UserFavoriteStoreEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;
import java.time.Instant;

@Entity
@Table(name = "user_favorite_stores")
@Data
@NoArgsConstructor
@AllArgsConstructor
@IdClass(UserFavoriteStoreEntity.UserFavoriteStoreId.class)
public class UserFavoriteStoreEntity {

    @Id
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private UserEntity user;

    @Id
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "store_id", nullable = false)
    private StoreEntity store;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class UserFavoriteStoreId implements Serializable {
        private Long user;
        private Long store;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\UserSearchHistoryEntity.java ---
// File: milktea-backend/src/main/java/com.milktea.app/entity/UserSearchHistoryEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;

@Entity
@Table(name = "user_search_histories")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserSearchHistoryEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private UserEntity user;

    @Column(name = "keyword", nullable = false, length = 100)
    private String keyword;

    @Column(name = "type", length = 20)
    private String type; // product, category

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\UserShareEntity.java ---
// File: milktea-backend/src/main/java/com.milktea.app/entity/UserShareEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;

@Entity
@Table(name = "user_shares")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserShareEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private UserEntity user;

    @Column(name = "type", nullable = false, length = 20)
    private String type; // product, activity, invite

    @Column(name = "target_id", nullable = false, length = 50)
    private String targetId;

    @Column(name = "channel", nullable = false, length = 20)
    private String channel; // wechat, moments, qq

    @Column(name = "invite_code", length = 50)
    private String inviteCode;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\entity\VerificationCodeEntity.java ---
// File: milktea-backend/src/main/java/com.milktea.app/entity/VerificationCodeEntity.java
package com.milktea.app.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;

@Entity
@Table(name = "verification_codes")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class VerificationCodeEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "phone", nullable = false, length = 20)
    private String phone;

    @Column(name = "code", nullable = false, length = 10)
    private String code;

    @Column(name = "type", nullable = false, length = 20)
    private String type; // login, register, update_phone, reset_password

    @Column(name = "sent_at", nullable = false)
    private Instant sentAt;

    @Column(name = "expires_at", nullable = false)
    private Instant expiresAt;

    @Column(name = "is_used", nullable = false)
    private Boolean isUsed;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\jwt\JwtAuthFilter.java ---
// File: milktea-backend/src/main/java/com/milktea/app/jwt/JwtAuthFilter.java
package com.milktea.app.jwt;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.ArrayList;

@Component
@RequiredArgsConstructor
@Slf4j
public class JwtAuthFilter extends OncePerRequestFilter {

    private final JwtService jwtService;

    @Override
    protected void doFilterInternal(
            HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain
    ) throws ServletException, IOException {
        final String authHeader = request.getHeader("Authorization");
        final String jwt;
        final Long userId;

        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            filterChain.doFilter(request, response);
            return;
        }

        jwt = authHeader.substring(7);
        try {
            // Extract userId from JWT
            userId = jwtService.getUserIdFromToken(jwt);
            if (userId != null && SecurityContextHolder.getContext().getAuthentication() == null) {
                // For simplicity, we create a basic UserDetails. In a real app, load from UserDetailsService.
                // The username here is actually the userId.
                UserDetails userDetails = new User(String.valueOf(userId), "", new ArrayList<>());

                if (jwtService.validateToken(jwt)) {
                    UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
                            userDetails,
                            null,
                            userDetails.getAuthorities()
                    );
                    authToken.setDetails(
                            new WebAuthenticationDetailsSource().buildDetails(request)
                    );
                    SecurityContextHolder.getContext().setAuthentication(authToken);
                }
            }
        } catch (Exception e) {
            log.error("Error processing JWT token: {}", e.getMessage());
            // Clear security context if token processing fails
            SecurityContextHolder.clearContext();
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            response.getWriter().write("Invalid or expired token");
            return;
        }

        filterChain.doFilter(request, response);
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\jwt\JwtProperties.java ---
// File: milktea-backend/src/main/java/com/milktea/app/jwt/JwtProperties.java
package com.milktea.app.jwt;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Data
@Component
@ConfigurationProperties(prefix = "jwt")
public class JwtProperties {
    private String secret;
    private Long expiration; // in milliseconds
    private Long refreshExpiration; // in milliseconds
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\jwt\JwtService.java ---
package com.milktea.app.jwt;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.security.Key;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;

@Service
@RequiredArgsConstructor
@Slf4j
public class JwtService {

    private final JwtProperties jwtProperties;

    // A simple in-memory blacklist for demonstration. In production, use Redis or a similar store.
    private final Map<String, Date> tokenBlacklist = new ConcurrentHashMap<>();

    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    public Long getUserIdFromToken(String token) {
        try {
            // JJWT 0.12.3+ uses subject as String, need to parse it to Long
            return Long.parseLong(extractClaim(token, Claims::getSubject));
        } catch (NumberFormatException e) {
            log.warn("Invalid user ID in JWT subject: {}", extractClaim(token, Claims::getSubject));
            return null;
        }
    }

    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    public String generateToken(Long userId) {
        Map<String, Object> claims = new HashMap<>();
        // You can add more claims here if needed, e.g., roles
        return buildToken(claims, String.valueOf(userId), jwtProperties.getExpiration());
    }

    public String generateRefreshToken(Long userId) {
        Map<String, Object> claims = new HashMap<>();
        return buildToken(claims, String.valueOf(userId), jwtProperties.getRefreshExpiration());
    }

    private String buildToken(
            Map<String, Object> extraClaims,
            String subject,
            Long expiration
    ) {
        // Use Jwts.builder() and modern API
        return Jwts
                .builder()
                .setClaims(extraClaims)
                .setSubject(subject)
                .setIssuedAt(new Date(System.currentTimeMillis()))
                .setExpiration(new Date(System.currentTimeMillis() + expiration))
                // JJWT 0.12.3+ uses signWith(key) directly or with header
                // SignatureAlgorithm.HS256 is deprecated, but often still works with the key
                .signWith(getSigningKey(), SignatureAlgorithm.HS256) // Keep for now, but consider updating if issues arise
                .compact();
    }

    public boolean validateToken(String token) {
        try {
            if (isTokenBlacklisted(token)) {
                return false;
            }
            // Use Jwts.parser() and build() for JJWT 0.12.3+
            Jwts.parser()
                    .setSigningKey(getSigningKey())
                    .build()
                    .parseClaimsJws(token); // parseClaimsJws() is correct
            return true;
        } catch (Exception e) {
            log.warn("JWT validation failed: {}", e.getMessage());
            return false;
        }
    }

    private Claims extractAllClaims(String token) {
        // Use Jwts.parser() and build() for JJWT 0.12.3+
        return Jwts
                .parser()
                .setSigningKey(getSigningKey())
                .build()
                .parseClaimsJws(token)
                .getBody();
    }

    private Key getSigningKey() {
        // Use Decoders.BASE64 for decoding
        byte[] keyBytes = Decoders.BASE64.decode(jwtProperties.getSecret());
        return Keys.hmacShaKeyFor(keyBytes);
    }

    public void addToBlacklist(String token) {
        try {
            // Use extractClaim to safely get expiration
            Date expiration = extractClaim(token, Claims::getExpiration);
            tokenBlacklist.put(token, expiration);
            log.info("Token added to blacklist: {}", token);
        } catch (Exception e) {
            log.error("Failed to add token to blacklist: {}", e.getMessage());
        }
    }

    public boolean isTokenBlacklisted(String token) {
        // Remove expired tokens from blacklist to prevent memory leak
        tokenBlacklist.entrySet().removeIf(entry -> entry.getValue().before(new Date()));
        return tokenBlacklist.containsKey(token);
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\AllergenRepository.java ---
// File: milktea-backend/src/main/java/com/milktea.app/repository/AllergenRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.AllergenEntity;
import org.springframework.data.jpa.repository.JpaRepository;

public interface AllergenRepository extends JpaRepository<AllergenEntity, Long> {
    // Custom query methods can be added here
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\BannerRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/BannerRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.BannerEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface BannerRepository extends JpaRepository<BannerEntity, Long> {
    List<BannerEntity> findByIsActiveTrueOrderBySortOrderAsc();
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\CartItemCustomizationRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/CartItemCustomizationRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.CartItemCustomizationEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface CartItemCustomizationRepository extends JpaRepository<CartItemCustomizationEntity, Long> {
    List<CartItemCustomizationEntity> findByCartItemId(Long cartItemId);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\CartItemRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/CartItemRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.CartItemEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface CartItemRepository extends JpaRepository<CartItemEntity, Long> {
    List<CartItemEntity> findByUserId(Long userId);
    List<CartItemEntity> findByUserIdAndIsSelectedTrue(Long userId);
    Optional<CartItemEntity> findByUserIdAndProductId(Long userId, Long productId);
    void deleteByUserId(Long userId);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\CategoryRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/CategoryRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.CategoryEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface CategoryRepository extends JpaRepository<CategoryEntity, Long> {
    List<CategoryEntity> findByParentIsNullAndIsActiveTrueOrderBySortOrderAsc();
    List<CategoryEntity> findByParentIdAndIsActiveTrueOrderBySortOrderAsc(Long parentId);
    List<CategoryEntity> findByIsActiveTrueOrderBySortOrderAsc();
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\CouponTemplateRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/CouponTemplateRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.CouponTemplateEntity;
import org.springframework.data.jpa.repository.JpaRepository;

public interface CouponTemplateRepository extends JpaRepository<CouponTemplateEntity, Long> {
    // Add custom queries if needed
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\FileRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/FileRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.FileEntity;
import org.springframework.data.jpa.repository.JpaRepository;

public interface FileRepository extends JpaRepository<FileEntity, Long> {
    // Custom query methods can be added here
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\IngredientRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/IngredientRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.IngredientEntity;
import org.springframework.data.jpa.repository.JpaRepository;

public interface IngredientRepository extends JpaRepository<IngredientEntity, Long> {
    // Custom query methods can be added here
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\MemberLevelRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/MemberLevelRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.MemberLevelEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface MemberLevelRepository extends JpaRepository<MemberLevelEntity, Long> {
    Optional<MemberLevelEntity> findFirstByMinGrowthValueLessThanEqualOrderByMinGrowthValueDesc(Integer growthValue);
    Optional<MemberLevelEntity> findFirstByMinGrowthValueGreaterThanOrderByMinGrowthValueAsc(Integer growthValue);
    Optional<MemberLevelEntity> findByName(String name);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\NotificationRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/NotificationRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.NotificationEntity;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;

public interface NotificationRepository extends JpaRepository<NotificationEntity, Long> {
    Page<NotificationEntity> findByUserIdOrderByCreatedAtDesc(Long userId, Pageable pageable);
    long countByUserIdAndIsReadFalse(Long userId);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\OrderItemCustomizationRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/OrderItemCustomizationRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.OrderItemCustomizationEntity;
import org.springframework.data.jpa.repository.JpaRepository;

public interface OrderItemCustomizationRepository extends JpaRepository<OrderItemCustomizationEntity, Long> {
    // Add custom queries if needed
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\OrderItemRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/OrderItemRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.OrderItemEntity;
import org.springframework.data.jpa.repository.JpaRepository;

public interface OrderItemRepository extends JpaRepository<OrderItemEntity, Long> {
    // Add custom queries if needed
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\OrderRefundImageRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/OrderRefundImageRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.OrderRefundImageEntity;
import org.springframework.data.jpa.repository.JpaRepository;

public interface OrderRefundImageRepository extends JpaRepository<OrderRefundImageEntity, Long> {
    // Add custom queries if needed
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\OrderRefundRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/OrderRefundRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.OrderRefundEntity;
import org.springframework.data.jpa.repository.JpaRepository;

public interface OrderRefundRepository extends JpaRepository<OrderRefundEntity, Long> {
    // Add custom queries if needed
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\OrderRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/OrderRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.OrderEntity;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface OrderRepository extends JpaRepository<OrderEntity, Long> {
    Optional<OrderEntity> findByOrderNo(String orderNo);
    Page<OrderEntity> findByUserIdOrderByCreatedAtDesc(Long userId, Pageable pageable);
    List<OrderEntity> findByUserIdAndStatusInOrderByCreatedAtDesc(Long userId, List<String> statuses);
    long countByUserIdAndStatus(Long userId, String status);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\OrderReviewImageRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/OrderReviewImageRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.OrderReviewImageEntity;
import org.springframework.data.jpa.repository.JpaRepository;

public interface OrderReviewImageRepository extends JpaRepository<OrderReviewImageEntity, Long> {
    // Add custom queries if needed
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\OrderReviewRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/OrderReviewRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.OrderReviewEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface OrderReviewRepository extends JpaRepository<OrderReviewEntity, Long> {
    Optional<OrderReviewEntity> findByOrderId(Long orderId);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\OrderStatusTimelineRepository.java ---
package com.milktea.app.repository;

import com.milktea.app.entity.OrderStatusTimelineEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional; // 必须导入

public interface OrderStatusTimelineRepository extends JpaRepository<OrderStatusTimelineEntity, Long> {
    List<OrderStatusTimelineEntity> findByOrderIdOrderByTimeAsc(Long orderId);
    Optional<OrderStatusTimelineEntity> findByOrderIdAndIsCurrentTrue(Long orderId);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\PageConfigRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/PageConfigRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.PageConfigEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface PageConfigRepository extends JpaRepository<PageConfigEntity, Long> {
    List<PageConfigEntity> findByPageName(String pageName);
    Optional<PageConfigEntity> findByPageNameAndKey(String pageName, String key);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\PaymentRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/PaymentRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.PaymentEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface PaymentRepository extends JpaRepository<PaymentEntity, Long> {
    Optional<PaymentEntity> findByOrderId(Long orderId);
    Optional<PaymentEntity> findByTransactionId(String transactionId);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\PointExchangeItemRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/PointExchangeItemRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.PointExchangeItemEntity;
import org.springframework.data.jpa.repository.JpaRepository;

public interface PointExchangeItemRepository extends JpaRepository<PointExchangeItemEntity, Long> {
    // Add custom queries if needed
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\PointTransactionRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/PointTransactionRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.PointTransactionEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface PointTransactionRepository extends JpaRepository<PointTransactionEntity, Long> {
    List<PointTransactionEntity> findByUserIdOrderByCreatedAtDesc(Long userId);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\ProductCustomizationOptionRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/ProductCustomizationOptionRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.ProductCustomizationOptionEntity;
import org.springframework.data.jpa.repository.JpaRepository;

public interface ProductCustomizationOptionRepository extends JpaRepository<ProductCustomizationOptionEntity, Long> {
    // Add custom queries if needed
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\ProductCustomizationTypeRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/ProductCustomizationTypeRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.ProductCustomizationTypeEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface ProductCustomizationTypeRepository extends JpaRepository<ProductCustomizationTypeEntity, Long> {
    List<ProductCustomizationTypeEntity> findByProductIdAndIsEnabledTrueOrderBySortOrderAsc(Long productId);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\ProductImageRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/ProductImageRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.ProductImageEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface ProductImageRepository extends JpaRepository<ProductImageEntity, Long> {
    List<ProductImageEntity> findByProductIdOrderBySortOrderAsc(Long productId);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\ProductNutritionRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/ProductNutritionRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.ProductNutritionEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface ProductNutritionRepository extends JpaRepository<ProductNutritionEntity, Long> {
    List<ProductNutritionEntity> findByProductId(Long productId);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\ProductRelatedMapRepository.java ---
package com.milktea.app.repository; 
// Placeholder for ProductRelatedMapRepository interface 


--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\ProductRepository.java ---
package com.milktea.app.repository; 
// Placeholder for ProductRepository interface 
// File: milktea-backend/src/main/java/com.milktea.app/repository/ProductRepository.java

import com.milktea.app.entity.ProductEntity;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.math.BigDecimal;
import java.util.List;

public interface ProductRepository extends JpaRepository<ProductEntity, Long> {
    List<ProductEntity> findByCategoryIdAndIsActiveTrue(Long categoryId);
    Page<ProductEntity> findByIsActiveTrue(Pageable pageable);
    List<ProductEntity> findByIsRecommendTrueAndIsActiveTrue();
    List<ProductEntity> findByIsHotTrueAndIsActiveTrueOrderByMonthlySalesDesc();

    @Query("SELECT p FROM ProductEntity p WHERE (:categoryId IS NULL OR p.category.id = :categoryId) " +
            "AND p.isActive = true " +
            "AND (:keyword IS NULL OR LOWER(p.name) LIKE LOWER(CONCAT('%', :keyword, '%')) OR LOWER(p.description) LIKE LOWER(CONCAT('%', :keyword, '%'))) " +
            "AND (:minPrice IS NULL OR p.price >= :minPrice) " +
            "AND (:maxPrice IS NULL OR p.price <= :maxPrice)")
    Page<ProductEntity> searchProducts(
            @Param("keyword") String keyword,
            @Param("categoryId") Long categoryId,
            @Param("minPrice") BigDecimal minPrice,
            @Param("maxPrice") BigDecimal maxPrice,
            Pageable pageable
    );
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\PromotionRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/PromotionRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.PromotionEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.time.Instant;
import java.util.List;

public interface PromotionRepository extends JpaRepository<PromotionEntity, Long> {
    List<PromotionEntity> findByIsActiveTrueAndEndTimeAfterOrderByStartTimeAsc(Instant now);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\QuickEntryRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/QuickEntryRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.QuickEntryEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface QuickEntryRepository extends JpaRepository<QuickEntryEntity, Long> {
    List<QuickEntryEntity> findByIsActiveTrueOrderBySortOrderAsc();
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\ReviewTagRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/ReviewTagRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.ReviewTagEntity;
import org.springframework.data.jpa.repository.JpaRepository;

public interface ReviewTagRepository extends JpaRepository<ReviewTagEntity, Long> {
    // Custom query methods can be added here
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\SearchKeywordRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/SearchKeywordRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.SearchKeywordEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface SearchKeywordRepository extends JpaRepository<SearchKeywordEntity, Long> {
    Optional<SearchKeywordEntity> findByKeyword(String keyword);
    List<SearchKeywordEntity> findByTypeOrderByCountDesc(String type);
    List<SearchKeywordEntity> findTop5ByKeywordStartingWithOrderByCountDesc(String prefix);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\StoreImageRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/StoreImageRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.StoreImageEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface StoreImageRepository extends JpaRepository<StoreImageEntity, Long> {
    List<StoreImageEntity> findByStoreIdOrderBySortOrderAsc(Long storeId);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\StoreRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/StoreRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.StoreEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.math.BigDecimal;
import java.util.List;

public interface StoreRepository extends JpaRepository<StoreEntity, Long> {
    List<StoreEntity> findByIsActiveTrue();

    // Placeholder for distance-based search. Actual implementation would need PostGIS or similar.
    // This query just returns active stores for demonstration.
    @Query(value = "SELECT s.*, " +
            "ACOS(SIN(RADIANS(:latitude)) * SIN(RADIANS(s.latitude)) + COS(RADIANS(:latitude)) * COS(RADIANS(s.latitude)) * COS(RADIANS(s.longitude) - RADIANS(:longitude))) * 6371000 AS distance_meters " +
            "FROM stores s " +
            "WHERE s.is_active = TRUE " +
            "HAVING ACOS(SIN(RADIANS(:latitude)) * SIN(RADIANS(s.latitude)) + COS(RADIANS(:latitude)) * COS(RADIANS(s.latitude)) * COS(RADIANS(s.longitude) - RADIANS(:longitude))) * 6371000 <= :radius " +
            "ORDER BY distance_meters ASC " +
            "LIMIT :limit",
            nativeQuery = true)
    List<StoreEntity> findNearbyStoresNative(
            @Param("latitude") BigDecimal latitude,
            @Param("longitude") BigDecimal longitude,
            @Param("radius") Double radius, // in meters
            @Param("limit") Integer limit
    );
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\StoreServiceRepository.java ---
package com.milktea.app.repository; 
// Placeholder for StoreServiceRepository interface 


--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\StoreTagRepository.java ---
package com.milktea.app.repository; 
// Placeholder for StoreTagRepository interface 


--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\SystemConfigRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/SystemConfigRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.SystemConfigEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface SystemConfigRepository extends JpaRepository<SystemConfigEntity, String> {
    Optional<SystemConfigEntity> findByKey(String key);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\UserAddressRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/UserAddressRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.UserAddressEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface UserAddressRepository extends JpaRepository<UserAddressEntity, Long> {
    List<UserAddressEntity> findByUserIdOrderByIsDefaultDescCreatedAtDesc(Long userId);
    Optional<UserAddressEntity> findByUserIdAndIsDefaultTrue(Long userId);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\UserCouponRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/UserCouponRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.UserCouponEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.time.Instant;
import java.util.List;
import java.util.Optional;

public interface UserCouponRepository extends JpaRepository<UserCouponEntity, Long> {
    List<UserCouponEntity> findByUserIdAndStatusOrderByExpireAtAsc(Long userId, String status);
    Optional<UserCouponEntity> findByUserIdAndCouponTemplateIdAndStatus(Long userId, Long couponTemplateId, String status);
    long countByUserIdAndStatus(Long userId, String status);
    List<UserCouponEntity> findByUserIdAndExpireAtBeforeAndStatus(Long userId, Instant now, String status);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\UserFavoriteProductRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/UserFavoriteProductRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.UserFavoriteProductEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface UserFavoriteProductRepository extends JpaRepository<UserFavoriteProductEntity, Long> {
    List<UserFavoriteProductEntity> findByUserId(Long userId);
    Optional<UserFavoriteProductEntity> findByUserIdAndProductId(Long userId, Long productId);
    void deleteByUserIdAndProductId(Long userId, Long productId);
    boolean existsByUserIdAndProductId(Long userId, Long productId);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\UserFavoriteStoreRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/UserFavoriteStoreRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.UserFavoriteStoreEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface UserFavoriteStoreRepository extends JpaRepository<UserFavoriteStoreEntity, UserFavoriteStoreEntity.UserFavoriteStoreId> {
    List<UserFavoriteStoreEntity> findByUserId(Long userId);
    Optional<UserFavoriteStoreEntity> findByUserIdAndStoreId(Long userId, Long storeId);
    boolean existsByUserIdAndStoreId(Long userId, Long storeId);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\UserRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/UserRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.UserEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface UserRepository extends JpaRepository<UserEntity, Long> {
    Optional<UserEntity> findByWechatOpenid(String wechatOpenid);
    Optional<UserEntity> findByUsername(String username);
    Optional<UserEntity> findByPhone(String phone);
    Optional<UserEntity> findByEmail(String email);
    Optional<UserEntity> findByUsernameOrPhoneOrEmail(String username, String phone, String email);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\UserSearchHistoryRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/UserSearchHistoryRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.UserSearchHistoryEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface UserSearchHistoryRepository extends JpaRepository<UserSearchHistoryEntity, Long> {
    List<UserSearchHistoryEntity> findByUserIdOrderByCreatedAtDesc(Long userId);
    void deleteByUserId(Long userId);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\UserShareRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/UserShareRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.UserShareEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface UserShareRepository extends JpaRepository<UserShareEntity, Long> {
    List<UserShareEntity> findByUserIdAndType(Long userId, String type);
    long countByUserIdAndType(Long userId, String type);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\repository\VerificationCodeRepository.java ---
// File: milktea-backend/src/main/java/com.milktea.app/repository/VerificationCodeRepository.java
package com.milktea.app.repository;

import com.milktea.app.entity.VerificationCodeEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.time.Instant;
import java.util.Optional;

public interface VerificationCodeRepository extends JpaRepository<VerificationCodeEntity, Long> {
    Optional<VerificationCodeEntity> findTopByPhoneAndTypeAndExpiresAtAfterAndIsUsedFalseOrderBySentAtDesc(
            String phone, String type, Instant now);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\service\AuthService.java ---
// File: milktea-backend/src/main/java/com.milktea.app/service/AuthService.java
package com.milktea.app.service;

import com.milktea.app.dto.auth.AccountLoginReqDTO;
import com.milktea.app.dto.auth.UserAuthResDTO;
import com.milktea.app.dto.auth.WechatLoginReqDTO;

public interface AuthService {
    UserAuthResDTO wechatLogin(WechatLoginReqDTO reqDTO); // 这是微信实现的
    UserAuthResDTO accountLogin(AccountLoginReqDTO reqDTO);
    // Add methods for registration, password reset, logout etc.
    void logout(String token);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\service\CartService.java ---
// File: milktea-backend/src/main/java/com.milktea.app/service/CartService.java
package com.milktea.app.service;

import com.milktea.app.dto.cart.CartBatchOperationReqDTO;
import com.milktea.app.dto.cart.CartItemAddReqDTO;
import com.milktea.app.dto.cart.CartItemUpdateReqDTO;
import com.milktea.app.dto.cart.CartResDTO;

public interface CartService {
    CartResDTO getCart(Long userId);
    CartResDTO addCartItem(Long userId, CartItemAddReqDTO reqDTO);
    CartResDTO updateCartItem(Long userId, Long cartItemId, CartItemUpdateReqDTO reqDTO);
    CartResDTO deleteCartItem(Long userId, Long cartItemId);
    CartResDTO batchOperateCartItems(Long userId, CartBatchOperationReqDTO reqDTO);
    void clearCart(Long userId);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\service\CategoryService.java ---
// File: milktea-backend/src/main/java/com.milktea.app/service/CategoryService.java
package com.milktea.app.service;

import com.milktea.app.dto.category.CategoryTreeResDTO;

import java.util.List;

public interface CategoryService {
    List<CategoryTreeResDTO> getCategoryTree();
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\service\CouponService.java ---
// File: milktea-backend/src/main/java/com.milktea.app/service/CouponService.java
package com.milktea.app.service;

import com.milktea.app.dto.coupon.CouponBatchReceiveReqDTO;
import com.milktea.app.dto.coupon.CouponListResDTO;
import com.milktea.app.dto.coupon.CouponReceiveResDTO;
import org.springframework.data.domain.Pageable;

public interface CouponService {
    CouponListResDTO getUserCoupons(Long userId, String status, Pageable pageable);
    CouponReceiveResDTO receiveCoupon(Long userId, Long templateId);
    CouponReceiveResDTO batchReceiveCoupons(Long userId, CouponBatchReceiveReqDTO reqDTO);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\service\FileService.java ---
// File: milktea-backend/src/main/java/com.milktea.app/service/FileService.java
package com.milktea.app.service;

import com.milktea.app.dto.file.FileUploadResDTO;
import org.springframework.web.multipart.MultipartFile;

public interface FileService {
    FileUploadResDTO uploadFile(Long userId, MultipartFile file, String category);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\service\HomeService.java ---
// File: milktea-backend/src/main/java/com.milktea.app/service/HomeService.java
package com.milktea.app.service;

import com.milktea.app.dto.home.HomePageResDTO;
import com.milktea.app.dto.product.ProductListResDTO; // For getRecommendedProducts
import org.springframework.data.domain.Pageable; // For getRecommendedProducts

import java.math.BigDecimal;

public interface HomeService {
    HomePageResDTO getHomePageData(BigDecimal latitude, BigDecimal longitude);
    // New: 2.1.2 获取个性化推荐
    ProductListResDTO getRecommendedProducts(Integer limit, String type);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\service\MemberService.java ---
// File: milktea-backend/src/main/java/com.milktea.app/service/MemberService.java
package com.milktea.app.service;

import com.milktea.app.dto.member.MemberInfoResDTO;

public interface MemberService {
    MemberInfoResDTO getMemberInfo(Long userId);
    // New: 5.3.2 领取生日特权
    void receiveBirthdayGift(Long userId);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\service\NotificationService.java ---
// File: milktea-backend/src/main/java/com.milktea.app/service/NotificationService.java
package com.milktea.app.service;

import com.milktea.app.dto.notification.NotificationBatchReadReqDTO;
import com.milktea.app.dto.notification.NotificationListResDTO;
import org.springframework.data.domain.Pageable;

public interface NotificationService {
    NotificationListResDTO getNotifications(Long userId, String type, Pageable pageable); // Added type parameter
    void markNotificationAsRead(Long userId, Long notificationId);
    void batchMarkNotificationsAsRead(Long userId, NotificationBatchReadReqDTO reqDTO);
    Long getUnreadNotificationCount(Long userId);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\service\OrderService.java ---
// File: milktea-backend/src/main/java/com.milktea.app/service/OrderService.java
package com.milktea.app.service;

import com.milktea.app.dto.order.*;
import org.springframework.data.domain.Pageable;

import java.time.Instant;

public interface OrderService {
    CheckoutResDTO getCheckoutDetails(Long userId, CheckoutReqDTO reqDTO);
    OrderValidateResDTO validateOrder(Long userId, OrderValidateReqDTO reqDTO);
    OrderCreateResDTO createOrder(Long userId, OrderCreateReqDTO reqDTO);
    // New: 4.1.2 立即购买
    OrderCreateResDTO buyNow(Long userId, OrderCreateReqDTO reqDTO);
    PaymentResDTO initiatePayment(Long userId, Long orderId, PaymentReqDTO reqDTO);
    PaymentStatusResDTO getPaymentStatus(Long userId, Long orderId);
    // New: 4.2.3 取消支付
    void cancelPayment(Long userId, Long orderId);
    OrderListResDTO getUserOrders(Long userId, String status, String type, Instant startDate, Instant endDate, Pageable pageable); // Added type, startDate, endDate
    OrderDetailResDTO getOrderDetail(Long userId, Long orderId);
    void cancelOrder(Long userId, Long orderId, OrderCancelReqDTO reqDTO);
    void confirmOrder(Long userId, Long orderId); // For pickup/delivery confirmation
    // New: 4.3.3.3 催单提醒
    void remindOrder(Long userId, Long orderId);
    void applyOrderRefund(Long userId, Long orderId, OrderRefundApplyReqDTO reqDTO);
    void addOrderReview(Long userId, Long orderId, OrderReviewReqDTO reqDTO);
    // WebSocket related
    void publishOrderStatusUpdate(Long orderId, String newStatus, String statusText, Instant estimatedTime);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\service\PointService.java ---
// File: milktea-backend/src/main/java/com.milktea.app/service/PointService.java
package com.milktea.app.service;

import com.milktea.app.dto.point.PointExchangeReqDTO;
import com.milktea.app.dto.point.PointTransactionListResDTO;
import org.springframework.data.domain.Pageable;

public interface PointService {
    PointTransactionListResDTO getPointTransactions(Long userId, String type, Pageable pageable); // Added type parameter
    void exchangePoints(Long userId, PointExchangeReqDTO reqDTO);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\service\ProductService.java ---
// File: milktea-backend/src/main/java/com.milktea.app/service/ProductService.java
package com.milktea.app.service;

import com.milktea.app.dto.product.ProductDetailResDTO;
import com.milktea.app.dto.product.ProductFavoriteStatusResDTO; // New DTO
import com.milktea.app.dto.product.ProductListReqDTO;
import com.milktea.app.dto.product.ProductListResDTO;
import org.springframework.data.domain.Pageable;

public interface ProductService {
    ProductListResDTO getProducts(ProductListReqDTO reqDTO, Pageable pageable); // Filter parameter in reqDTO
    ProductListResDTO getCategoryProducts(Long categoryId, ProductListReqDTO reqDTO, Pageable pageable); // New method
    ProductDetailResDTO getProductDetail(Long userId, Long productId);
    void addFavoriteProduct(Long userId, Long productId);
    void removeFavoriteProduct(Long userId, Long productId);
    // New: 2.3.4 获取收藏状态
    ProductFavoriteStatusResDTO getProductFavoriteStatus(Long userId, Long productId);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\service\SearchService.java ---
// File: milktea-backend/src/main/java/com.milktea.app/service/SearchService.java
package com.milktea.app.service;

import com.milktea.app.dto.search.ProductSearchReqDTO;
import com.milktea.app.dto.search.ProductSearchResDTO;
import com.milktea.app.dto.search.SearchHistoryReqDTO;
import com.milktea.app.dto.search.SearchHotKeywordsResDTO;
import com.milktea.app.dto.search.SearchSuggestResDTO;
import org.springframework.data.domain.Pageable;

public interface SearchService {
    ProductSearchResDTO searchProducts(Long userId, ProductSearchReqDTO reqDTO, Pageable pageable);
    SearchHotKeywordsResDTO getHotKeywordsAndHistory(Long userId, Integer limit); // Added limit parameter
    SearchSuggestResDTO getSearchSuggestions(String keyword, Integer limit); // Renamed prefix to keyword, added limit
    void addSearchHistory(Long userId, SearchHistoryReqDTO reqDTO);
    void clearSearchHistory(Long userId);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\service\StoreService.java ---
// File: milktea-backend/src/main/java/com.milktea.app/service/StoreService.java
package com.milktea.app.service;

import com.milktea.app.dto.store.StoreDetailResDTO;
import com.milktea.app.dto.store.StoreNearbyReqDTO;
import com.milktea.app.dto.store.StoreNearbyResDTO;

public interface StoreService {
    StoreNearbyResDTO getNearbyStores(Long userId, StoreNearbyReqDTO reqDTO);
    StoreDetailResDTO getStoreDetail(Long userId, Long storeId);
    void addFavoriteStore(Long userId, Long storeId);
    void removeFavoriteStore(Long userId, Long storeId);
    Boolean isStoreFavorite(Long userId, Long storeId);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\service\SystemService.java ---
// File: milktea-backend/src/main/java/com.milktea.app/service/SystemService.java
package com.milktea.app.service;

import com.milktea.app.dto.system.PageConfigResDTO;
import com.milktea.app.dto.system.SystemConfigResDTO;

import java.util.List;

public interface SystemService {
    SystemConfigResDTO getSystemConfigs();
    PageConfigResDTO getPageConfigs(String pageName);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\service\UserService.java ---
// File: milktea-backend/src/main/java/com.milktea.app/service/UserService.java
package com.milktea.app.service;

import com.milktea.app.dto.user.*;
import org.springframework.data.domain.Pageable;

import java.math.BigDecimal;

public interface UserService {
    UserProfileResDTO getUserProfile(Long userId);
    UserProfileResDTO updateProfile(Long userId, UserProfileUpdateReqDTO reqDTO);
    void updatePhone(Long userId, UserPhoneUpdateReqDTO reqDTO);
    UserAddressResDTO getUserAddresses(Long userId, Pageable pageable);
    UserAddressResDTO.AddressDTO getUserAddressDetail(Long userId, Long addressId);
    UserAddressResDTO.AddressDTO createUserAddress(Long userId, UserAddressCreateReqDTO reqDTO);
    UserAddressResDTO.AddressDTO updateUserAddress(Long userId, Long addressId, UserAddressCreateReqDTO reqDTO);
    void deleteUserAddress(Long userId, Long addressId);
    void setDefaultUserAddress(Long userId, Long addressId);
    // New: 1.3.6 根据定位获取地址
    UserAddressResDTO getAddressesByLocation(Long userId, BigDecimal longitude, BigDecimal latitude, Integer radius, Integer limit);
    ShareInfoResDTO getShareInfo(Long userId);
    GeneratePosterResDTO generateSharePoster(Long userId, GeneratePosterReqDTO reqDTO); // 这是微信实现的
    void recordShare(Long userId, ShareRecordReqDTO reqDTO); // 这是微信实现的
    // Add methods for sending verification codes (SMS service placeholder)
    void sendVerificationCode(String phone, String type);
    void verifyVerificationCode(String phone, String code, String type);
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\service\impl\AuthServiceImpl.java ---
// File: milktea-backend/src/main/java/com.milktea.app/service/impl/AuthServiceImpl.java
package com.milktea.app.service.impl;

import com.milktea.app.common.constant.ErrorCode;
import com.milktea.app.common.exception.BusinessException;
import com.milktea.app.dto.auth.AccountLoginReqDTO;
import com.milktea.app.dto.auth.UserAuthResDTO;
import com.milktea.app.dto.auth.WechatLoginReqDTO;
import com.milktea.app.dto.user.UserProfileResDTO;
import com.milktea.app.entity.UserEntity;
import com.milktea.app.jwt.JwtService;
import com.milktea.app.repository.UserRepository;
import com.milktea.app.service.AuthService;
import com.milktea.app.service.UserService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.client.RestTemplate;

import java.time.Instant;
import java.time.LocalDate;
import java.util.Optional;

@Service
@RequiredArgsConstructor
@Slf4j
public class AuthServiceImpl implements AuthService {

    private final UserRepository userRepository;
    private final JwtService jwtService;
    private final PasswordEncoder passwordEncoder;
    private final UserService userService; // To leverage user profile mapping
    private final RestTemplate restTemplate; // Placeholder for external API calls

    @Override
    @Transactional
    public UserAuthResDTO wechatLogin(WechatLoginReqDTO reqDTO) {
        // 这是微信实现的: Placeholder for WeChat API call
        // Example: Call WeChat API to exchange code for openid and session_key
        String wechatOpenId = mockWechatAuth(reqDTO.getCode());
        if (wechatOpenId == null) {
            throw new BusinessException(ErrorCode.WECHAT_LOGIN_FAILED, "WeChat authentication failed.");
        }

        Optional<UserEntity> existingUser = userRepository.findByWechatOpenid(wechatOpenId);
        UserEntity user;

        if (existingUser.isEmpty()) {
            // New user registration
            user = new UserEntity();
            user.setWechatOpenid(wechatOpenId);
            user.setNickname(reqDTO.getUserInfo() != null ? reqDTO.getUserInfo().getNickName() : "微信用户");
            user.setAvatarUrl(reqDTO.getUserInfo() != null ? reqDTO.getUserInfo().getAvatarUrl() : null);
            user.setGender(reqDTO.getUserInfo() != null ? reqDTO.getUserInfo().getGender().shortValue() : (short)0);
            user.setCountry(reqDTO.getUserInfo() != null ? reqDTO.getUserInfo().getCountry() : null);
            user.setProvince(reqDTO.getUserInfo() != null ? reqDTO.getUserInfo().getProvince() : null);
            user.setCity(reqDTO.getUserInfo() != null ? reqDTO.getUserInfo().getCity() : null);
            user.setIsActive(true);
            user.setGrowthValue(0);
            user.setPoints(0);
            user.setBalance(java.math.BigDecimal.ZERO);
            user.setCreatedAt(Instant.now());
            user.setUpdatedAt(Instant.now());
            user = userRepository.save(user);
            log.info("New user registered via WeChat: {}", user.getId());
        } else {
            user = existingUser.get();
            // Update last login time and potentially user info if provided
            user.setLastLoginAt(Instant.now());
            if (reqDTO.getUserInfo() != null) {
                user.setNickname(reqDTO.getUserInfo().getNickName());
                user.setAvatarUrl(reqDTO.getUserInfo().getAvatarUrl());
                user.setGender(reqDTO.getUserInfo().getGender().shortValue());
                user.setCountry(reqDTO.getUserInfo().getCountry());
                user.setProvince(reqDTO.getUserInfo().getProvince());
                user.setCity(reqDTO.getUserInfo().getCity());
            }
            userRepository.save(user);
        }

        String token = jwtService.generateToken(user.getId());
        return buildUserAuthResDTO(user, token);
    }

    @Override
    @Transactional
    public UserAuthResDTO accountLogin(AccountLoginReqDTO reqDTO) {
        Optional<UserEntity> userOptional = userRepository.findByUsernameOrPhoneOrEmail(
                reqDTO.getUsername(), reqDTO.getUsername(), reqDTO.getUsername());

        if (userOptional.isEmpty()) {
            throw new BusinessException(ErrorCode.USER_NOT_EXIST, "用户不存在");
        }

        UserEntity user = userOptional.get();

        // Placeholder for captcha validation
        if (reqDTO.getCaptcha() != null && !validateCaptcha(reqDTO.getCaptcha())) {
            throw new BusinessException(ErrorCode.INVALID_VERIFICATION_CODE, "验证码错误");
        }

        if (user.getPasswordHash() == null || !passwordEncoder.matches(reqDTO.getPassword(), user.getPasswordHash())) {
            throw new BusinessException(ErrorCode.INVALID_CREDENTIALS, "用户名或密码不正确");
        }

        user.setLastLoginAt(Instant.now());
        userRepository.save(user);

        String token = jwtService.generateToken(user.getId());
        return buildUserAuthResDTO(user, token);
    }

    @Override
    public void logout(String token) {
        // Invalidate the JWT token (add to a blacklist)
        jwtService.addToBlacklist(token);
        log.info("User logged out, token blacklisted.");
    }

    private UserAuthResDTO buildUserAuthResDTO(UserEntity user, String token) {
        UserProfileResDTO.UserDetailDTO userDetail = new UserProfileResDTO.UserDetailDTO();
        userDetail.setId(String.valueOf(user.getId()));
        userDetail.setNickname(user.getNickname());
        userDetail.setAvatar(user.getAvatarUrl());
        userDetail.setPhone(user.getPhone());
        // For level, assuming a direct mapping or simple logic
        userDetail.setLevel(mapMemberLevelToCode(user.getMemberLevel() != null ? user.getMemberLevel().getName() : null));
        userDetail.setLevelName(user.getMemberLevel() != null ? user.getMemberLevel().getName() : "普通会员");
        userDetail.setPoints(user.getPoints());
        userDetail.setBalance(user.getBalance());
        userDetail.setBirthday(user.getBirthday());
        userDetail.setCreatedAt(user.getCreatedAt());

        return new UserAuthResDTO(token, userDetail);
    }

    private String mockWechatAuth(String code) {
        // In a real application, this would call WeChat's API to get openid
        log.info("Mocking WeChat auth for code: {}", code);
        if ("mock_success_code".equals(code)) {
            // Simulate successful auth for a new user, or a known user
            return "mock_openid_" + System.currentTimeMillis(); // Generate a unique mock openid
        }
        if ("mock_existing_code".equals(code)) {
            return "mock_openid_existing_user"; // Return a consistent openid for an "existing" mock user
        }
        // Simulate failure
        return null;
    }

    private boolean validateCaptcha(String captcha) {
        // Placeholder for actual captcha (e.g., SMS verification code) validation logic
        // In a real scenario, this would involve checking against a stored code and its expiration.
        log.info("Mocking captcha validation for: {}", captcha);
        return "123456".equals(captcha); // Simple mock check for '123456'
    }

    private String mapMemberLevelToCode(String levelName) {
        if (levelName == null) {
            return "normal";
        }
        return switch (levelName) {
            case "普通会员" -> "normal";
            case "黄金会员" -> "gold";
            case "钻石会员" -> "diamond";
            default -> "normal"; // Default or unknown level
        };
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\service\impl\CartServiceImpl.java ---
// File: milktea-backend/src/main/java/com.milktea.app/service/impl/CartServiceImpl.java
package com.milktea.app.service.impl;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.milktea.app.common.constant.ErrorCode;
import com.milktea.app.common.exception.BusinessException;
import com.milktea.app.dto.cart.CartBatchOperationReqDTO;
import com.milktea.app.dto.cart.CartItemAddReqDTO;
import com.milktea.app.dto.cart.CartItemUpdateReqDTO;
import com.milktea.app.dto.cart.CartResDTO;
import com.milktea.app.entity.*;
import com.milktea.app.repository.*;
import com.milktea.app.service.CartService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class CartServiceImpl implements CartService {

    private final CartItemRepository cartItemRepository;
    private final CartItemCustomizationRepository cartItemCustomizationRepository;
    private final ProductRepository productRepository;
    private final ProductCustomizationTypeRepository customizationTypeRepository;
    private final ProductCustomizationOptionRepository customizationOptionRepository;
    private final UserRepository userRepository;
    private final ObjectMapper objectMapper; // For JSON parsing for product tags etc.

    @Override
    @Transactional(readOnly = true)
    public CartResDTO getCart(Long userId) {
        UserEntity user = userRepository.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_EXIST, "User not found."));

        List<CartItemEntity> cartItems = cartItemRepository.findByUserId(userId);
        List<CartResDTO.CartItemDTO> itemDTOs = new ArrayList<>();
        BigDecimal totalAmount = BigDecimal.ZERO;
        BigDecimal selectedAmount = BigDecimal.ZERO;
        int totalQuantity = 0;
        int selectedQuantity = 0;
        int validItemCount = 0;
        int invalidItemCount = 0;

        for (CartItemEntity item : cartItems) {
            // Re-validate product details and price to ensure it's up-to-date
            ProductEntity product = productRepository.findById(item.getProduct().getId())
                    .orElse(null);

            CartResDTO.CartItemDTO itemDTO = new CartResDTO.CartItemDTO();
            itemDTO.setId(item.getId());
            itemDTO.setProductId(item.getProduct().getId());
            itemDTO.setProductImage(item.getProduct().getMainImageUrl());

            boolean currentProductValid = true;
            String invalidReason = null;

            if (product == null || !product.getIsActive()) {
                currentProductValid = false;
                invalidReason = "商品已下架";
                itemDTO.setProductName(item.getProduct().getName() + "(已下架)"); // Show original name but indicate status
                itemDTO.setPrice(item.getPriceAtAdd()); // Keep original price for display
                itemDTO.setOriginalPrice(item.getOriginalPriceAtAdd());
            } else {
                itemDTO.setProductName(product.getName());
                itemDTO.setPrice(product.getPrice());
                itemDTO.setOriginalPrice(product.getOriginalPrice());
            }

            // Check stock
            if (currentProductValid && product.getStock() < item.getQuantity()) {
                currentProductValid = false;
                invalidReason = "库存不足";
            }

            itemDTO.setQuantity(item.getQuantity());
            itemDTO.setMaxQuantity(product != null ? product.getStock() : 0); // Current stock
            itemDTO.setStock(product != null ? product.getStock() : 0);
            itemDTO.setIsSelected(item.getIsSelected());
            itemDTO.setIsValid(currentProductValid);
            itemDTO.setInvalidReason(invalidReason);

            // Calculate subtotal for the item
            BigDecimal itemBasePrice = currentProductValid ? product.getPrice() : item.getPriceAtAdd();
            BigDecimal itemSubtotal = itemBasePrice.multiply(BigDecimal.valueOf(item.getQuantity()));

            // Add customization price adjustments
            CartResDTO.CustomizationsDTO customizationsDTO = new CartResDTO.CustomizationsDTO();
            List<CartResDTO.ToppingDTO> toppingDTOs = new ArrayList<>();

            for (CartItemCustomizationEntity customization : item.getCustomizations()) {
                BigDecimal adjustment = currentProductValid ?
                        customizationOptionRepository.findById(getOptionIdFromValue(customization.getOptionValue())) // This needs to be improved; direct value lookup is problematic
                                .map(ProductCustomizationOptionEntity::getPriceAdjustment)
                                .orElse(customization.getPriceAdjustmentAtAdd()) : customization.getPriceAdjustmentAtAdd();

                itemSubtotal = itemSubtotal.add(adjustment.multiply(BigDecimal.valueOf(customization.getQuantity())));

                CartResDTO.OptionDTO optionDTO = new CartResDTO.OptionDTO(
                        customization.getOptionValue(),
                        customization.getOptionLabel(),
                        adjustment
                );
                switch (customization.getCustomizationTypeName()) {
                    case "sweetness" -> customizationsDTO.setSweetness(optionDTO);
                    case "temperature" -> customizationsDTO.setTemperature(optionDTO);
                    case "toppings" -> toppingDTOs.add(new CartResDTO.ToppingDTO(
                            customization.getOptionValue(),
                            customization.getOptionLabel(),
                            adjustment,
                            customization.getQuantity()
                    ));
                }
            }
            customizationsDTO.setToppings(toppingDTOs);
            itemDTO.setCustomizations(customizationsDTO);
            itemDTO.setSubtotal(itemSubtotal);

            itemDTOs.add(itemDTO);

            totalQuantity += item.getQuantity();
            totalAmount = totalAmount.add(itemSubtotal);

            if (item.getIsSelected()) {
                selectedQuantity += item.getQuantity();
                selectedAmount = selectedAmount.add(itemSubtotal);
            }

            if (currentProductValid) {
                validItemCount++;
            } else {
                invalidItemCount++;
            }
        }

        // Calculate final summary
        // For simplicity, delivery fee and discount are placeholders.
        BigDecimal deliveryFee = BigDecimal.ZERO; // Will be calculated in checkout based on store/address
        BigDecimal totalDiscount = BigDecimal.ZERO; // Will be calculated in checkout based on coupons/promotions
        BigDecimal finalAmount = selectedAmount.add(deliveryFee).subtract(totalDiscount);

        CartResDTO.CartSummaryDTO summary = new CartResDTO.CartSummaryDTO(
                totalQuantity, selectedQuantity, totalAmount, selectedAmount,
                totalDiscount, deliveryFee, finalAmount, validItemCount, invalidItemCount
        );

        return new CartResDTO(itemDTOs, summary);
    }

    @Override
    @Transactional
    public CartResDTO addCartItem(Long userId, CartItemAddReqDTO reqDTO) {
        UserEntity user = userRepository.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_EXIST, "User not found."));
        ProductEntity product = productRepository.findById(reqDTO.getProductId())
                .orElseThrow(() -> new BusinessException(ErrorCode.PRODUCT_NOT_FOUND, "Product not found."));

        if (!product.getIsActive()) {
            throw new BusinessException(ErrorCode.PRODUCT_OFFLINE, "Product is offline.");
        }
        if (product.getStock() < reqDTO.getQuantity()) {
            throw new BusinessException(ErrorCode.PRODUCT_STOCK_INSUFFICIENT, "Product stock insufficient.");
        }

        // Check if item with same product and *same customizations* already exists
        // This logic can be complex due to customization comparison. For simplicity,
        // we'll assume one entry per product in cart for now, and customizations are updated.
        // A more robust solution would involve a hash of customizations for unique cart items.
        Optional<CartItemEntity> existingCartItemOptional = cartItemRepository.findByUserIdAndProductId(userId, reqDTO.getProductId());
        CartItemEntity cartItem;

        if (existingCartItemOptional.isPresent()) {
            cartItem = existingCartItemOptional.get();
            cartItem.setQuantity(cartItem.getQuantity() + reqDTO.getQuantity()); // Just increase quantity
            // For production: if customizations can change for the same product,
            // new custom entry or logic to handle variant selection is needed.
            // For now, we update customizations if provided, overwriting previous ones.
            updateCartItemCustomizations(cartItem, product, reqDTO.getChoices());
        } else {
            cartItem = new CartItemEntity();
            cartItem.setUser(user);
            cartItem.setProduct(product);
            cartItem.setQuantity(reqDTO.getQuantity());
            cartItem.setIsSelected(true);
            cartItem.setIsValid(true);
            cartItem.setPriceAtAdd(product.getPrice());
            cartItem.setOriginalPriceAtAdd(product.getOriginalPrice());
            cartItem = cartItemRepository.save(cartItem);
            updateCartItemCustomizations(cartItem, product, reqDTO.getChoices());
        }

        return getCart(userId);
    }

    @Override
    @Transactional
    public CartResDTO updateCartItem(Long userId, Long cartItemId, CartItemUpdateReqDTO reqDTO) {
        CartItemEntity cartItem = cartItemRepository.findById(cartItemId)
                .orElseThrow(() -> new BusinessException(ErrorCode.CART_ITEM_NOT_FOUND, "Cart item not found."));

        if (!cartItem.getUser().getId().equals(userId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN, "Access denied to cart item.");
        }

        ProductEntity product = productRepository.findById(cartItem.getProduct().getId())
                .orElseThrow(() -> new BusinessException(ErrorCode.PRODUCT_NOT_FOUND, "Product not found."));

        if (!product.getIsActive()) {
            throw new BusinessException(ErrorCode.PRODUCT_OFFLINE, "Product is offline.");
        }

        if (reqDTO.getQuantity() != null) {
            if (product.getStock() < reqDTO.getQuantity()) {
                throw new BusinessException(ErrorCode.PRODUCT_STOCK_INSUFFICIENT, "Product stock insufficient.");
            }
            cartItem.setQuantity(reqDTO.getQuantity());
        }

        // Update customizations if provided
        if (reqDTO.getChoices() != null) {
            updateCartItemCustomizations(cartItem, product, reqDTO.getChoices());
        }

        cartItemRepository.save(cartItem);
        return getCart(userId);
    }

    @Override
    @Transactional
    public CartResDTO deleteCartItem(Long userId, Long cartItemId) {
        CartItemEntity cartItem = cartItemRepository.findById(cartItemId)
                .orElseThrow(() -> new BusinessException(ErrorCode.CART_ITEM_NOT_FOUND, "Cart item not found."));

        if (!cartItem.getUser().getId().equals(userId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN, "Access denied to cart item.");
        }

        cartItemRepository.delete(cartItem);
        return getCart(userId);
    }

    @Override
    @Transactional
    public CartResDTO batchOperateCartItems(Long userId, CartBatchOperationReqDTO reqDTO) {
        List<CartItemEntity> cartItems = new ArrayList<>();
        if (reqDTO.getItemIds() != null && !reqDTO.getItemIds().isEmpty()) {
            cartItems = cartItemRepository.findAllById(reqDTO.getItemIds());
            cartItems = cartItems.stream()
                    .filter(item -> item.getUser().getId().equals(userId))
                    .collect(Collectors.toList());
        } else if ("select_all".equals(reqDTO.getAction()) || "unselect_all".equals(reqDTO.getAction())) {
            cartItems = cartItemRepository.findByUserId(userId);
        }

        switch (reqDTO.getAction()) {
            case "select_all" -> cartItems.forEach(item -> item.setIsSelected(true));
            case "unselect_all" -> cartItems.forEach(item -> item.setIsSelected(false));
            case "delete_selected" -> {
                cartItemRepository.deleteAll(cartItems);
                // After deletion, fetch the remaining cart items
                return getCart(userId);
            }
            default -> throw new BusinessException(ErrorCode.INVALID_PARAM, "Unsupported cart batch operation.");
        }
        cartItemRepository.saveAll(cartItems);
        return getCart(userId);
    }

    @Override
    @Transactional
    public void clearCart(Long userId) {
        cartItemRepository.deleteByUserId(userId);
    }

    private void updateCartItemCustomizations(CartItemEntity cartItem, ProductEntity product, CartItemAddReqDTO.Customization choices) {
        // Clear existing customizations for this cart item
        cartItemCustomizationRepository.deleteAll(cartItem.getCustomizations());
        cartItem.setCustomizations(new ArrayList<>()); // Clear the list in the entity

        if (choices == null) return;

        // Fetch product's customization types and options
        Map<String, ProductCustomizationTypeEntity> productCustomizationTypes = customizationTypeRepository.findByProductIdAndIsEnabledTrueOrderBySortOrderAsc(product.getId())
                .stream()
                .collect(Collectors.toMap(ProductCustomizationTypeEntity::getTypeName, type -> type));

        if (choices.getSweetness() != null) {
            ProductCustomizationTypeEntity type = productCustomizationTypes.get("sweetness");
            if (type != null) {
                ProductCustomizationOptionEntity option = type.getOptions().stream()
                        .filter(o -> o.getValue().equals(choices.getSweetness()))
                        .findFirst()
                        .orElseThrow(() -> new BusinessException(ErrorCode.INVALID_PARAM, "Invalid sweetness option."));
                cartItem.getCustomizations().add(createCartItemCustomization(cartItem, type, option, 1));
            }
        }
        if (choices.getTemperature() != null) {
            ProductCustomizationTypeEntity type = productCustomizationTypes.get("temperature");
            if (type != null) {
                ProductCustomizationOptionEntity option = type.getOptions().stream()
                        .filter(o -> o.getValue().equals(choices.getTemperature()))
                        .findFirst()
                        .orElseThrow(() -> new BusinessException(ErrorCode.INVALID_PARAM, "Invalid temperature option."));
                cartItem.getCustomizations().add(createCartItemCustomization(cartItem, type, option, 1));
            }
        }
        if (choices.getToppings() != null && !choices.getToppings().isEmpty()) {
            ProductCustomizationTypeEntity type = productCustomizationTypes.get("toppings");
            if (type != null) {
                Map<String, ProductCustomizationOptionEntity> toppingOptions = type.getOptions().stream()
                        .collect(Collectors.toMap(ProductCustomizationOptionEntity::getValue, o -> o));

                for (CartItemAddReqDTO.ToppingItem toppingItem : choices.getToppings()) {
                    ProductCustomizationOptionEntity option = toppingOptions.get(toppingItem.getId());
                    if (option == null) {
                        throw new BusinessException(ErrorCode.INVALID_PARAM, "Invalid topping option: " + toppingItem.getId());
                    }
                    if (option.getStock() != null && option.getStock() < toppingItem.getQuantity()) {
                        throw new BusinessException(ErrorCode.PRODUCT_STOCK_INSUFFICIENT, "Topping stock insufficient for: " + option.getLabel());
                    }
                    cartItem.getCustomizations().add(createCartItemCustomization(cartItem, type, option, toppingItem.getQuantity()));
                }
            }
        }
        cartItemCustomizationRepository.saveAll(cartItem.getCustomizations());
    }

    private CartItemCustomizationEntity createCartItemCustomization(
            CartItemEntity cartItem,
            ProductCustomizationTypeEntity type,
            ProductCustomizationOptionEntity option,
            Integer quantity) {
        CartItemCustomizationEntity customization = new CartItemCustomizationEntity();
        customization.setCartItem(cartItem);
        customization.setCustomizationTypeName(type.getTypeName());
        customization.setOptionValue(option.getValue());
        customization.setOptionLabel(option.getLabel());
        customization.setPriceAdjustmentAtAdd(option.getPriceAdjustment());
        customization.setQuantity(quantity);
        return customization;
    }

    // This is a simplified method. In a real system, customization options would have their own IDs.
    // DTO uses 'value' for options, so we need to map that back to an ID if fetching from repo directly.
    private Long getOptionIdFromValue(String optionValue) {
        // This is highly problematic without knowing the actual mapping or global option IDs.
        // For a more robust solution, the `ProductCustomizationOptionEntity` should either:
        // 1. Have a unique 'code' field that maps to DTO 'value'.
        // 2. Be fetched by `customizationType.id` and `value`.
        // Placeholder for now.
        log.warn("Directly mapping option value '{}' to a dummy ID. This needs proper implementation.", optionValue);
        // Returning a dummy ID or throwing an error is appropriate for a placeholder.
        // For a real app, you'd likely query:
        // customizationOptionRepository.findByCustomizationTypeAndValue(type, optionValue).getId();
        return 1L; // Dummy ID
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\service\impl\CategoryServiceImpl.java ---
// File: milktea-backend/src/main/java/com.milktea.app/service/impl/CategoryServiceImpl.java
package com.milktea.app.service.impl;

import com.milktea.app.dto.category.CategoryTreeResDTO;
import com.milktea.app.entity.CategoryEntity;
import com.milktea.app.repository.CategoryRepository;
import com.milktea.app.service.CategoryService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class CategoryServiceImpl implements CategoryService {

    private final CategoryRepository categoryRepository;

    @Override
    @Transactional(readOnly = true)
    public List<CategoryTreeResDTO> getCategoryTree() {
        // Fetch all active categories
        List<CategoryEntity> allCategories = categoryRepository.findByIsActiveTrueOrderBySortOrderAsc();

        // Build a map for quick lookup by ID
        // Map<Long, CategoryEntity> categoryMap = allCategories.stream()
        //         .collect(Collectors.toMap(CategoryEntity::getId, category -> category));

        // Filter for top-level categories (parent_id is null)
        List<CategoryEntity> topLevelCategories = allCategories.stream()
                .filter(category -> category.getParent() == null)
                .collect(Collectors.toList());

        // Recursively build the DTO tree
        return topLevelCategories.stream()
                .map(this::mapToCategoryTreeDTO)
                .collect(Collectors.toList());
    }

    private CategoryTreeResDTO mapToCategoryTreeDTO(CategoryEntity entity) {
        CategoryTreeResDTO dto = new CategoryTreeResDTO();
        dto.setId(entity.getId());
        dto.setParentId(entity.getParent() != null ? entity.getParent().getId() : null);
        dto.setName(entity.getName());
        dto.setIcon(entity.getIconUrl());
        dto.setImage(entity.getImageUrl());
        dto.setSort(entity.getSortOrder());
        dto.setDescription(entity.getDescription());
        // For productCount, this would typically be a cached field or derived from a complex query
        dto.setProductCount(0); // Placeholder
        dto.setChildren(entity.getChildren().stream()
                .map(this::mapToCategoryTreeDTO)
                .collect(Collectors.toList()));
        return dto;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\service\impl\CouponServiceImpl.java ---
// File: milktea-backend/src/main/java/com.milktea.app/service/impl/CouponServiceImpl.java
package com.milktea.app.service.impl;

import com.milktea.app.common.constant.ErrorCode;
import com.milktea.app.common.exception.BusinessException;
import com.milktea.app.common.util.DateUtil;
import com.milktea.app.dto.coupon.CouponBatchReceiveReqDTO;
import com.milktea.app.dto.coupon.CouponListResDTO;
import com.milktea.app.dto.coupon.CouponReceiveResDTO;
import com.milktea.app.entity.CouponTemplateEntity;
import com.milktea.app.entity.UserCouponEntity;
import com.milktea.app.entity.UserEntity;
import com.milktea.app.repository.CouponTemplateRepository;
import com.milktea.app.repository.UserCouponRepository;
import com.milktea.app.repository.UserRepository;
import com.milktea.app.service.CouponService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class CouponServiceImpl implements CouponService {

    private final UserCouponRepository userCouponRepository;
    private final CouponTemplateRepository couponTemplateRepository;
    private final UserRepository userRepository;

    @Override
    @Transactional(readOnly = true)
    public CouponListResDTO getUserCoupons(Long userId, String status, Pageable pageable) {
        userRepository.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_EXIST, "User not found."));

        List<UserCouponEntity> userCoupons;
        if (status == null || status.equalsIgnoreCase("all")) {
            // Fetch all coupons for the user, then filter and paginate in memory or refine repository query
            // For simplicity here, we'll assume the repo can handle it or fetch all then filter.
            // A production app would have more specific queries or predicates.
            userCoupons = userCouponRepository.findByUserIdAndStatusOrderByExpireAtAsc(userId, "available"); // Example
            userCoupons.addAll(userCouponRepository.findByUserIdAndStatusOrderByExpireAtAsc(userId, "used"));
            userCoupons.addAll(userCouponRepository.findByUserIdAndStatusOrderByExpireAtAsc(userId, "expired"));
        } else {
            userCoupons = userCouponRepository.findByUserIdAndStatusOrderByExpireAtAsc(userId, status.toLowerCase());
        }

        List<CouponListResDTO.CouponDTO> couponDTOs = userCoupons.stream()
                .map(this::mapToCouponDTO)
                .collect(Collectors.toList());

        // Manual pagination if not using Page directly from JPA
        int start = (int) pageable.getOffset();
        int end = Math.min((start + pageable.getPageSize()), couponDTOs.size());
        List<CouponListResDTO.CouponDTO> pagedDTOs = couponDTOs.subList(start, end);
        Page<CouponListResDTO.CouponDTO> couponPage = new PageImpl<>(pagedDTOs, pageable, couponDTOs.size());


        CouponListResDTO resDTO = new CouponListResDTO();
        resDTO.setCoupons(couponPage.getContent());
        resDTO.setTotal((int) couponPage.getTotalElements());
        resDTO.setPage(pageable.getPageNumber() + 1);
        resDTO.setLimit(pageable.getPageSize());
        return resDTO;
    }

    @Override
    @Transactional
    public CouponReceiveResDTO receiveCoupon(Long userId, Long templateId) {
        UserEntity user = userRepository.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_EXIST, "User not found."));
        CouponTemplateEntity template = couponTemplateRepository.findById(templateId)
                .orElseThrow(() -> new BusinessException(ErrorCode.COUPON_NOT_FOUND, "Coupon template not found."));

        if (!template.getIsActive()) {
            throw new BusinessException(ErrorCode.COUPON_NOT_FOUND, "Coupon is not active.");
        }
        if (template.getRemainingQuantity() <= 0) {
            throw new BusinessException(ErrorCode.COUPON_OUT_OF_STOCK, "Coupon has been fully distributed.");
        }

        long acquiredCount = userCouponRepository.countByUserIdAndCouponTemplateIdAndStatus(userId, templateId, "available") +
                userCouponRepository.countByUserIdAndCouponTemplateIdAndStatus(userId, templateId, "used");
        if (acquiredCount >= template.getAcquireLimit()) {
            throw new BusinessException(ErrorCode.COUPON_ACQUIRE_LIMIT_REACHED, "User has reached the acquisition limit for this coupon.");
        }

        UserCouponEntity userCoupon = new UserCouponEntity();
        userCoupon.setUser(user);
        userCoupon.setCouponTemplate(template);
        userCoupon.setStatus("available");
        userCoupon.setReceivedAt(Instant.now());
        userCoupon.setCreatedAt(Instant.now());
        userCoupon.setUpdatedAt(Instant.now());

        // Calculate expire_at based on validity_type
        if ("fixed_days".equalsIgnoreCase(template.getValidityType())) {
            userCoupon.setExpireAt(Instant.now().plus(template.getValidDays(), ChronoUnit.DAYS));
        } else if ("fixed_date_range".equalsIgnoreCase(template.getValidityType())) {
            // Convert LocalDate to Instant, assuming end of day for expiration
            userCoupon.setExpireAt(template.getEndDate().plusDays(1).atStartOfDay(java.time.ZoneOffset.UTC).toInstant());
        } else {
            throw new BusinessException(ErrorCode.SYSTEM_ERROR, "Invalid coupon validity type.");
        }

        template.setRemainingQuantity(template.getRemainingQuantity() - 1); // Decrease remaining quantity
        couponTemplateRepository.save(template);
        userCoupon = userCouponRepository.save(userCoupon);

        return new CouponReceiveResDTO(true, userCoupon.getId());
    }

    @Override
    @Transactional
    public CouponReceiveResDTO batchReceiveCoupons(Long userId, CouponBatchReceiveReqDTO reqDTO) {
        // This method can call receiveCoupon for each ID, handling individual errors or batching
        // For simplicity, we'll iterate and collect successes.
        boolean overallSuccess = true;
        for (Long templateId : reqDTO.getCouponIds()) {
            try {
                receiveCoupon(userId, templateId); // Attempt to receive each coupon
            } catch (BusinessException e) {
                log.warn("Failed to receive coupon {} for user {}: {}", templateId, userId, e.getMessage());
                overallSuccess = false; // Mark overall operation as partially failed
            }
        }
        // Return a generic success/failure for batch, or a list of individual results
        return new CouponReceiveResDTO(overallSuccess, null); // couponId is null for batch success
    }

    private CouponListResDTO.CouponDTO mapToCouponDTO(UserCouponEntity entity) {
        CouponListResDTO.CouponDTO dto = new CouponListResDTO.CouponDTO();
        dto.setId(entity.getId());
        dto.setName(entity.getCouponTemplate().getName());
        dto.setType(entity.getCouponTemplate().getType());
        dto.setValue(entity.getCouponTemplate().getValue());
        dto.setMinAmount(entity.getCouponTemplate().getMinAmount());
        dto.setDescription(entity.getCouponTemplate().getDescription());
        dto.setUsage(entity.getCouponTemplate().getUsageScope());
        // For targetIds, parse JSONB string to List<String>
        if (entity.getCouponTemplate().getTargetIds() != null) {
            try {
                dto.setTargetIds(objectMapper.readValue(entity.getCouponTemplate().getTargetIds(), List.class));
            } catch (JsonProcessingException e) {
                log.error("Error parsing targetIds JSON: {}", entity.getCouponTemplate().getTargetIds(), e);
                dto.setTargetIds(List.of());
            }
        } else {
            dto.setTargetIds(List.of());
        }
        dto.setStatus(entity.getStatus());
        dto.setReceivedAt(entity.getReceivedAt());
        dto.setExpireAt(entity.getExpireAt());
        dto.setUsedAt(entity.getUsedAt());
        dto.setOrderId(entity.getOrderId());

        // Computed fields
        boolean canUse = "available".equalsIgnoreCase(entity.getStatus()) && entity.getExpireAt().isAfter(Instant.now());
        dto.setCanUse(canUse);
        if (!canUse) {
            if ("used".equalsIgnoreCase(entity.getStatus())) {
                dto.unusableReason = "已使用";
            } else if (entity.getExpireAt().isBefore(Instant.now())) {
                dto.unusableReason = "已过期";
            } else {
                dto.unusableReason = "不可用";
            }
        }

        return dto;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\service\impl\FileServiceImpl.java ---
// File: milktea-backend/src/main/java/com.milktea.app/service/impl/FileServiceImpl.java
package com.milktea.app.service.impl;

import com.milktea.app.common.constant.ErrorCode;
import com.milktea.app.common.exception.BusinessException;
import com.milktea.app.dto.file.FileUploadResDTO;
import com.milktea.app.entity.FileEntity;
import com.milktea.app.entity.UserEntity;
import com.milktea.app.repository.FileRepository;
import com.milktea.app.repository.UserRepository;
import com.milktea.app.service.FileService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.Instant;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class FileServiceImpl implements FileService {

    @Value("${file.upload-dir:uploads}") // Configurable upload directory
    private String uploadDir;
    @Value("${file.max-size-mb:5}") // Max file size in MB
    private long maxFileSizeMb;
    @Value("${file.supported-image-types:image/jpeg,image/png,image/gif}")
    private List<String> supportedImageTypes;

    private final FileRepository fileRepository;
    private final UserRepository userRepository;

    @Override
    @Transactional
    public FileUploadResDTO uploadFile(Long userId, MultipartFile file, String category) {
        if (file.isEmpty()) {
            throw new BusinessException(ErrorCode.INVALID_PARAM, "File cannot be empty.");
        }

        if (file.getSize() > maxFileSizeMb * 1024 * 1024) {
            throw new BusinessException(ErrorCode.FILE_SIZE_EXCEEDS_LIMIT, "File size exceeds limit (" + maxFileSizeMb + "MB).");
        }

        String contentType = file.getContentType();
        if (contentType == null || !supportedImageTypes.contains(contentType)) {
            throw new BusinessException(ErrorCode.INVALID_FILE_TYPE, "Unsupported file type: " + contentType + ". Only JPEG, PNG, GIF are allowed.");
        }

        try {
            // Ensure upload directory exists
            Path uploadPath = Paths.get(uploadDir).toAbsolutePath().normalize();
            Files.createDirectories(uploadPath);

            String originalFilename = file.getOriginalFilename();
            String fileExtension = "";
            if (originalFilename != null && originalFilename.contains(".")) {
                fileExtension = originalFilename.substring(originalFilename.lastIndexOf("."));
            }
            String fileName = UUID.randomUUID().toString() + fileExtension;
            Path filePath = uploadPath.resolve(fileName);

            Files.copy(file.getInputStream(), filePath);

            // Get image dimensions
            BufferedImage bimg = ImageIO.read(file.getInputStream());
            int width = bimg.getWidth();
            int height = bimg.getHeight();

            UserEntity user = null;
            if (userId != null) {
                user = userRepository.findById(userId)
                        .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_EXIST, "User not found."));
            }

            FileEntity fileEntity = new FileEntity();
            fileEntity.setUser(user);
            fileEntity.setUrl("/uploads/" + fileName); // Assuming a /uploads endpoint exposes these files
            fileEntity.setPath(filePath.toString());
            fileEntity.setSize((int) file.getSize());
            fileEntity.setType(getFileTypeFromContentType(contentType));
            fileEntity.setCategory(category);
            fileEntity.setWidth(width);
            fileEntity.setHeight(height);
            fileEntity.setMimeType(contentType);
            fileEntity.setCreatedAt(Instant.now());

            fileEntity = fileRepository.save(fileEntity);

            return new FileUploadResDTO(
                    fileEntity.getUrl(),
                    fileEntity.getPath(),
                    fileEntity.getSize(),
                    fileEntity.getMimeType(),
                    fileEntity.getWidth(),
                    fileEntity.getHeight()
            );

        } catch (IOException e) {
            log.error("File upload failed for user {}: {}", userId, e.getMessage(), e);
            throw new BusinessException(ErrorCode.FILE_UPLOAD_FAILED, "Failed to upload file: " + e.getMessage());
        }
    }

    private String getFileTypeFromContentType(String contentType) {
        if (contentType == null) return "unknown";
        if (contentType.startsWith("image/")) return "image";
        if (contentType.startsWith("video/")) return "video";
        if (contentType.startsWith("audio/")) return "audio";
        return "other";
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\service\impl\HomeServiceImpl.java ---
// File: milktea-backend/src/main/java/com.milktea.app/service/impl/HomeServiceImpl.java
package com.milktea.app.service.impl;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.milktea.app.common.constant.ErrorCode;
import com.milktea.app.common.exception.BusinessException;
import com.milktea.app.common.util.GeoUtil;
import com.milktea.app.dto.home.HomePageResDTO;
import com.milktea.app.dto.product.ProductListResDTO;
import com.milktea.app.entity.*;
import com.milktea.app.repository.*;
import com.milktea.app.service.HomeService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class HomeServiceImpl implements HomeService {

    private final BannerRepository bannerRepository;
    private final QuickEntryRepository quickEntryRepository;
    private final ProductRepository productRepository;
    private final CategoryRepository categoryRepository;
    private final PromotionRepository promotionRepository;
    private final StoreRepository storeRepository;
    private final UserFavoriteStoreRepository userFavoriteStoreRepository;
    private final ObjectMapper objectMapper;

    @Override
    @Transactional(readOnly = true)
    public HomePageResDTO getHomePageData(BigDecimal latitude, BigDecimal longitude) {
        HomePageResDTO homePageResDTO = new HomePageResDTO();

        // 1. Banners
        List<BannerEntity> bannerEntities = bannerRepository.findByIsActiveTrueOrderBySortOrderAsc();
        homePageResDTO.setBanners(bannerEntities.stream()
                .map(this::mapToBannerDTO)
                .collect(Collectors.toList()));

        // 2. Quick Entries
        List<QuickEntryEntity> quickEntryEntities = quickEntryRepository.findByIsActiveTrueOrderBySortOrderAsc();
        homePageResDTO.setQuickEntries(quickEntryEntities.stream()
                .map(this::mapToQuickEntryDTO)
                .collect(Collectors.toList()));

        // 3. Recommend Products (e.g., is_recommend=true)
        List<ProductEntity> recommendProducts = productRepository.findByIsRecommendTrueAndIsActiveTrue();
        homePageResDTO.setRecommendProducts(new HomePageResDTO.RecommendProductsDTO(
                "为你推荐",
                recommendProducts.stream()
                        .map(this::mapToProductItemDTO)
                        .collect(Collectors.toList())
        ));

        // 4. Categories (e.g., top-level active categories)
        List<CategoryEntity> categories = categoryRepository.findByParentIsNullAndIsActiveTrueOrderBySortOrderAsc();
        homePageResDTO.setCategories(categories.stream()
                .map(this::mapToCategoryDTO)
                .collect(Collectors.toList()));

        // 5. Hot Products (e.g., is_hot=true, ordered by monthly sales)
        List<ProductEntity> hotProducts = productRepository.findByIsHotTrueAndIsActiveTrueOrderByMonthlySalesDesc();
        homePageResDTO.setHotProducts(hotProducts.stream()
                .limit(5) // Limit to top 5 hot products
                .map(this::mapToHotProductDTO)
                .collect(Collectors.toList()));

        // 6. Promotions
        List<PromotionEntity> promotionEntities = promotionRepository.findByIsActiveTrueAndEndTimeAfterOrderByStartTimeAsc(Instant.now());
        homePageResDTO.setPromotions(promotionEntities.stream()
                .map(this::mapToPromotionDTO)
                .collect(Collectors.toList()));

        // 7. Nearby Store (Requires latitude and longitude)
        if (latitude != null && longitude != null) {
            List<StoreEntity> nearbyStores = storeRepository.findNearbyStoresNative(latitude, longitude, 5000.0, 1); // 5km radius, top 1
            if (!nearbyStores.isEmpty()) {
                StoreEntity nearestStore = nearbyStores.get(0);
                homePageResDTO.setNearbyStore(mapToNearbyStoreDTO(nearestStore, latitude, longitude, null)); // userId is null for public homepage
            } else {
                homePageResDTO.setNearbyStore(null); // No nearby store found
            }
        } else {
            homePageResDTO.setNearbyStore(null); // No location provided
        }

        return homePageResDTO;
    }

    @Override
    @Transactional(readOnly = true)
    public ProductListResDTO getRecommendedProducts(Integer limit, String type) {
        List<ProductEntity> recommendedProducts;
        // Placeholder for more sophisticated recommendation logic based on 'type'
        if ("category".equalsIgnoreCase(type)) {
            // Example: recommend from a specific category (e.g. ID 1 for Milk Tea)
            recommendedProducts = productRepository.findByCategoryIdAndIsActiveTrue(1L);
        } else if ("combo".equalsIgnoreCase(type)) {
            // Example: recommend combo products (assuming a tag or flag for combos)
            recommendedProducts = productRepository.findByIsActiveTrue(PageRequest.of(0, limit)).getContent().stream()
                    .filter(p -> p.getTags() != null && p.getTags().contains("combo")) // Simplified
                    .collect(Collectors.toList());
        } else { // Default or "product" type
            recommendedProducts = productRepository.findByIsRecommendTrueAndIsActiveTrue();
        }

        List<ProductListResDTO.ProductItemDTO> productItemDTOs = recommendedProducts.stream()
                .limit(limit != null ? limit : 10)
                .map(this::mapToProductItemDTO)
                .collect(Collectors.toList());

        ProductListResDTO resDTO = new ProductListResDTO();
        resDTO.setProducts(productItemDTOs);
        resDTO.setTotal(productItemDTOs.size()); // Total for this specific recommendation list
        resDTO.setPage(1);
        resDTO.setLimit(limit != null ? limit : 10);
        return resDTO;
    }


    private HomePageResDTO.BannerDTO mapToBannerDTO(BannerEntity entity) {
        HomePageResDTO.BannerDTO dto = new HomePageResDTO.BannerDTO();
        dto.setId(String.valueOf(entity.getId()));
        dto.setImage(entity.getImageUrl());
        dto.setTitle(entity.getTitle());
        dto.setSubtitle(entity.getSubtitle());
        dto.setType(entity.getType());
        dto.setTargetId(entity.getTargetId());
        dto.setUrl(entity.getUrl());
        dto.setBackgroundColor(entity.getBackgroundColor());
        return dto;
    }

    private HomePageResDTO.QuickEntryDTO mapToQuickEntryDTO(QuickEntryEntity entity) {
        HomePageResDTO.QuickEntryDTO dto = new HomePageResDTO.QuickEntryDTO();
        dto.setId(String.valueOf(entity.getId()));
        dto.setIcon(entity.getIconUrl());
        dto.setName(entity.getName());
        dto.setType(entity.getType());
        dto.setTargetId(String.valueOf(entity.getTargetId()));
        dto.setBadge(entity.getBadge());
        return dto;
    }

    private HomePageResDTO.ProductItemDTO mapToProductItemDTO(ProductEntity entity) {
        HomePageResDTO.ProductItemDTO dto = new HomePageResDTO.ProductItemDTO();
        dto.setId(String.valueOf(entity.getId()));
        dto.setName(entity.getName());
        dto.setImage(entity.getMainImageUrl());
        dto.setPrice(entity.getPrice());
        dto.setOriginalPrice(entity.getOriginalPrice());
        dto.setSales(entity.getSales());
        // Parse tags from JSONB string
        if (entity.getTags() != null) {
            try {
                dto.setTags(objectMapper.readValue(entity.getTags(), new TypeReference<List<String>>() {}));
            } catch (Exception e) {
                log.error("Failed to parse product tags for product {}: {}", entity.getId(), e.getMessage());
                dto.setTags(new ArrayList<>());
            }
        } else {
            dto.setTags(new ArrayList<>());
        }
        dto.setDescription(entity.getDescription());
        return dto;
    }

    private HomePageResDTO.CategoryDTO mapToCategoryDTO(CategoryEntity entity) {
        HomePageResDTO.CategoryDTO dto = new HomePageResDTO.CategoryDTO();
        dto.setId(String.valueOf(entity.getId()));
        dto.setName(entity.getName());
        dto.setIcon(entity.getIconUrl());
        dto.setImage(entity.getImageUrl());
        // Product count would need a separate query or cached value
        dto.setProductCount(0); // Placeholder
        dto.setDescription(entity.getDescription());
        return dto;
    }

    private HomePageResDTO.HotProductDTO mapToHotProductDTO(ProductEntity entity) {
        HomePageResDTO.HotProductDTO dto = new HomePageResDTO.HotProductDTO();
        dto.setId(String.valueOf(entity.getId()));
        dto.setRank(0); // Placeholder for actual ranking logic
        dto.setName(entity.getName());
        dto.setImage(entity.getMainImageUrl());
        dto.setPrice(entity.getPrice());
        dto.setRating(entity.getRating());
        dto.setMonthlySales(entity.getMonthlySales());
        dto.setIncreaseRate(BigDecimal.valueOf(0.15)); // Placeholder
        return dto;
    }

    private HomePageResDTO.PromotionDTO mapToPromotionDTO(PromotionEntity entity) {
        HomePageResDTO.PromotionDTO dto = new HomePageResDTO.PromotionDTO();
        dto.setId(String.valueOf(entity.getId()));
        dto.setTitle(entity.getTitle());
        dto.setSubtitle(entity.getSubtitle());
        dto.setImage(entity.getImageUrl());
        dto.setType(entity.getType());
        dto.setValue(entity.getValue());
        dto.setStartTime(entity.getStartTime());
        dto.setEndTime(entity.getEndTime());
        dto.setButtonText(entity.getButtonText());
        return dto;
    }

    private HomePageResDTO.NearbyStoreDTO mapToNearbyStoreDTO(StoreEntity entity, BigDecimal userLat, BigDecimal userLon, Long userId) {
        HomePageResDTO.NearbyStoreDTO dto = new HomePageResDTO.NearbyStoreDTO();
        dto.setId(String.valueOf(entity.getId()));
        dto.setName(entity.getName());
        dto.setAddress(entity.getAddress());
        // Calculate distance in meters
        double distance = GeoUtil.calculateDistance(
                userLat.doubleValue(), userLon.doubleValue(),
                entity.getLatitude().doubleValue(), entity.getLongitude().doubleValue()
        );
        dto.setDistance((int) Math.round(distance));
        dto.setBusinessHours(entity.getBusinessHours());
        dto.setStatus(entity.getStatus());
        dto.setPhone(entity.getPhone());
        // Services and Tags require mapping from related entities
        dto.setServices(entity.getServices().stream().map(StoreServiceEntity::getServiceType).collect(Collectors.toList()));
        dto.setTags(entity.getTags().stream().map(StoreTagEntity::getTagName).collect(Collectors.toList()));
        dto.setDeliveryFee(entity.getDeliveryFee());
        dto.setMinimumOrderAmount(entity.getMinimumOrderAmount());
        dto.setRating(entity.getRating());
        dto.setImages(entity.getImages().stream().map(StoreImageEntity::getImageUrl).collect(Collectors.toList()));
        dto.setCurrentWaitTime(entity.getCurrentWaitTime());
        // Set isFavorite if userId is provided
        dto.setIsFavorite(userId != null && userFavoriteStoreRepository.existsByUserIdAndStoreId(userId, entity.getId()));
        dto.setLongitude(entity.getLongitude()); // Added from StoreDetailResDTO
        dto.setLatitude(entity.getLatitude());   // Added from StoreDetailResDTO
        return dto;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\service\impl\MemberServiceImpl.java ---
// File: milktea-backend/src/main/java/com.milktea.app/service/impl/MemberServiceImpl.java
package com.milktea.app.service.impl;

import com.milktea.app.common.constant.ErrorCode;
import com.milktea.app.common.exception.BusinessException;
import com.milktea.app.dto.member.MemberInfoResDTO;
import com.milktea.app.entity.MemberLevelEntity;
import com.milktea.app.entity.UserEntity;
import com.milktea.app.repository.MemberLevelRepository;
import com.milktea.app.repository.UserRepository;
import com.milktea.app.service.MemberService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

@Service
@RequiredArgsConstructor
@Slf4j
public class MemberServiceImpl implements MemberService {

    private final UserRepository userRepository;
    private final MemberLevelRepository memberLevelRepository;
    private final ObjectMapper objectMapper; // To parse privileges_json

    @Override
    @Transactional(readOnly = true)
    public MemberInfoResDTO getMemberInfo(Long userId) {
        UserEntity user = userRepository.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_EXIST, "User not found."));

        MemberInfoResDTO resDTO = new MemberInfoResDTO();
        resDTO.setGrowthValue(user.getGrowthValue());

        // Current member level
        MemberLevelEntity currentLevel = user.getMemberLevel();
        if (currentLevel != null) {
            resDTO.setLevel(currentLevel.getName()); // Use name as code for now
            resDTO.setLevelName(currentLevel.getName());
            // Parse privileges
            if (currentLevel.getPrivilegesJson() != null) {
                try {
                    List<MemberInfoResDTO.PrivilegeDTO> privileges = objectMapper.readValue(
                            currentLevel.getPrivilegesJson(),
                            new TypeReference<List<MemberInfoResDTO.PrivilegeDTO>>() {}
                    );
                    resDTO.setPrivileges(privileges);
                } catch (Exception e) {
                    log.error("Failed to parse privileges JSON for level {}: {}", currentLevel.getId(), e.getMessage());
                    resDTO.setPrivileges(new ArrayList<>());
                }
            } else {
                resDTO.setPrivileges(new ArrayList<>());
            }
        } else {
            // Default to a basic/normal level if no level is assigned
            resDTO.setLevel("normal");
            resDTO.setLevelName("普通会员");
            resDTO.setPrivileges(new ArrayList<>());
        }

        // Next member level calculation
        Optional<MemberLevelEntity> nextLevelOptional = memberLevelRepository.findFirstByMinGrowthValueGreaterThanOrderByMinGrowthValueAsc(user.getGrowthValue());
        if (nextLevelOptional.isPresent()) {
            resDTO.setNextLevel(nextLevelOptional.get().getName());
            resDTO.setNextLevelName(nextLevelOptional.get().getName());
            resDTO.setNeedGrowthValue(nextLevelOptional.get().getMinGrowthValue() - user.getGrowthValue());
        } else {
            resDTO.setNextLevel(null);
            resDTO.setNextLevelName("已是最高等级");
            resDTO.setNeedGrowthValue(0);
        }

        // Member card expiration
        resDTO.setExpireDate(user.getMemberCardExpireDate());

        // Birthday gift (placeholder logic)
        // Check if current month is user's birthday month
        boolean isBirthdayMonth = user.getBirthday() != null && user.getBirthday().getMonth() == LocalDate.now().getMonth();
        MemberInfoResDTO.BirthdayGiftDTO birthdayGiftDTO = new MemberInfoResDTO.BirthdayGiftDTO();
        birthdayGiftDTO.setAvailable(isBirthdayMonth);
        if (isBirthdayMonth) {
            List<MemberInfoResDTO.GiftItemDTO> gifts = new ArrayList<>();
            gifts.add(new MemberInfoResDTO.GiftItemDTO("coupon", "生日专属优惠券", "免费饮品一杯"));
            birthdayGiftDTO.setGifts(gifts);
            birthdayGiftDTO.setExpireDate(LocalDate.now().plusMonths(1).withDayOfMonth(1).minusDays(1)); // Expires end of current month
        } else {
            birthdayGiftDTO.setGifts(new ArrayList<>());
            birthdayGiftDTO.setExpireDate(null);
        }
        resDTO.setBirthdayGift(birthdayGiftDTO);

        return resDTO;
    }

    @Override
    @Transactional
    public void receiveBirthdayGift(Long userId) {
        UserEntity user = userRepository.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_EXIST, "User not found."));

        // Placeholder for checking if user is eligible for birthday gift and has not received it yet
        boolean isBirthdayMonth = user.getBirthday() != null && user.getBirthday().getMonth() == LocalDate.now().getMonth();
        // Additional check: user should not have already received the gift for the current year.
        // This would require a "birthday_gift_received_year" field on UserEntity or similar.
        boolean alreadyReceivedThisYear = false; // Mocking false

        if (!isBirthdayMonth) {
            throw new BusinessException(ErrorCode.FORBIDDEN, "Not your birthday month.");
        }
        if (alreadyReceivedThisYear) {
            throw new BusinessException(ErrorCode.CONFLICT, "Birthday gift already received this year.");
        }

        // Logic to issue coupon or other gifts
        // Example: couponService.receiveBirthdayCoupon(userId, "birthday_coupon_template_id");
        log.info("User {} received birthday gift (mock).", userId);

        // Update user to mark birthday gift as received for this year
        // user.setLastBirthdayGiftReceivedYear(LocalDate.now().getYear());
        // userRepository.save(user);
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\service\impl\NotificationServiceImpl.java ---
// File: milktea-backend/src/main/java/com.milktea.app/service/impl/NotificationServiceImpl.java
package com.milktea.app.service.impl;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.milktea.app.common.constant.ErrorCode;
import com.milktea.app.common.exception.BusinessException;
import com.milktea.app.dto.notification.NotificationBatchReadReqDTO;
import com.milktea.app.dto.notification.NotificationListResDTO;
import com.milktea.app.entity.NotificationEntity;
import com.milktea.app.entity.UserEntity;
import com.milktea.app.repository.NotificationRepository;
import com.milktea.app.repository.UserRepository;
import com.milktea.app.service.NotificationService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.data.jpa.domain.Specification;
import jakarta.persistence.criteria.Predicate;

import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import com.fasterxml.jackson.core.type.TypeReference;

@Service
@RequiredArgsConstructor
@Slf4j
public class NotificationServiceImpl implements NotificationService {

    private final NotificationRepository notificationRepository;
    private final UserRepository userRepository;
    private final ObjectMapper objectMapper;

    @Override
    @Transactional(readOnly = true)
    public NotificationListResDTO getNotifications(Long userId, String type, Pageable pageable) {
        userRepository.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_EXIST, "User not found."));

        Specification<NotificationEntity> spec = (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();
            predicates.add(cb.equal(root.get("user").get("id"), userId));

            if (type != null && !type.equalsIgnoreCase("all")) {
                predicates.add(cb.equal(root.get("type"), type.toLowerCase()));
            }

            return cb.and(predicates.toArray(new Predicate[0]));
        };

        // Find all matching transactions for the user, then manually paginate
        // For a more efficient solution, repository method should return Page<PointTransactionEntity> directly with the spec.
        Page<NotificationEntity> notificationPage = notificationRepository.findAll(spec, pageable);


        List<NotificationListResDTO.NotificationDTO> notificationDTOs = notificationPage.getContent().stream()
                .map(this::mapToNotificationDTO)
                .collect(Collectors.toList());

        long unreadCount = notificationRepository.countByUserIdAndIsReadFalse(userId);

        NotificationListResDTO resDTO = new NotificationListResDTO();
        resDTO.setNotifications(notificationDTOs);
        resDTO.setUnreadCount((int) unreadCount);
        resDTO.setTotal((int) notificationPage.getTotalElements());
        resDTO.setPage(notificationPage.getNumber() + 1);
        resDTO.setLimit(pageable.getPageSize());
        return resDTO;
    }

    @Override
    @Transactional
    public void markNotificationAsRead(Long userId, Long notificationId) {
        NotificationEntity notification = notificationRepository.findById(notificationId)
                .orElseThrow(() -> new BusinessException(ErrorCode.NOT_FOUND, "Notification not found."));

        if (!notification.getUser().getId().equals(userId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN, "Access denied to notification.");
        }

        if (!notification.getIsRead()) {
            notification.setIsRead(true);
            notification.setReadAt(Instant.now());
            notificationRepository.save(notification);
            log.info("Notification {} marked as read for user {}", notificationId, userId);
        }
    }

    @Override
    @Transactional
    public void batchMarkNotificationsAsRead(Long userId, NotificationBatchReadReqDTO reqDTO) {
        List<NotificationEntity> notificationsToUpdate;
        if (reqDTO.getAll() != null && reqDTO.getAll()) {
            // Mark all unread notifications for the user as read
            notificationsToUpdate = notificationRepository.findByUserIdOrderByCreatedAtDesc(userId, Pageable.unpaged())
                    .stream()
                    .filter(n -> !n.getIsRead())
                    .collect(Collectors.toList());
        } else if (reqDTO.getIds() != null && !reqDTO.getIds().isEmpty()) {
            // Mark specific notifications as read
            notificationsToUpdate = notificationRepository.findAllById(reqDTO.getIds());
            notificationsToUpdate = notificationsToUpdate.stream()
                    .filter(n -> n.getUser().getId().equals(userId) && !n.getIsRead())
                    .collect(Collectors.toList());
        } else {
            throw new BusinessException(ErrorCode.INVALID_PARAM, "Either 'all' must be true or 'ids' must be provided for batch read.");
        }

        notificationsToUpdate.forEach(n -> {
            n.setIsRead(true);
            n.setReadAt(Instant.now());
        });
        notificationRepository.saveAll(notificationsToUpdate);
        log.info("{} notifications marked as read for user {}", notificationsToUpdate.size(), userId);
    }

    @Override
    @Transactional(readOnly = true)
    public Long getUnreadNotificationCount(Long userId) {
        userRepository.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_EXIST, "User not found."));
        return notificationRepository.countByUserIdAndIsReadFalse(userId);
    }

    private NotificationListResDTO.NotificationDTO mapToNotificationDTO(NotificationEntity entity) {
        NotificationListResDTO.NotificationDTO dto = new NotificationListResDTO.NotificationDTO();
        dto.setId(entity.getId());
        dto.setType(entity.getType());
        dto.setTitle(entity.getTitle());
        dto.setContent(entity.getContent());
        // Parse data_json to Map
        if (entity.getDataJson() != null) {
            try {
                dto.setData(objectMapper.readValue(entity.getDataJson(), new TypeReference<>() {}));
            } catch (Exception e) {
                log.error("Failed to parse data_json for notification {}: {}", entity.getId(), e.getMessage());
                dto.setData(null);
            }
        }
        dto.setIsRead(entity.getIsRead());
        dto.setCreatedAt(entity.getCreatedAt());
        dto.setReadAt(entity.getReadAt());
        return dto;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\service\impl\OrderServiceImpl.java ---
// File: milktea-backend/src/main/java/com.milktea.app/service/impl/OrderServiceImpl.java
package com.milktea.app.service.impl;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.milktea.app.common.constant.ErrorCode;
import com.milktea.app.common.enums.OrderStatus;
import com.milktea.app.common.enums.PayStatus;
import com.milktea.app.common.exception.BusinessException;
import com.milktea.app.common.util.DateUtil;
import com.milktea.app.common.util.GeoUtil;
import com.milktea.app.dto.coupon.CouponListResDTO;
import com.milktea.app.dto.home.HomePageResDTO;
import com.milktea.app.dto.order.*;
import com.milktea.app.dto.user.UserAddressResDTO;
import com.milktea.app.entity.*;
import com.milktea.app.repository.*;
import com.milktea.app.service.OrderService;
import com.milktea.app.controller.websocket.OrderWebSocketHandler;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.data.jpa.domain.Specification;
import jakarta.persistence.criteria.Predicate;

import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class OrderServiceImpl implements OrderService {

    private final OrderRepository orderRepository;
    private final OrderItemRepository orderItemRepository;
    private final OrderItemCustomizationRepository orderItemCustomizationRepository;
    private final OrderStatusTimelineRepository orderStatusTimelineRepository;
    private final PaymentRepository paymentRepository;
    private final OrderReviewRepository orderReviewRepository;
    private final OrderReviewImageRepository orderReviewImageRepository;
    private final OrderRefundRepository orderRefundRepository;
    private final OrderRefundImageRepository orderRefundImageRepository;
    private final UserRepository userRepository;
    private final CartItemRepository cartItemRepository;
    private final ProductRepository productRepository;
    private final UserAddressRepository userAddressRepository;
    private final StoreRepository storeRepository;
    private final UserCouponRepository userCouponRepository;
    private final CouponTemplateRepository couponTemplateRepository;
    private final ProductCustomizationTypeRepository customizationTypeRepository;
    private final ProductCustomizationOptionRepository customizationOptionRepository;
    private final ReviewTagRepository reviewTagRepository;
    private final OrderWebSocketHandler orderWebSocketHandler; // For WebSocket communication
    private final ObjectMapper objectMapper; // For JSON parsing
    private final PointTransactionRepository pointTransactionRepository; // Added for point transactions


    // Constants for order calculation/business logic
    private static final BigDecimal DEFAULT_PACKAGE_FEE = BigDecimal.valueOf(1.00);
    private static final BigDecimal DEFAULT_DELIVERY_FEE = BigDecimal.valueOf(3.00); // Base fee, overridden by store/config
    private static final int ORDER_PAYMENT_EXPIRATION_MINUTES = 15; // Payment expires in 15 minutes
    private static final int ORDER_CANCEL_DEADLINE_MINUTES = 10; // User can cancel within 10 minutes of creation
    private static final int ORDER_REFUND_DEADLINE_DAYS = 7; // User can apply for refund within 7 days of completion
    private static final int ORDER_RATE_DEADLINE_DAYS = 14; // User can rate within 14 days of completion

    @Override
    @Transactional(readOnly = true)
    public CheckoutResDTO getCheckoutDetails(Long userId, CheckoutReqDTO reqDTO) {
        UserEntity user = userRepository.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_EXIST, "User not found."));

        List<CartItemEntity> cartItems = cartItemRepository.findAllById(reqDTO.getItemIds());
        if (cartItems.isEmpty() || cartItems.stream().anyMatch(item -> !item.getUser().getId().equals(userId))) {
            throw new BusinessException(ErrorCode.CART_ITEM_NOT_FOUND, "Selected cart items not found or do not belong to user.");
        }

        // Validate cart items and get product info
        List<CheckoutResDTO.OrderItemSummaryDTO> orderItemSummaries = new ArrayList<>();
        BigDecimal productAmount = BigDecimal.ZERO;
        BigDecimal totalDiscount = BigDecimal.ZERO; // Discounts from promotions/etc., before coupon
        BigDecimal packageFee = DEFAULT_PACKAGE_FEE.multiply(BigDecimal.valueOf(cartItems.size())); // Simple package fee per item

        for (CartItemEntity cartItem : cartItems) {
            ProductEntity product = productRepository.findById(cartItem.getProduct().getId())
                    .orElseThrow(() -> new BusinessException(ErrorCode.PRODUCT_NOT_FOUND, "Product not found: " + cartItem.getProduct().getId()));

            if (!product.getIsActive()) {
                throw new BusinessException(ErrorCode.PRODUCT_OFFLINE, "Product " + product.getName() + " is offline.");
            }
            if (product.getStock() < cartItem.getQuantity()) {
                throw new BusinessException(ErrorCode.PRODUCT_STOCK_INSUFFICIENT, "Product " + product.getName() + " stock insufficient.");
            }

            BigDecimal itemBasePrice = product.getPrice();
            BigDecimal itemSubtotal = itemBasePrice.multiply(BigDecimal.valueOf(cartItem.getQuantity()));

            // Customization price adjustments
            CheckoutResDTO.CustomizationsDTO customizationsDTO = new CheckoutResDTO.CustomizationsDTO();
            List<String> toppingLabels = new ArrayList<>();

            for (CartItemCustomizationEntity customization : cartItem.getCustomizations()) {
                // This needs to be improved; direct value lookup is problematic for options if IDs aren't directly available in customization DTO.
                // For now, we'll try to find the option by value or fallback to price at add.
                BigDecimal adjustment = customizationOptionRepository.findByCustomizationType_TypeNameAndValue(
                                customization.getCustomizationTypeName(), customization.getOptionValue())
                        .map(ProductCustomizationOptionEntity::getPriceAdjustment)
                        .orElse(customization.getPriceAdjustmentAtAdd());

                itemSubtotal = itemSubtotal.add(adjustment.multiply(BigDecimal.valueOf(customization.getQuantity())));

                switch (customization.getCustomizationTypeName()) {
                    case "sweetness" -> customizationsDTO.setSweetness(customization.getOptionLabel());
                    case "temperature" -> customizationsDTO.setTemperature(customization.getOptionLabel());
                    case "toppings" -> {
                        for (int i = 0; i < customization.getQuantity(); i++) { // Add label multiple times if quantity > 1
                            toppingLabels.add(customization.getOptionLabel());
                        }
                    }
                }
            }
            customizationsDTO.setToppings(toppingLabels);

            orderItemSummaries.add(new CheckoutResDTO.OrderItemSummaryDTO(
                    product.getId(),
                    product.getName(),
                    product.getMainImageUrl(),
                    cartItem.getQuantity(),
                    product.getPrice(), // Price before customization adjustments
                    customizationsDTO,
                    itemSubtotal
            ));
            productAmount = productAmount.add(itemSubtotal);
        }

        // Address Information
        UserAddressResDTO.AddressDTO addressDTO = null;
        if (reqDTO.getAddressId() != null) {
            UserAddressEntity addressEntity = userAddressRepository.findById(reqDTO.getAddressId())
                    .orElseThrow(() -> new BusinessException(ErrorCode.ADDRESS_NOT_FOUND, "Delivery address not found."));
            addressDTO = mapToAddressDTO(addressEntity);
        } else {
            // Get default address if no specific address is provided
            Optional<UserAddressEntity> defaultAddress = userAddressRepository.findByUserIdAndIsDefaultTrue(userId);
            if (defaultAddress.isPresent()) {
                addressDTO = mapToAddressDTO(defaultAddress.get());
            }
        }

        // Store Information (assuming we pick a nearby store or a specific store)
        // For simplicity, let's just pick one "default" store or the closest if an address is provided
        StoreEntity store = null;
        HomePageResDTO.NearbyStoreDTO storeDTO = null;
        BigDecimal deliveryFee = BigDecimal.ZERO;

        if (addressDTO != null && addressDTO.getLatitude() != null && addressDTO.getLongitude() != null) {
            List<StoreEntity> nearbyStores = storeRepository.findNearbyStoresNative(
                    addressDTO.getLatitude(), addressDTO.getLongitude(), 5000.0, 1); // Get nearest store within 5km
            if (!nearbyStores.isEmpty()) {
                store = nearbyStores.get(0);
                storeDTO = mapToNearbyStoreDTO(store, addressDTO.getLatitude(), addressDTO.getLongitude(), userId);
                deliveryFee = store.getDeliveryFee();
            }
        }
        if (store == null) { // Fallback if no nearby store found or no address
            // Attempt to fetch the first active store as a fallback
            store = storeRepository.findByIsActiveTrue().stream().findFirst().orElse(null);
            if (store != null) {
                storeDTO = mapToNearbyStoreDTO(store, BigDecimal.ZERO, BigDecimal.ZERO, userId); // Dummy location for store
                deliveryFee = store.getDeliveryFee();
            } else {
                throw new BusinessException(ErrorCode.STORE_NOT_FOUND, "No active stores available.");
            }
        }


        // Coupon Information
        CouponListResDTO.CouponDTO selectedCouponDTO = null;
        if (reqDTO.getCouponId() != null) {
            UserCouponEntity userCoupon = userCouponRepository.findById(reqDTO.getCouponId())
                    .orElseThrow(() -> new BusinessException(ErrorCode.COUPON_NOT_FOUND, "Coupon not found."));
            if (!userCoupon.getUser().getId().equals(userId) || !"available".equals(userCoupon.getStatus()) || userCoupon.getExpireAt().isBefore(Instant.now())) {
                throw new BusinessException(ErrorCode.COUPON_NOT_APPLICABLE, "Selected coupon is not available or expired.");
            }
            selectedCouponDTO = mapToCouponDTO(userCoupon);

            // Apply coupon discount (simplified logic)
            BigDecimal discountValue = calculateCouponDiscount(userCoupon.getCouponTemplate(), productAmount);
            totalDiscount = totalDiscount.add(discountValue);
        }

        List<CouponListResDTO.CouponDTO> availableCoupons = userCouponRepository.findByUserIdAndStatusOrderByExpireAtAsc(userId, "available")
                .stream()
                .filter(uc -> uc.getExpireAt().isAfter(Instant.now())) // Only truly available
                .map(this::mapToCouponDTO)
                .collect(Collectors.toList());

        // Points and Balance
        Integer availablePoints = user.getPoints();
        BigDecimal balance = user.getBalance();
        Integer pointsRate = 100; // 100 points = 1 Yuan (example)

        // Summary calculation
        BigDecimal finalAmount = productAmount.add(packageFee).add(deliveryFee).subtract(totalDiscount);
        finalAmount = finalAmount.max(BigDecimal.ZERO); // Ensure final amount isn't negative

        CheckoutResDTO.OrderSummaryDTO summary = new CheckoutResDTO.OrderSummaryDTO(
                productAmount,
                deliveryFee,
                packageFee,
                totalDiscount,
                finalAmount,
                BigDecimal.ZERO, // Points discount, applied during order creation
                BigDecimal.ZERO  // Balance discount, applied during order creation
        );

        // Delivery Time (placeholder)
        CheckoutResDTO.DeliveryTimeDTO deliveryTime = new CheckoutResDTO.DeliveryTimeDTO(
                LocalDate.now(), "14:30-15:00", true
        );

        // Warnings (placeholder)
        List<CheckoutResDTO.WarningDTO> warnings = new ArrayList<>();
        // Example: if (store.isClosingSoon()) warnings.add(new CheckoutResDTO.WarningDTO("time_limit", "门店即将打烊,请尽快下单"));

        return new CheckoutResDTO(
                orderItemSummaries,
                addressDTO,
                availableCoupons,
                selectedCouponDTO,
                summary,
                availablePoints,
                pointsRate,
                balance,
                deliveryTime,
                storeDTO,
                store != null ? store.getMinimumOrderAmount() : BigDecimal.ZERO,
                reqDTO.getRemark(),
                warnings
        );
    }

    @Override
    @Transactional(readOnly = true)
    public OrderValidateResDTO validateOrder(Long userId, OrderValidateReqDTO reqDTO) {
        OrderValidateResDTO resDTO = new OrderValidateResDTO();
        resDTO.setIsValid(true);
        resDTO.setInvalidItems(new ArrayList<>());
        resDTO.setWarnings(new ArrayList<>());

        // Placeholder for full order validation logic
        // This should mirror the logic in getCheckoutDetails and createOrder,
        // but only return validation results without persisting anything.
        log.info("Performing mock order validation for user {}", userId);

        // Example validation: check item availability
        // If it's a buy-now scenario, itemIds would be product IDs.
        // If it's from cart, itemIds are cart item IDs.
        // The current validateOrder (and processOrderCreation) assumes itemIds are actually product IDs in OrderCreateReqDTO.
        // This is a discrepancy between the doc's BuyNowReqDTO (same as CreateOrderReqDTO) and CheckoutReqDTO.
        // For now, I'm adapting the logic to consider if it's from cart (`reqDTO.getItemIds` are CartItem IDs) or direct product.
        // Assuming `OrderValidateReqDTO`'s `itemIds` are conceptual product IDs in this context (e.g. from a cart preview).

        List<Long> productIdsToValidate = new ArrayList<>();
        if (reqDTO.getItemIds() != null && !reqDTO.getItemIds().isEmpty()) {
            for (Long itemId : reqDTO.getItemIds()) {
                Optional<CartItemEntity> cartItemOpt = cartItemRepository.findById(itemId);
                if (cartItemOpt.isEmpty() || !cartItemOpt.get().getUser().getId().equals(userId)) {
                    resDTO.getInvalidItems().add(new OrderValidateResDTO.InvalidItemDTO(itemId, "cart_item_not_found", "购物车商品不存在"));
                    resDTO.setIsValid(false);
                    continue;
                }
                productIdsToValidate.add(cartItemOpt.get().getProduct().getId());
            }
        }
        // If productIdsToValidate is still empty, and no items were explicitly passed, this might be a placeholder for "buy now"
        // or an empty cart scenario for validation. For simplicity, we'll assume itemIds refers to selected cart items for now.

        for (Long productId : productIdsToValidate) {
            ProductEntity product = productRepository.findById(productId).orElse(null);

            if (product == null || !product.getIsActive()) {
                resDTO.getInvalidItems().add(new OrderValidateResDTO.InvalidItemDTO(productId, "product_offline", "商品已下架"));
                resDTO.setIsValid(false);
            } else if (product.getStock() <= 0) { // Check if quantity exceeds stock. For simplicity, checking if stock is 0.
                resDTO.getInvalidItems().add(new OrderValidateResDTO.InvalidItemDTO(productId, "stock_out", "库存不足"));
                resDTO.setIsValid(false);
            }
            // Add more validation like price change, customization validity etc.
        }

        // Example warning: store status
        // Assume logic to find relevant store and check its status
        if (reqDTO.getStoreId() != null) {
            Optional<StoreEntity> storeOpt = storeRepository.findById(reqDTO.getStoreId());
            if (storeOpt.isPresent() && "closed".equals(storeOpt.get().getStatus())) {
                resDTO.getWarnings().add(new OrderValidateResDTO.WarningDTO("store_closed", "您选择的门店已打烊"));
                resDTO.setIsValid(false); // Make it invalid if store is closed
            }
        }


        // Re-calculate checkout details using the same logic as getCheckoutDetails
        // If there are discrepancies, mark as invalid or add warnings.
        // For this boilerplate, we skip full recalculation for brevity.

        if (!resDTO.getInvalidItems().isEmpty()) {
            resDTO.setIsValid(false);
        }

        return resDTO;
    }

    @Override
    @Transactional
    public OrderCreateResDTO createOrder(Long userId, OrderCreateReqDTO reqDTO) {
        // Delegate to a common order creation method
        return processOrderCreation(userId, reqDTO, false); // Not a buy-now scenario
    }

    @Override
    @Transactional
    public OrderCreateResDTO buyNow(Long userId, OrderCreateReqDTO reqDTO) {
        if (reqDTO.getItems() == null || reqDTO.getItems().size() != 1) {
            throw new BusinessException(ErrorCode.INVALID_PARAM, "Buy now only supports a single product.");
        }
        return processOrderCreation(userId, reqDTO, true); // Is a buy-now scenario
    }

    private OrderCreateResDTO processOrderCreation(Long userId, OrderCreateReqDTO reqDTO, boolean isBuyNow) {
        UserEntity user = userRepository.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_EXIST, "User not found."));

        // Step 1: Validate request and inventory again (critical for order creation)
        OrderValidateResDTO validationResult = validateOrder(userId, mapToOrderValidateReqDTO(reqDTO));
        if (!validationResult.getIsValid()) {
            throw new BusinessException(ErrorCode.CHECKOUT_VALIDATION_FAILED, "Order validation failed.", validationResult.getInvalidItems());
        }

        // Step 2: Create Order Entity
        OrderEntity order = new OrderEntity();
        order.setUser(user);
        order.setOrderNo(generateOrderNo()); // Generate unique order number
        order.setType(reqDTO.getType());
        order.setStatus(OrderStatus.CREATED.getCode());
        order.setStatusText(OrderStatus.CREATED.getDescription());
        order.setRemark(reqDTO.getRemark());
        order.setCreatedAt(Instant.now());
        order.setUpdatedAt(Instant.now());
        order.setIsRated(false);
        order.setPointsUsed(reqDTO.getPoints() != null ? reqDTO.getPoints() : 0);
        order.setBalanceUsed(reqDTO.getBalance() != null ? reqDTO.getBalance() : BigDecimal.ZERO);

        // Handle delivery/pickup specific details
        if ("delivery".equalsIgnoreCase(reqDTO.getType())) {
            UserAddressEntity address = userAddressRepository.findById(reqDTO.getAddressId())
                    .orElseThrow(() -> new BusinessException(ErrorCode.ADDRESS_NOT_FOUND, "Delivery address not found."));
            order.setDeliveryAddress(address);
            order.setDeliveryTimeExpected(reqDTO.getDeliveryTime());
        } else if ("pickup".equalsIgnoreCase(reqDTO.getType())) {
            StoreEntity store = storeRepository.findById(reqDTO.getStoreId())
                    .orElseThrow(() -> new BusinessException(ErrorCode.STORE_NOT_FOUND, "Pickup store not found."));
            order.setPickupStore(store);
            order.setEstimatedReadyTime(reqDTO.getDeliveryTime()); // Re-using deliveryTime for pickup estimated time
            order.setPickupCode(generatePickupCode()); // Generate unique pickup code
        } else {
            throw new BusinessException(ErrorCode.INVALID_PARAM, "Invalid order type.");
        }

        // Handle invoice
        if (reqDTO.getInvoice() != null) {
            order.setInvoiceType(reqDTO.getInvoice().getType());
            order.setInvoiceTitle(reqDTO.getInvoice().getTitle());
            order.setInvoiceTaxNumber(reqDTO.getInvoice().getTaxNumber());
        }

        BigDecimal productAmount = BigDecimal.ZERO;
        BigDecimal totalDiscount = BigDecimal.ZERO;
        BigDecimal packageFee = DEFAULT_PACKAGE_FEE.multiply(BigDecimal.valueOf(reqDTO.getItems().size())); // Simple package fee per item
        BigDecimal deliveryFee = BigDecimal.ZERO; // Will be set by store or config

        if (order.getDeliveryAddress() != null && order.getPickupStore() != null) { // If delivery type and store exists
            deliveryFee = order.getPickupStore().getDeliveryFee();
        } else if ("delivery".equalsIgnoreCase(reqDTO.getType())) {
            deliveryFee = DEFAULT_DELIVERY_FEE; // Fallback to default
        }

        // Step 3: Create Order Items and calculate amounts
        List<OrderItemEntity> orderItems = new ArrayList<>();
        for (OrderCreateReqDTO.OrderItemCreateDTO itemDTO : reqDTO.getItems()) {
            ProductEntity product = productRepository.findById(itemDTO.getProductId())
                    .orElseThrow(() -> new BusinessException(ErrorCode.PRODUCT_NOT_FOUND, "Product not found: " + itemDTO.getProductId()));

            // Decrease product stock (optimistic locking or more robust stock management needed for high concurrency)
            if (product.getStock() < itemDTO.getQuantity()) {
                throw new BusinessException(ErrorCode.PRODUCT_STOCK_INSUFFICIENT, "Product " + product.getName() + " stock insufficient.");
            }
            product.setStock(product.getStock() - itemDTO.getQuantity());
            productRepository.save(product); // Update stock

            BigDecimal itemBasePrice = product.getPrice();
            BigDecimal itemSubtotal = itemBasePrice.multiply(BigDecimal.valueOf(itemDTO.getQuantity()));

            OrderItemEntity orderItem = new OrderItemEntity();
            orderItem.setOrder(order);
            orderItem.setProduct(product);
            orderItem.setProductName(product.getName());
            orderItem.setProductImageUrl(product.getMainImageUrl());
            orderItem.setQuantity(itemDTO.getQuantity());
            orderItem.setPriceAtOrder(product.getPrice());
            orderItem.setOriginalPriceAtOrder(product.getOriginalPrice());
            orderItem.setCreatedAt(Instant.now());

            // Handle customizations
            List<OrderItemCustomizationEntity> itemCustomizations = new ArrayList<>();
            if (itemDTO.getCustomizations() != null) {
                Map<String, ProductCustomizationTypeEntity> productCustomizationTypes = customizationTypeRepository.findByProductIdAndIsEnabledTrueOrderBySortOrderAsc(product.getId())
                        .stream()
                        .collect(Collectors.toMap(ProductCustomizationTypeEntity::getTypeName, type -> type));

                if (itemDTO.getCustomizations().getSweetness() != null) {
                    ProductCustomizationTypeEntity type = productCustomizationTypes.get("sweetness");
                    ProductCustomizationOptionEntity option = type.getOptions().stream()
                            .filter(o -> o.getValue().equals(itemDTO.getCustomizations().getSweetness()))
                            .findFirst().orElse(null);
                    if (option != null) {
                        itemSubtotal = itemSubtotal.add(option.getPriceAdjustment());
                        itemCustomizations.add(createOrderItemCustomization(orderItem, type, option, 1));
                    }
                }
                if (itemDTO.getCustomizations().getTemperature() != null) {
                    ProductCustomizationTypeEntity type = productCustomizationTypes.get("temperature");
                    ProductCustomizationOptionEntity option = type.getOptions().stream()
                            .filter(o -> o.getValue().equals(itemDTO.getCustomizations().getTemperature()))
                            .findFirst().orElse(null);
                    if (option != null) {
                        itemSubtotal = itemSubtotal.add(option.getPriceAdjustment());
                        itemCustomizations.add(createOrderItemCustomization(orderItem, type, option, 1));
                    }
                }
                if (itemDTO.getCustomizations().getToppings() != null) {
                    ProductCustomizationTypeEntity type = productCustomizationTypes.get("toppings");
                    Map<String, ProductCustomizationOptionEntity> toppingOptions = type.getOptions().stream()
                            .collect(Collectors.toMap(ProductCustomizationOptionEntity::getValue, o -> o));
                    for (OrderCreateReqDTO.ToppingItem toppingItem : itemDTO.getCustomizations().getToppings()) {
                        ProductCustomizationOptionEntity option = toppingOptions.get(toppingItem.getId());
                        if (option == null) {
                            throw new BusinessException(ErrorCode.INVALID_PARAM, "Invalid topping option: " + toppingItem.getId());
                        }
                        if (option.getStock() != null && option.getStock() < toppingItem.getQuantity()) {
                            throw new BusinessException(ErrorCode.PRODUCT_STOCK_INSUFFICIENT, "Topping " + option.getLabel() + " stock insufficient.");
                        }
                        itemSubtotal = itemSubtotal.add(option.getPriceAdjustment().multiply(BigDecimal.valueOf(toppingItem.getQuantity())));
                        itemCustomizations.add(createOrderItemCustomization(orderItem, type, option, toppingItem.getQuantity()));
                        // Also decrease topping stock if applicable
                        if (option.getStock() != null) {
                            option.setStock(option.getStock() - toppingItem.getQuantity());
                            customizationOptionRepository.save(option);
                        }
                    }
                }
            }
            orderItem.setSubtotal(itemSubtotal);
            orderItem.setCustomizations(itemCustomizations);
            orderItems.add(orderItem);
            productAmount = productAmount.add(itemSubtotal);
        }
        order.setItems(orderItems);
        order.setProductAmount(productAmount);
        order.setPackageFee(packageFee);
        order.setDeliveryFee(deliveryFee);

        // Apply coupon discount if any
        if (reqDTO.getCouponId() != null) {
            UserCouponEntity userCoupon = userCouponRepository.findById(reqDTO.getCouponId())
                    .orElseThrow(() -> new BusinessException(ErrorCode.COUPON_NOT_FOUND, "Coupon not found."));
            if (!userCoupon.getUser().getId().equals(userId) || !"available".equals(userCoupon.getStatus()) || userCoupon.getExpireAt().isBefore(Instant.now())) {
                throw new BusinessException(ErrorCode.COUPON_NOT_APPLICABLE, "Selected coupon is not available or expired.");
            }
            // Use coupon (mark as used, update discount amount)
            BigDecimal discountValue = calculateCouponDiscount(userCoupon.getCouponTemplate(), productAmount);
            order.setDiscountAmount(order.getDiscountAmount().add(discountValue));
            order.setCouponId(userCoupon.getId());
            userCoupon.setStatus("used");
            userCoupon.setUsedAt(Instant.now());
            // userCoupon.setOrderId(order.getId()); // Set order ID after order is saved to avoid transient issues if FK constraint exists
            userCouponRepository.save(userCoupon);
        }

        // Apply points discount
        BigDecimal pointsDiscountAmount = BigDecimal.ZERO;
        if (reqDTO.getPoints() != null && reqDTO.getPoints() > 0) {
            if (user.getPoints() < reqDTO.getPoints()) {
                throw new BusinessException(ErrorCode.INSUFFICIENT_POINTS, "Insufficient points.");
            }
            // Assume 100 points = 1 unit of currency for now
            pointsDiscountAmount = BigDecimal.valueOf(reqDTO.getPoints()).divide(BigDecimal.valueOf(100), 2, BigDecimal.ROUND_HALF_UP);
            order.setPointsDiscountAmount(pointsDiscountAmount);
            // Deduct points from user
            user.setPoints(user.getPoints() - reqDTO.getPoints());
            // Record point transaction (earn, use)
            PointTransactionEntity pointTransaction = new PointTransactionEntity();
            pointTransaction.setUser(user);
            pointTransaction.setPointsChange(-reqDTO.getPoints());
            pointTransaction.setBalanceAfterTransaction(user.getPoints());
            pointTransaction.setType("use");
            pointTransaction.setDescription("使用积分抵扣订单");
            pointTransaction.setRelatedType("order");
            pointTransaction.setRelatedId(order.getOrderNo());
            pointTransaction.setCreatedAt(Instant.now());
            pointTransactionRepository.save(pointTransaction);
        }

        // Apply balance discount
        BigDecimal balanceDiscountAmount = BigDecimal.ZERO;
        if (reqDTO.getBalance() != null && reqDTO.getBalance().compareTo(BigDecimal.ZERO) > 0) {
            if (user.getBalance().compareTo(reqDTO.getBalance()) < 0) {
                throw new BusinessException(ErrorCode.INSUFFICIENT_POINTS, "Insufficient balance."); // Reusing error code
            }
            balanceDiscountAmount = reqDTO.getBalance();
            order.setBalanceDiscountAmount(balanceDiscountAmount);
            // Deduct balance from user
            user.setBalance(user.getBalance().subtract(reqDTO.getBalance()));
            // Record balance transaction (omitted for brevity)
        }
        userRepository.save(user); // Save user with updated points/balance

        // Calculate final order amounts
        BigDecimal totalAmountBeforePayment = productAmount.add(packageFee).add(deliveryFee)
                .subtract(order.getDiscountAmount())
                .subtract(order.getPointsDiscountAmount())
                .subtract(order.getBalanceDiscountAmount());

        order.setPayAmount(totalAmountBeforePayment.max(BigDecimal.ZERO)); // Amount actually needs to be paid
        order.setTotalAmount(totalAmountBeforePayment.max(BigDecimal.ZERO)); // Final total amount, after all discounts

        OrderEntity savedOrder = orderRepository.save(order);

        // Set coupon's order_id after order is saved
        if (reqDTO.getCouponId() != null) {
            UserCouponEntity userCoupon = userCouponRepository.findById(reqDTO.getCouponId())
                    .orElse(null); // Should not be null due to earlier check
            if (userCoupon != null) {
                userCoupon.setOrderId(savedOrder.getId());
                userCouponRepository.save(userCoupon);
            }
        }

        // Save order items and their customizations
        for (OrderItemEntity orderItem : orderItems) {
            orderItem.setOrder(savedOrder); // Set the saved order object
            OrderItemEntity savedOrderItem = orderItemRepository.save(orderItem);
            orderItem.getCustomizations().forEach(cust -> cust.setOrderItem(savedOrderItem));
            orderItemCustomizationRepository.saveAll(orderItem.getCustomizations());
        }

        // Add initial order status timeline entry
        addOrderStatusTimeline(savedOrder, OrderStatus.CREATED, true);

        // Set deadlines
        savedOrder.setCancelDeadline(Instant.now().plusSeconds(ORDER_CANCEL_DEADLINE_MINUTES * 60L));
        orderRepository.save(savedOrder);

        // Step 4: Initiate Payment if needed
        boolean needPay = savedOrder.getPayAmount().compareTo(BigDecimal.ZERO) > 0;
        OrderCreateResDTO.PayInfoDTO payInfo = null;
        if (needPay) {
            // Placeholder for payment gateway interaction
            // This would typically involve calling an external payment SDK
            log.info("Initiating payment for order {}", savedOrder.getOrderNo());
            // Mock payment info
            payInfo = new OrderCreateResDTO.PayInfoDTO(
                    "MOCK_PAY_" + UUID.randomUUID().toString(),
                    "wechat", // Default mock pay type
                    savedOrder.getPayAmount(),
                    Instant.now().plusSeconds(ORDER_PAYMENT_EXPIRATION_MINUTES * 60L)
            );
            // Create a payment entity in 'unpaid' state
            PaymentEntity payment = new PaymentEntity();
            payment.setOrder(savedOrder);
            payment.setPayId(payInfo.getPayId());
            payment.setPayType(payInfo.getPayType());
            payment.setPayAmount(payInfo.getPayAmount());
            payment.setPayStatus(PayStatus.UNPAID.getCode());
            payment.setExpireTime(payInfo.getExpireTime());
            payment.setIsSandbox(true); // For testing
            payment.setCreatedAt(Instant.now());
            payment.setUpdatedAt(Instant.now());
            paymentRepository.save(payment);
        }

        // Step 5: Clear cart items that were part of this order, if not a "buy now"
        if (!isBuyNow) {
            // Needs explicit cart item IDs from reqDTO to clear. This is a simplification.
            // In a full cart checkout flow, reqDTO would contain a list of cart item IDs to be cleared.
            log.warn("Cart clearing logic is simplified. Needs actual cart item IDs for clearance.");
        }


        // Step 6: Publish WebSocket message for order creation
        // This is a placeholder for sending initial status to the user
        publishOrderStatusUpdate(savedOrder.getId(), savedOrder.getStatus(), savedOrder.getStatusText(), savedOrder.getEstimatedReadyTime());

        return new OrderCreateResDTO(
                savedOrder.getId(),
                savedOrder.getOrderNo(),
                savedOrder.getTotalAmount(),
                savedOrder.getPayAmount(),
                savedOrder.getPointsUsed(),
                savedOrder.getBalanceUsed(),
                order.getDiscountAmount(),
                needPay,
                payInfo
        );
    }

    @Override
    @Transactional
    public PaymentResDTO initiatePayment(Long userId, Long orderId, PaymentReqDTO reqDTO) {
        OrderEntity order = orderRepository.findById(orderId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ORDER_NOT_FOUND, "Order not found."));

        if (!order.getUser().getId().equals(userId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN, "Access denied to order.");
        }
        if (!OrderStatus.CREATED.getCode().equals(order.getStatus()) && !PayStatus.UNPAID.getCode().equals(order.getStatus())) {
            throw new BusinessException(ErrorCode.ORDER_STATUS_INVALID, "Order is not in a payable state.");
        }

        // Check if there's an existing unpaid payment or create a new one
        Optional<PaymentEntity> existingPaymentOptional = paymentRepository.findByOrderId(orderId);
        PaymentEntity payment;

        if (existingPaymentOptional.isPresent() && PayStatus.UNPAID.getCode().equals(existingPaymentOptional.get().getPayStatus()) && existingPaymentOptional.get().getExpireTime().isAfter(Instant.now())) {
            payment = existingPaymentOptional.get();
        } else {
            // Create a new payment record, or update if expired
            payment = existingPaymentOptional.orElseGet(PaymentEntity::new);
            payment.setOrder(order);
            payment.setPayId("MOCK_PAY_" + UUID.randomUUID().toString()); // New payment ID
            payment.setPayAmount(order.getPayAmount());
            payment.setPayStatus(PayStatus.UNPAID.getCode());
            payment.setExpireTime(Instant.now().plusSeconds(ORDER_PAYMENT_EXPIRATION_MINUTES * 60L));
            payment.setCreatedAt(Instant.now());
            // Update the existing payment if found, otherwise it's a new one.
        }

        payment.setPayType(reqDTO.getPayType());
        payment.setChannel(reqDTO.getChannel());
        payment.setUpdatedAt(Instant.now());
        payment = paymentRepository.save(payment);

        // Placeholder for real payment gateway integration
        Map<String, String> payParams = new HashMap<>();
        payParams.put("tradeNO", payment.getPayId());
        payParams.put("totalAmount", payment.getPayAmount().toPlainString());
        payParams.put("subject", "奶茶小屋订单: " + order.getOrderNo());
        payParams.put("body", "商品详情...");
        payParams.put("timeoutExpress", ORDER_PAYMENT_EXPIRATION_MINUTES + "m");

        String paymentUrl = null;
        if ("h5".equals(reqDTO.getChannel())) {
            paymentUrl = "https://mock-payment-gateway.com/pay?id=" + payment.getPayId(); // Placeholder H5 URL
        }

        return new PaymentResDTO(
                payment.getPayId(),
                order.getOrderNo(),
                payment.getPayAmount(),
                payment.getPayType(),
                payParams,
                true, // Mocking sandbox mode for Alipay
                paymentUrl
        );
    }

    @Override
    @Transactional(readOnly = true)
    public PaymentStatusResDTO getPaymentStatus(Long userId, Long orderId) {
        OrderEntity order = orderRepository.findById(orderId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ORDER_NOT_FOUND, "Order not found."));

        if (!order.getUser().getId().equals(userId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN, "Access denied to order.");
        }

        PaymentEntity payment = paymentRepository.findByOrderId(orderId)
                .orElseThrow(() -> new BusinessException(ErrorCode.NOT_FOUND, "Payment record not found for this order."));

        // In a real system, you would query the payment gateway for the latest status
        // For now, we rely on our DB status, which should be updated by a webhook from the payment gateway.
        return new PaymentStatusResDTO(
                order.getId(),
                payment.getPayStatus(),
                payment.getPayTime(),
                payment.getPayAmount(),
                payment.getTransactionId()
        );
    }

    @Override
    @Transactional
    public void cancelPayment(Long userId, Long orderId) {
        OrderEntity order = orderRepository.findById(orderId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ORDER_NOT_FOUND, "Order not found."));

        if (!order.getUser().getId().equals(userId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN, "Access denied to order.");
        }

        PaymentEntity payment = paymentRepository.findByOrderId(orderId)
                .orElseThrow(() -> new BusinessException(ErrorCode.NOT_FOUND, "Payment record not found for this order."));

        if (!PayStatus.UNPAID.getCode().equals(payment.getPayStatus())) {
            throw new BusinessException(ErrorCode.ORDER_STATUS_INVALID, "Payment is not in an unpaid state and cannot be cancelled.");
        }

        // Placeholder for calling payment gateway to cancel pending payment
        log.info("Cancelling pending payment {} for order {}", payment.getPayId(), order.getOrderNo());

        payment.setPayStatus(PayStatus.CANCELLED.getCode());
        payment.setUpdatedAt(Instant.now());
        paymentRepository.save(payment);

        // Optionally, update order status as well if payment cancellation implies order cancellation
        // order.setStatus(OrderStatus.CANCELLED.getCode());
        // order.setStatusText(OrderStatus.CANCELLED.getDescription());
        // orderRepository.save(order);
        // addOrderStatusTimeline(order, OrderStatus.CANCELLED, true);

        log.info("Payment {} for order {} has been cancelled.", payment.getPayId(), order.getOrderNo());
    }


    @Override
    @Transactional(readOnly = true)
    public OrderListResDTO getUserOrders(Long userId, String status, String type, Instant startDate, Instant endDate, Pageable pageable) {
        userRepository.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_EXIST, "User not found."));

        Specification<OrderEntity> spec = (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();
            predicates.add(cb.equal(root.get("user").get("id"), userId));

            if (status != null && !status.equalsIgnoreCase("all")) {
                predicates.add(cb.equal(root.get("status"), status.toLowerCase()));
            }
            if (type != null && !type.equalsIgnoreCase("all")) {
                predicates.add(cb.equal(root.get("type"), type.toLowerCase()));
            }
            if (startDate != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("createdAt"), startDate));
            }
            if (endDate != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("createdAt"), endDate));
            }

            return cb.and(predicates.toArray(new Predicate[0]));
        };

        Page<OrderEntity> orderPage = orderRepository.findAll(spec, pageable);

        List<OrderListResDTO.OrderSummaryDTO> orderSummaryDTOs = orderPage.getContent().stream()
                .map(this::mapToOrderSummaryDTO)
                .collect(Collectors.toList());

        // Order statistics
        OrderListResDTO.OrderStatsDTO stats = new OrderListResDTO.OrderStatsDTO();
        stats.setAll((int) orderRepository.countByUserId(userId)); // Needs custom count method without status filter
        stats.setPending((int) orderRepository.countByUserIdAndStatus(userId, OrderStatus.CREATED.getCode()));
        stats.setPaid((int) orderRepository.countByUserIdAndStatus(userId, OrderStatus.PAID.getCode()));
        stats.setMaking((int) orderRepository.countByUserIdAndStatus(userId, OrderStatus.MAKING.getCode()));
        stats.setReady((int) orderRepository.countByUserIdAndStatus(userId, OrderStatus.READY.getCode()));
        stats.setCompleted((int) orderRepository.countByUserIdAndStatus(userId, OrderStatus.COMPLETED.getCode()));
        stats.setCancelled((int) orderRepository.countByUserIdAndStatus(userId, OrderStatus.CANCELLED.getCode()));


        OrderListResDTO resDTO = new OrderListResDTO();
        resDTO.setOrders(orderSummaryDTOs);
        resDTO.setTotal((int) orderPage.getTotalElements());
        resDTO.setPage(pageable.getPageNumber() + 1);
        resDTO.setLimit(pageable.getPageSize());
        resDTO.setStats(stats);
        return resDTO;
    }

    @Override
    @Transactional(readOnly = true)
    public OrderDetailResDTO getOrderDetail(Long userId, Long orderId) {
        OrderEntity order = orderRepository.findById(orderId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ORDER_NOT_FOUND, "Order not found."));

        if (!order.getUser().getId().equals(userId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN, "Access denied to order.");
        }

        return mapToOrderDetailResDTO(order);
    }

    @Override
    @Transactional
    public void cancelOrder(Long userId, Long orderId, OrderCancelReqDTO reqDTO) {
        OrderEntity order = orderRepository.findById(orderId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ORDER_NOT_FOUND, "Order not found."));

        if (!order.getUser().getId().equals(userId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN, "Access denied to order.");
        }

        // Only allow cancellation if order is in CREATED or PAID status and within deadline
        if (!OrderStatus.CREATED.getCode().equals(order.getStatus()) && !OrderStatus.PAID.getCode().equals(order.getStatus())) {
            throw new BusinessException(ErrorCode.ORDER_CANNOT_CANCEL, "Order cannot be cancelled in its current state.");
        }
        if (order.getCancelDeadline() != null && Instant.now().isAfter(order.getCancelDeadline())) {
            throw new BusinessException(ErrorCode.ORDER_CANNOT_CANCEL, "Cancellation deadline has passed.");
        }

        // Process refund if order was paid
        if (OrderStatus.PAID.getCode().equals(order.getStatus())) {
            // Placeholder for calling payment gateway for refund
            log.info("Initiating refund for cancelled order {} for amount {}", order.getOrderNo(), order.getPayAmount());
            // Update payment status (mock)
            PaymentEntity payment = paymentRepository.findByOrderId(order.getId())
                    .orElseThrow(() -> new BusinessException(ErrorCode.SYSTEM_ERROR, "Payment record not found for paid order."));
            payment.setPayStatus(PayStatus.CANCELLED.getCode()); // Or refunded depending on actual system
            paymentRepository.save(payment);
            // Revert points/balance if used
            if (order.getPointsUsed() > 0) {
                UserEntity user = order.getUser();
                user.setPoints(user.getPoints() + order.getPointsUsed());
                userRepository.save(user);
                // Log point transaction (refund)
                PointTransactionEntity pointTransaction = new PointTransactionEntity();
                pointTransaction.setUser(user);
                pointTransaction.setPointsChange(order.getPointsUsed());
                pointTransaction.setBalanceAfterTransaction(user.getPoints());
                pointTransaction.setType("earn");
                pointTransaction.setDescription("取消订单返还积分");
                pointTransaction.setRelatedType("order");
                pointTransaction.setRelatedId(order.getOrderNo());
                pointTransaction.setCreatedAt(Instant.now());
                pointTransactionRepository.save(pointTransaction);
            }
            if (order.getBalanceUsed().compareTo(BigDecimal.ZERO) > 0) {
                UserEntity user = order.getUser();
                user.setBalance(user.getBalance().add(order.getBalanceUsed()));
                userRepository.save(user);
            }
            // Revert coupon if used
            if (order.getCouponId() != null) {
                UserCouponEntity userCoupon = userCouponRepository.findById(order.getCouponId()).orElse(null);
                if (userCoupon != null) {
                    userCoupon.setStatus("available"); // Make coupon available again
                    userCoupon.setUsedAt(null);
                    userCoupon.setOrderId(null);
                    userCouponRepository.save(userCoupon);
                }
            }
        }

        // Revert product stock
        for (OrderItemEntity item : order.getItems()) {
            ProductEntity product = item.getProduct();
            product.setStock(product.getStock() + item.getQuantity());
            productRepository.save(product);
            // Revert topping stock if applicable
            for (OrderItemCustomizationEntity customization : item.getCustomizations()) {
                if ("toppings".equalsIgnoreCase(customization.getCustomizationTypeName())) {
                    // Need to find the correct ProductCustomizationTypeEntity and then the option
                    Optional<ProductCustomizationTypeEntity> typeOpt = customizationTypeRepository.findByTypeNameAndProductId(customization.getCustomizationTypeName(), product.getId());
                    typeOpt.ifPresent(typeEntity -> {
                        Optional<ProductCustomizationOptionEntity> optionOpt = typeEntity.getOptions().stream()
                                .filter(o -> o.getValue().equals(customization.getOptionValue()))
                                .findFirst();
                        optionOpt.ifPresent(option -> {
                            if (option.getStock() != null) {
                                option.setStock(option.getStock() + customization.getQuantity());
                                customizationOptionRepository.save(option);
                            }
                        });
                    });
                }
            }
        }

        order.setStatus(OrderStatus.CANCELLED.getCode());
        order.setStatusText(OrderStatus.CANCELLED.getDescription());
        orderRepository.save(order);
        addOrderStatusTimeline(order, OrderStatus.CANCELLED, true);

        // Publish WebSocket message
        publishOrderStatusUpdate(order.getId(), order.getStatus(), order.getStatusText(), null);
    }

    @Override
    @Transactional
    public void confirmOrder(Long userId, Long orderId) {
        OrderEntity order = orderRepository.findById(orderId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ORDER_NOT_FOUND, "Order not found."));

        if (!order.getUser().getId().equals(userId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN, "Access denied to order.");
        }

        // Only allow confirmation if order is in READY or DELIVERING status
        if (!OrderStatus.READY.getCode().equals(order.getStatus()) && !OrderStatus.DELIVERING.getCode().equals(order.getStatus())) {
            throw new BusinessException(ErrorCode.ORDER_STATUS_INVALID, "Order cannot be confirmed in its current state.");
        }

        order.setStatus(OrderStatus.COMPLETED.getCode());
        order.setStatusText(OrderStatus.COMPLETED.getDescription());
        order.setPickupTimeActual(Instant.now()); // If pickup
        orderRepository.save(order);
        addOrderStatusTimeline(order, OrderStatus.COMPLETED, true);

        // Set refund and rate deadlines
        order.setRefundDeadline(Instant.now().plusSeconds(ORDER_REFUND_DEADLINE_DAYS * 24 * 60 * 60L));
        order.setRateDeadline(Instant.now().plusSeconds(ORDER_RATE_DEADLINE_DAYS * 24 * 60 * 60L));
        orderRepository.save(order);

        // Publish WebSocket message
        publishOrderStatusUpdate(order.getId(), order.getStatus(), order.getStatusText(), null);

        // Optionally, give points for completed order
        UserEntity user = order.getUser();
        int pointsEarned = order.getTotalAmount().multiply(BigDecimal.TEN).intValue(); // Example: 10 points per 1 unit of currency
        user.setPoints(user.getPoints() + pointsEarned);
        userRepository.save(user);
        // Log point transaction
        PointTransactionEntity pointTransaction = new PointTransactionEntity();
        pointTransaction.setUser(user);
        pointTransaction.setPointsChange(pointsEarned);
        pointTransaction.setBalanceAfterTransaction(user.getPoints());
        pointTransaction.setType("earn");
        pointTransaction.setDescription("完成订单获得积分");
        pointTransaction.setRelatedType("order");
        pointTransaction.setRelatedId(order.getOrderNo());
        pointTransaction.setCreatedAt(Instant.now());
        pointTransactionRepository.save(pointTransaction);
    }

    @Override
    @Transactional
    public void remindOrder(Long userId, Long orderId) {
        OrderEntity order = orderRepository.findById(orderId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ORDER_NOT_FOUND, "Order not found."));

        if (!order.getUser().getId().equals(userId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN, "Access denied to order.");
        }

        // Only allow reminding if order is in PAID or MAKING status
        if (!OrderStatus.PAID.getCode().equals(order.getStatus()) && !OrderStatus.MAKING.getCode().equals(order.getStatus())) {
            throw new BusinessException(ErrorCode.ORDER_STATUS_INVALID, "Order cannot be reminded in its current state.");
        }

        // Placeholder for sending a notification to the store/kitchen staff
        log.info("User {} reminded for order {}. Current status: {}", userId, orderId, order.getStatus());
        // Example: notificationService.sendToStore(order.getPickupStore().getId(), "Order " + order.getOrderNo() + " is being reminded by customer.");
    }


    @Override
    @Transactional
    public void applyOrderRefund(Long userId, Long orderId, OrderRefundApplyReqDTO reqDTO) {
        OrderEntity order = orderRepository.findById(orderId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ORDER_NOT_FOUND, "Order not found."));

        if (!order.getUser().getId().equals(userId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN, "Access denied to order.");
        }

        // Only allow refund if order is completed and within deadline
        if (!OrderStatus.COMPLETED.getCode().equals(order.getStatus())) {
            throw new BusinessException(ErrorCode.ORDER_CANNOT_REFUND, "Refund can only be applied for completed orders.");
        }
        if (order.getRefundDeadline() != null && Instant.now().isAfter(order.getRefundDeadline())) {
            throw new BusinessException(ErrorCode.ORDER_CANNOT_REFUND, "Refund deadline has passed.");
        }
        if ("refunded".equals(order.getStatus())) {
            throw new BusinessException(ErrorCode.ORDER_CANNOT_REFUND, "Order has already been refunded.");
        }

        OrderRefundEntity refund = new OrderRefundEntity();
        refund.setOrder(order);
        refund.setUser(order.getUser());
        refund.setReason(reqDTO.getReason());
        refund.setDescription(reqDTO.getDescription());
        refund.setStatus("pending"); // Initial status
        refund.setRefundAmount(order.getPayAmount()); // Full refund amount for now, could be partial
        refund.setCreatedAt(Instant.now());
        refund.setUpdatedAt(Instant.now());
        refund = orderRefundRepository.save(refund);

        // Save refund images
        if (reqDTO.getImages() != null && !reqDTO.getImages().isEmpty()) {
            for (String imageUrl : reqDTO.getImages()) {
                OrderRefundImageEntity refundImage = new OrderRefundImageEntity();
                refundImage.setRefund(refund);
                refundImage.setImageUrl(imageUrl);
                refundImage.setCreatedAt(Instant.now());
                orderRefundImageRepository.save(refundImage);
            }
        }

        // Update order status to indicate refund is pending
        order.setStatus("refund_pending"); // Custom status for pending refund
        order.setStatusText("退款申请中");
        orderRepository.save(order);
        addOrderStatusTimeline(order, OrderStatus.REFUNDED, false); // Mark as false for pending.

        // Publish WebSocket message (e.g., to admin or user)
        publishOrderStatusUpdate(order.getId(), "refund_pending", "退款申请中", null);
    }

    @Override
    @Transactional
    public void addOrderReview(Long userId, Long orderId, OrderReviewReqDTO reqDTO) {
        OrderEntity order = orderRepository.findById(orderId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ORDER_NOT_FOUND, "Order not found."));

        if (!order.getUser().getId().equals(userId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN, "Access denied to order.");
        }
        if (!OrderStatus.COMPLETED.getCode().equals(order.getStatus())) {
            throw new BusinessException(ErrorCode.ORDER_STATUS_INVALID, "Only completed orders can be reviewed.");
        }
        if (order.getIsRated()) {
            throw new BusinessException(ErrorCode.CONFLICT, "Order has already been rated.");
        }
        if (order.getRateDeadline() != null && Instant.now().isAfter(order.getRateDeadline())) {
            throw new BusinessException(ErrorCode.FORBIDDEN, "Review deadline has passed.");
        }

        OrderReviewEntity review = new OrderReviewEntity();
        review.setOrder(order);
        review.setUser(order.getUser());
        review.setRating(reqDTO.getRating().shortValue());
        review.setContent(reqDTO.getContent());
        review.setIsAnonymous(reqDTO.getAnonymous() != null ? reqDTO.getAnonymous() : false);
        review.setCreatedAt(Instant.now());
        review.setUpdatedAt(Instant.now());
        review = orderReviewRepository.save(review);

        // Save review images
        if (reqDTO.getImages() != null && !reqDTO.getImages().isEmpty()) {
            for (String imageUrl : reqDTO.getImages()) {
                OrderReviewImageEntity reviewImage = new OrderReviewImageEntity();
                reviewImage.setReview(review);
                reviewImage.setImageUrl(imageUrl);
                reviewImage.setCreatedAt(Instant.now());
                orderReviewImageRepository.save(reviewImage);
            }
        }

        // Link review tags
        if (reqDTO.getTags() != null && !reqDTO.getTags().isEmpty()) {
            List<ReviewTagEntity> tags = reqDTO.getTags().stream()
                    .map(tagName -> {
                        // Find or create tag
                        Optional<ReviewTagEntity> existingTag = reviewTagRepository.findByName(tagName);
                        return existingTag.orElseGet(() -> {
                            ReviewTagEntity newTag = new ReviewTagEntity();
                            newTag.setName(tagName);
                            return reviewTagRepository.save(newTag);
                        });
                    })
                    .collect(Collectors.toList());
            review.setTags(tags);
            orderReviewRepository.save(review);
        }

        // Update order status to rated
        order.setIsRated(true);
        orderRepository.save(order);

        // Update product rating (simple average, could be more complex)
        // Assuming one product for simplicity or averaging across all products in order
        if (order.getItems() != null && !order.getItems().isEmpty()) {
            for (OrderItemEntity orderItem : order.getItems()) {
                ProductEntity product = orderItem.getProduct();
                product.setRatingCount(product.getRatingCount() + 1);
                // Avoid division by zero if ratingCount becomes 0 for some reason
                BigDecimal newTotalRatingSum = product.getRating().multiply(BigDecimal.valueOf(product.getRatingCount() - 1))
                        .add(BigDecimal.valueOf(reqDTO.getRating()));
                product.setRating(newTotalRatingSum.divide(BigDecimal.valueOf(product.getRatingCount()), 1, BigDecimal.ROUND_HALF_UP));
                productRepository.save(product);
            }
        }
    }

    @Override
    public void publishOrderStatusUpdate(Long orderId, String newStatus, String statusText, Instant estimatedTime) {
        OrderStatusChangedWsDTO.OrderStatusChangedData data = new OrderStatusChangedWsDTO.OrderStatusChangedData(
                orderId,
                orderRepository.findById(orderId).map(OrderEntity::getOrderNo).orElse("N/A"),
                null, // Old status, can be retrieved if needed
                newStatus,
                statusText,
                System.currentTimeMillis(),
                estimatedTime
        );
        OrderStatusChangedWsDTO wsDTO = new OrderStatusChangedWsDTO("order_status_changed", data);
        orderWebSocketHandler.sendOrderStatusUpdate(orderId, wsDTO);
        log.info("Published order status update for order {}: {}", orderId, newStatus);
    }

    private OrderItemCustomizationEntity createOrderItemCustomization(
            OrderItemEntity orderItem,
            ProductCustomizationTypeEntity type,
            ProductCustomizationOptionEntity option,
            Integer quantity) {
        OrderItemCustomizationEntity customization = new OrderItemCustomizationEntity();
        customization.setOrderItem(orderItem);
        customization.setCustomizationTypeName(type.getTypeName());
        customization.setOptionValue(option.getValue());
        customization.setOptionLabel(option.getLabel());
        customization.setPriceAdjustmentAtOrder(option.getPriceAdjustment());
        customization.setQuantity(quantity);
        customization.setCreatedAt(Instant.now());
        return customization;
    }

    private OrderValidateReqDTO mapToOrderValidateReqDTO(OrderCreateReqDTO reqDTO) {
        OrderValidateReqDTO validateReq = new OrderValidateReqDTO();
        validateReq.setAddressId(reqDTO.getAddressId());
        validateReq.setStoreId(reqDTO.getStoreId()); // Added storeId for validation
        validateReq.setCouponId(reqDTO.getCouponId());
        validateReq.setRemark(reqDTO.getRemark());
        // For validation, if items are passed, we consider them.
        // In a real cart-checkout flow, itemIds here would be actual cart item IDs.
        // For 'createOrder'/'buyNow' directly with products, this needs to be adapted.
        // Assuming `OrderValidateReqDTO`'s `itemIds` are conceptual product IDs in this context.
        validateReq.setItemIds(reqDTO.getItems().stream()
                .map(OrderCreateReqDTO.OrderItemCreateDTO::getProductId)
                .collect(Collectors.toList()));
        return validateReq;
    }

    private String generateOrderNo() {
        // Simple order number generation. Production should use a distributed ID generator.
        return "MT" + DateTimeFormatter.ofPattern("yyyyMMddHHmmss").format(LocalDateTime.now()) +
                String.format("%04d", new Random().nextInt(10000));
    }

    private String generatePickupCode() {
        // Simple pickup code generation.
        return new Random().ints(4, 0, 10).mapToObj(String::valueOf).collect(Collectors.joining());
    }

    private void addOrderStatusTimeline(OrderEntity order, OrderStatus status, boolean isCurrent) {
        OrderStatusTimelineEntity timeline = new OrderStatusTimelineEntity();
        timeline.setOrder(order);
        timeline.setStatus(status.getCode());
        timeline.setStatusText(status.getDescription());
        timeline.setTime(Instant.now());
        timeline.setIsCurrent(isCurrent);
        timeline.setCreatedAt(Instant.now());
        orderStatusTimelineRepository.save(timeline);

        // Update previous current status to false if a new current status is set
        if (isCurrent) {
            orderStatusTimelineRepository.findByOrderIdAndIsCurrentTrue(order.getId())
                    .ifPresent(prev -> {
                        if (!prev.getId().equals(timeline.getId())) { // Don't update self
                            prev.setIsCurrent(false);
                            orderStatusTimelineRepository.save(prev);
                        }
                    });
        }
    }

    private BigDecimal calculateCouponDiscount(CouponTemplateEntity template, BigDecimal productAmount) {
        BigDecimal discount = BigDecimal.ZERO;
        if (template.getMinAmount().compareTo(productAmount) > 0) {
            return BigDecimal.ZERO; // Minimum amount not met
        }

        switch (template.getType()) {
            case "discount": // e.g.,满减
                discount = template.getValue();
                break;
            case "percentage": // e.g., 折扣
                discount = productAmount.multiply(template.getValue());
                break;
            case "fixed": // e.g., 固定金额
                discount = template.getValue();
                break;
            default:
                log.warn("Unknown coupon type: {}", template.getType());
                break;
        }
        return discount.min(productAmount); // Discount cannot exceed product amount
    }

    private UserAddressResDTO.AddressDTO mapToAddressDTO(UserAddressEntity entity) {
        UserAddressResDTO.AddressDTO dto = new UserAddressResDTO.AddressDTO();
        dto.setId(entity.getId());
        dto.setName(entity.getName());
        dto.setPhone(entity.getPhone());
        dto.setProvince(entity.getProvince());
        dto.setCity(entity.getCity());
        dto.setDistrict(entity.getDistrict());
        dto.setDetail(entity.getDetail());
        dto.setPostalCode(entity.getPostalCode());
        dto.setIsDefault(entity.getIsDefault());
        dto.setType(entity.getType());
        dto.setLabel(entity.getLabel());
        dto.setLongitude(entity.getLongitude());
        dto.setLatitude(entity.getLatitude());
        dto.setCreatedAt(entity.getCreatedAt());
        return dto;
    }

    private HomePageResDTO.NearbyStoreDTO mapToNearbyStoreDTO(StoreEntity entity, BigDecimal userLat, BigDecimal userLon, Long userId) {
        HomePageResDTO.NearbyStoreDTO dto = new HomePageResDTO.NearbyStoreDTO();
        dto.setId(String.valueOf(entity.getId()));
        dto.setName(entity.getName());
        dto.setAddress(entity.getAddress());

        double distance = GeoUtil.calculateDistance(
                userLat.doubleValue(), userLon.doubleValue(),
                entity.getLatitude().doubleValue(), entity.getLongitude().doubleValue()
        );
        dto.setDistance((int) Math.round(distance));

        dto.setBusinessHours(entity.getBusinessHours());
        dto.setStatus(entity.getStatus());
        dto.setPhone(entity.getPhone());
        dto.setServices(entity.getServices().stream().map(StoreServiceEntity::getServiceType).collect(Collectors.toList()));
        dto.setTags(entity.getTags().stream().map(StoreTagEntity::getTagName).collect(Collectors.toList()));
        dto.setDeliveryFee(entity.getDeliveryFee());
        dto.setMinimumOrderAmount(entity.getMinimumOrderAmount());
        dto.setRating(entity.getRating());
        dto.setImages(entity.getImages().stream().map(StoreImageEntity::getImageUrl).collect(Collectors.toList()));
        dto.setCurrentWaitTime(entity.getCurrentWaitTime());
        // This 'isFavorite' cannot be directly determined without knowing the requesting user's favorites
        dto.setIsFavorite(userId != null && userFavoriteStoreRepository.existsByUserIdAndStoreId(userId, entity.getId()));
        dto.setLongitude(entity.getLongitude()); // Added from StoreDetailResDTO
        dto.setLatitude(entity.getLatitude());   // Added from StoreDetailResDTO
        return dto;
    }

    private CouponListResDTO.CouponDTO mapToCouponDTO(UserCouponEntity entity) {
        CouponListResDTO.CouponDTO dto = new CouponListResDTO.CouponDTO();
        dto.setId(entity.getId());
        dto.setName(entity.getCouponTemplate().getName());
        dto.setType(entity.getCouponTemplate().getType());
        dto.setValue(entity.getCouponTemplate().getValue());
        dto.setMinAmount(entity.getCouponTemplate().getMinAmount());
        dto.setDescription(entity.getCouponTemplate().getDescription());
        dto.setUsage(entity.getCouponTemplate().getUsageScope());
        if (entity.getCouponTemplate().getTargetIds() != null) {
            try {
                dto.setTargetIds(objectMapper.readValue(entity.getCouponTemplate().getTargetIds(), List.class));
            } catch (JsonProcessingException e) {
                log.error("Error parsing targetIds JSON: {}", entity.getCouponTemplate().getTargetIds(), e);
                dto.setTargetIds(List.of());
            }
        } else {
            dto.setTargetIds(List.of());
        }
        dto.setStatus(entity.getStatus());
        dto.setReceivedAt(entity.getReceivedAt());
        dto.setExpireAt(entity.getExpireAt());
        dto.setUsedAt(entity.getUsedAt());
        dto.setOrderId(entity.getOrderId());
        dto.setCanUse(true); // Placeholder for detailed "canUse" logic based on current order context
        dto.unusableReason = ""; // Placeholder
        return dto;
    }

    private OrderListResDTO.OrderSummaryDTO mapToOrderSummaryDTO(OrderEntity entity) {
        OrderListResDTO.OrderSummaryDTO dto = new OrderListResDTO.OrderSummaryDTO();
        dto.setId(entity.getId());
        dto.setOrderNo(entity.getOrderNo());
        dto.setStatus(entity.getStatus());
        dto.setStatusText(entity.getStatusText());
        dto.setType(entity.getType());
        dto.setTotalAmount(entity.getTotalAmount());
        dto.setPayAmount(entity.getPayAmount());
        dto.setItemCount(entity.getItems() != null ? entity.getItems().size() : 0);
        dto.setItems(entity.getItems() != null ? entity.getItems().stream()
                .map(this::mapToOrderItemBriefDTO)
                .collect(Collectors.toList()) : Collections.emptyList());
        dto.setStoreName(entity.getPickupStore() != null ? entity.getPickupStore().getName() : null);
        dto.setAddress(entity.getDeliveryAddress() != null ? entity.getDeliveryAddress().getDetail() : null);
        dto.setDeliveryTime(entity.getDeliveryTimeExpected());
        dto.setCreatedAt(entity.getCreatedAt());

        // Computed actions
        List<String> actions = new ArrayList<>();
        boolean needAction = false;
        if (OrderStatus.CREATED.getCode().equals(entity.getStatus()) && entity.getPayAmount().compareTo(BigDecimal.ZERO) > 0) {
            actions.add("pay");
            actions.add("cancel");
            needAction = true;
        } else if (OrderStatus.PAID.getCode().equals(entity.getStatus())) {
            actions.add("remind"); // Remind for making
            actions.add("cancel"); // Allow cancellation for paid but not yet making
            needAction = true;
        } else if (OrderStatus.MAKING.getCode().equals(entity.getStatus())) {
            actions.add("remind");
        } else if (OrderStatus.READY.getCode().equals(entity.getStatus()) || OrderStatus.DELIVERING.getCode().equals(entity.getStatus())) {
            actions.add("confirm");
            needAction = true;
        } else if (OrderStatus.COMPLETED.getCode().equals(entity.getStatus()) && !entity.getIsRated()) {
            actions.add("rate");
            needAction = true;
        }
        if (OrderStatus.COMPLETED.getCode().equals(entity.getStatus()) && entity.getRefundDeadline() != null && Instant.now().isBefore(entity.getRefundDeadline())) {
            actions.add("apply_refund");
            needAction = true;
        }
        dto.setActions(actions);
        dto.setNeedAction(needAction);

        return dto;
    }

    private OrderListResDTO.OrderItemBriefDTO mapToOrderItemBriefDTO(OrderItemEntity entity) {
        OrderListResDTO.OrderItemBriefDTO dto = new OrderListResDTO.OrderItemBriefDTO();
        dto.setProductName(entity.getProductName());
        dto.setProductImage(entity.getProductImageUrl());
        dto.setQuantity(entity.getQuantity());
        dto.setPrice(entity.getPriceAtOrder());
        return dto;
    }

    private OrderDetailResDTO mapToOrderDetailResDTO(OrderEntity entity) {
        OrderDetailResDTO dto = new OrderDetailResDTO();
        dto.setId(entity.getId());
        dto.setOrderNo(entity.getOrderNo());
        dto.setStatus(entity.getStatus());
        dto.setStatusText(entity.getStatusText());
        dto.setType(entity.getType());
        dto.setCreatedAt(entity.getCreatedAt());
        dto.setUpdatedAt(entity.getUpdatedAt());

        // Map order items
        dto.setItems(entity.getItems() != null ? entity.getItems().stream()
                .map(this::mapToOrderItemDetailDTO)
                .collect(Collectors.toList()) : Collections.emptyList());

        // Map status timeline
        dto.setStatusTimeline(entity.getStatusTimelines() != null ? entity.getStatusTimelines().stream()
                .map(this::mapToOrderStatusTimelineDTO)
                .sorted(Comparator.comparing(OrderDetailResDTO.OrderStatusTimelineDTO::getTime, Comparator.nullsFirst(Comparator.naturalOrder())))
                .collect(Collectors.toList()) : Collections.emptyList());

        // Map summary
        OrderDetailResDTO.OrderSummaryDetailDTO summaryDTO = new OrderDetailResDTO.OrderSummaryDetailDTO();
        summaryDTO.setProductAmount(entity.getProductAmount());
        summaryDTO.setDeliveryFee(entity.getDeliveryFee());
        summaryDTO.setPackageFee(entity.getPackageFee());
        summaryDTO.setDiscount(entity.getDiscountAmount());
        summaryDTO.setPointsDiscount(entity.getPointsUsed()); // Assuming points used is the discount value
        summaryDTO.setBalanceDiscount(entity.getBalanceUsed());
        summaryDTO.setTotalAmount(entity.getTotalAmount());
        summaryDTO.setPayAmount(entity.getPayAmount());
        summaryDTO.setPointsEarned(entity.getTotalAmount().multiply(BigDecimal.TEN).intValue()); // Example calc
        dto.setSummary(summaryDTO);

        // Address/Store info
        if ("delivery".equalsIgnoreCase(entity.getType()) && entity.getDeliveryAddress() != null) {
            dto.setAddress(mapToAddressDTO(entity.getDeliveryAddress()));
        }
        if (entity.getPickupStore() != null) {
            // Need a simplified store DTO, or reuse HomePageResDTO.NearbyStoreDTO without distance
            dto.setStore(mapToNearbyStoreDTO(entity.getPickupStore(), BigDecimal.ZERO, BigDecimal.ZERO, userId)); // dummy lat/lon for store itself
        }

        // Delivery/Pickup specific info
        if ("delivery".equalsIgnoreCase(entity.getType())) {
            OrderDetailResDTO.DeliveryInfoDTO deliveryInfo = new OrderDetailResDTO.DeliveryInfoDTO();
            deliveryInfo.setDeliveryTime(entity.getDeliveryTimeExpected());
            deliveryInfo.setEstimatedArrival(entity.getEstimatedArrivalTime());
            deliveryInfo.setRiderName(entity.getRiderName());
            deliveryInfo.setRiderPhone(entity.getRiderPhone());
            if (entity.getRiderLongitude() != null && entity.getRiderLatitude() != null) {
                deliveryInfo.setRiderLocation(new OrderDetailResDTO.RiderLocationDTO(entity.getRiderLongitude(), entity.getRiderLatitude()));
            }
            dto.setDeliveryInfo(deliveryInfo);
        } else if ("pickup".equalsIgnoreCase(entity.getType())) {
            OrderDetailResDTO.PickupInfoDTO pickupInfo = new OrderDetailResDTO.PickupInfoDTO();
            pickupInfo.setPickupCode(entity.getPickupCode());
            pickupInfo.setPickupTime(entity.getPickupTimeActual());
            pickupInfo.setEstimatedReadyTime(entity.getEstimatedReadyTime());
            pickupInfo.setCounterNumber(entity.getCounterNumber());
            dto.setPickupInfo(pickupInfo);
        }

        // Payment info
        paymentRepository.findByOrderId(entity.getId()).ifPresent(paymentEntity -> {
            OrderDetailResDTO.PaymentDetailDTO paymentDTO = new OrderDetailResDTO.PaymentDetailDTO();
            paymentDTO.setPayType(paymentEntity.getPayType());
            paymentDTO.setPayAmount(paymentEntity.getPayAmount());
            paymentDTO.setPayTime(paymentEntity.getPayTime());
            paymentDTO.setTransactionId(paymentEntity.getTransactionId());
            dto.setPayment(paymentDTO);
        });

        // Used coupon
        if (entity.getCouponId() != null) {
            userCouponRepository.findById(entity.getCouponId()).ifPresent(userCoupon -> {
                dto.setCoupon(mapToCouponDTO(userCoupon));
            });
        }

        dto.setPointsUsed(entity.getPointsUsed());
        dto.setBalanceUsed(entity.getBalanceUsed());
        dto.setRemark(entity.getRemark());

        // Invoice info
        if (entity.getInvoiceType() != null) {
            OrderDetailResDTO.InvoiceDetailDTO invoiceDTO = new OrderDetailResDTO.InvoiceDetailDTO();
            invoiceDTO.setType(entity.getInvoiceType());
            invoiceDTO.setTitle(entity.getInvoiceTitle());
            invoiceDTO.setStatus("pending"); // Placeholder, could fetch from invoice service
            dto.setInvoice(invoiceDTO);
        }

        // Actions
        List<String> actions = new ArrayList<>();
        if (OrderStatus.CREATED.getCode().equals(entity.getStatus()) || OrderStatus.PAID.getCode().equals(entity.getStatus())) {
            if (entity.getCancelDeadline() == null || Instant.now().isBefore(entity.getCancelDeadline())) {
                actions.add("cancel");
            }
            if (OrderStatus.PAID.getCode().equals(entity.getStatus())) {
                actions.add("remind");
            }
        }
        if (OrderStatus.MAKING.getCode().equals(entity.getStatus())) {
            actions.add("remind");
        }
        if (OrderStatus.READY.getCode().equals(entity.getStatus()) || OrderStatus.DELIVERING.getCode().equals(entity.getStatus())) {
            actions.add("confirm");
        }
        if (OrderStatus.COMPLETED.getCode().equals(entity.getStatus())) {
            if (entity.getRefundDeadline() != null && Instant.now().isBefore(entity.getRefundDeadline())) {
                actions.add("apply_refund");
            }
            if (!entity.getIsRated() && (entity.getRateDeadline() == null || Instant.now().isBefore(entity.getRateDeadline()))) {
                actions.add("rate");
            }
        }
        dto.setActions(actions);
        dto.setCancelDeadline(entity.getCancelDeadline());
        dto.setRefundDeadline(entity.getRefundDeadline());
        dto.setRateDeadline(entity.getRateDeadline());

        return dto;
    }

    private OrderDetailResDTO.OrderItemDetailDTO mapToOrderItemDetailDTO(OrderItemEntity entity) {
        OrderDetailResDTO.OrderItemDetailDTO dto = new OrderDetailResDTO.OrderItemDetailDTO();
        dto.setProductId(entity.getProduct().getId());
        dto.setProductName(entity.getProductName());
        dto.setProductImage(entity.getProductImageUrl());
        dto.setQuantity(entity.getQuantity());
        dto.setPrice(entity.getPriceAtOrder());
        dto.setOriginalPrice(entity.getOriginalPriceAtOrder());
        dto.setSubtotal(entity.getSubtotal());

        OrderDetailResDTO.CustomizationsDetailDTO customizationsDTO = new OrderDetailResDTO.CustomizationsDetailDTO();
        List<OrderDetailResDTO.ToppingDetailDTO> toppingDetailDTOs = new ArrayList<>();
        for (OrderItemCustomizationEntity customization : entity.getCustomizations()) {
            switch (customization.getCustomizationTypeName()) {
                case "sweetness" -> customizationsDTO.setSweetness(customization.getOptionLabel());
                case "temperature" -> customizationsDTO.setTemperature(customization.getOptionLabel());
                case "toppings" -> toppingDetailDTOs.add(new OrderDetailResDTO.ToppingDetailDTO(
                        customization.getOptionLabel(), customization.getPriceAdjustmentAtOrder(), customization.getQuantity()
                ));
            }
        }
        customizationsDTO.setToppings(toppingDetailDTOs);
        dto.setCustomizations(customizationsDTO);
        return dto;
    }

    private OrderDetailResDTO.OrderStatusTimelineDTO mapToOrderStatusTimelineDTO(OrderStatusTimelineEntity entity) {
        OrderDetailResDTO.OrderStatusTimelineDTO dto = new OrderDetailResDTO.OrderStatusTimelineDTO();
        dto.setStatus(entity.getStatus());
        dto.setText(entity.getStatusText());
        dto.setTime(entity.getTime());
        dto.setCompleted(entity.getIsCurrent()); // Simplified: assume current means completed up to this point
        dto.setCurrent(entity.getIsCurrent());
        // Estimated time logic would be complex; keeping null for non-current states.
        dto.setEstimatedTime(null);
        return dto;
    }

    // Placeholder method, ideally customization options have explicit IDs or a unique code
    private Long getOptionIdFromValue(String optionValue) {
        // This is highly problematic without knowing the actual mapping or global option IDs.
        // For a more robust solution, the `ProductCustomizationOptionEntity` should either:
        // 1. Have a unique 'code' field that maps to DTO 'value'.
        // 2. Be fetched by `customizationType.id` and `value`.
        // Returning a dummy ID or throwing an error is appropriate for a placeholder.
        // For a real app, you'd likely query:
        // customizationOptionRepository.findByCustomizationTypeAndValue(type, optionValue).getId();
        log.warn("Directly mapping option value '{}' to a dummy ID. This needs proper implementation.", optionValue);
        return 1L; // Dummy ID
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\service\impl\PointServiceImpl.java ---
// File: milktea-backend/src/main/java/com.milktea.app/service/impl/PointServiceImpl.java
package com.milktea.app.service.impl;

import com.milktea.app.common.constant.ErrorCode;
import com.milktea.app.common.exception.BusinessException;
import com.milktea.app.dto.point.PointExchangeReqDTO;
import com.milktea.app.dto.point.PointTransactionListResDTO;
import com.milktea.app.entity.PointExchangeItemEntity;
import com.milktea.app.entity.PointTransactionEntity;
import com.milktea.app.entity.UserEntity;
import com.milktea.app.repository.PointExchangeItemRepository;
import com.milktea.app.repository.PointTransactionRepository;
import com.milktea.app.repository.UserRepository;
import com.milktea.app.service.PointService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.data.jpa.domain.Specification;
import jakarta.persistence.criteria.Predicate;

import java.time.Instant;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
import lombok.EqualsAndHashCode;

@Service
@RequiredArgsConstructor
@Slf4j
@EqualsAndHashCode
public class PointServiceImpl implements PointService {

    private final UserRepository userRepository;
    private final PointTransactionRepository pointTransactionRepository;
    private final PointExchangeItemRepository pointExchangeItemRepository;

    @Override
    @Transactional(readOnly = true)
    public PointTransactionListResDTO getPointTransactions(Long userId, String type, Pageable pageable) {
        UserEntity user = userRepository.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_EXIST, "User not found."));

        Specification<PointTransactionEntity> spec = (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();
            predicates.add(cb.equal(root.get("user").get("id"), userId));

            if (type != null && !type.equalsIgnoreCase("all")) {
                predicates.add(cb.equal(root.get("type"), type.toLowerCase()));
            }

            return cb.and(predicates.toArray(new Predicate[0]));
        };

        // Find all matching transactions for the user, then manually paginate
        // For a more efficient solution, repository method should return Page<PointTransactionEntity> directly with the spec.
        List<PointTransactionEntity> transactions = pointTransactionRepository.findAll(spec);


        // Manual pagination for simplicity as findByUserId returns all.
        // In a real app, the repository method would return a Page<PointTransactionEntity>.
        int start = (int) pageable.getOffset();
        int end = Math.min((start + pageable.getPageSize()), transactions.size());
        List<PointTransactionEntity> pagedTransactions = transactions.subList(start, end);

        List<PointTransactionListResDTO.PointTransactionDTO> transactionDTOs = pagedTransactions.stream()
                .map(this::mapToPointTransactionDTO)
                .collect(Collectors.toList());

        PointTransactionListResDTO.PointSummaryDTO summary = new PointTransactionListResDTO.PointSummaryDTO(
                user.getPoints(),
                user.getPoints(), // availablePoints same as totalPoints for now, no frozen logic
                0, // frozenPoints placeholder
                100, // expiringPoints placeholder
                LocalDate.of(2024, 12, 31) // expireDate placeholder
        );

        PointTransactionListResDTO resDTO = new PointTransactionListResDTO();
        resDTO.setTransactions(transactionDTOs);
        resDTO.setTotal(transactions.size());
        resDTO.setPage(pageable.getPageNumber() + 1);
        resDTO.setLimit(pageable.getPageSize());
        resDTO.setSummary(summary);
        return resDTO;
    }

    @Override
    @Transactional
    public void exchangePoints(Long userId, PointExchangeReqDTO reqDTO) {
        UserEntity user = userRepository.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_EXIST, "User not found."));

        PointExchangeItemEntity exchangeItem = pointExchangeItemRepository.findById(reqDTO.getItemId())
                .orElseThrow(() -> new BusinessException(ErrorCode.POINT_EXCHANGE_ITEM_NOT_FOUND, "Exchange item not found."));

        if (!exchangeItem.getIsActive()) {
            throw new BusinessException(ErrorCode.POINT_EXCHANGE_ITEM_NOT_FOUND, "Exchange item is not active.");
        }
        if (exchangeItem.getStock() != null && exchangeItem.getStock() < reqDTO.getQuantity()) {
            throw new BusinessException(ErrorCode.POINT_EXCHANGE_ITEM_OUT_OF_STOCK, "Exchange item stock insufficient.");
        }

        int totalCost = exchangeItem.getPointsCost() * reqDTO.getQuantity();
        if (user.getPoints() < totalCost) {
            throw new BusinessException(ErrorCode.INSUFFICIENT_POINTS, "Insufficient points to exchange.");
        }

        // Deduct points
        user.setPoints(user.getPoints() - totalCost);
        userRepository.save(user);

        // Update item stock if applicable
        if (exchangeItem.getStock() != null) {
            exchangeItem.setStock(exchangeItem.getStock() - reqDTO.getQuantity());
            pointExchangeItemRepository.save(exchangeItem);
        }

        // Record point transaction
        PointTransactionEntity transaction = new PointTransactionEntity();
        transaction.setUser(user);
        transaction.setPointsChange(-totalCost);
        transaction.setBalanceAfterTransaction(user.getPoints());
        transaction.setType("use");
        transaction.setDescription("兑换商品: " + exchangeItem.getName());
        transaction.setRelatedType("exchange_item");
        transaction.setRelatedId(String.valueOf(exchangeItem.getId()));
        transaction.setCreatedAt(Instant.now());
        pointTransactionRepository.save(transaction);

        // Trigger action based on target_type (e.g., issue a coupon, create an order for a product)
        log.info("User {} exchanged {} points for item {}. Target type: {}", userId, totalCost, exchangeItem.getId(), exchangeItem.getTargetType());
        // Placeholder for actual logic:
        // if ("coupon_template".equals(exchangeItem.getTargetType())) {
        //     couponService.receiveCoupon(userId, exchangeItem.getTargetId());
        // } else if ("product".equals(exchangeItem.getTargetType())) {
        //     // Logic to create a special order for the redeemed product
        // }
    }

    private PointTransactionListResDTO.PointTransactionDTO mapToPointTransactionDTO(PointTransactionEntity entity) {
        PointTransactionListResDTO.PointTransactionDTO dto = new PointTransactionListResDTO.PointTransactionDTO();
        dto.setId(entity.getId());
        dto.setType(entity.getType());
        dto.setPoints(entity.getPointsChange());
        dto.setBalance(entity.getBalanceAfterTransaction());
        dto.setDescription(entity.getDescription());
        dto.setRelatedId(entity.getRelatedId());
        dto.setRelatedType(entity.getRelatedType());
        dto.setCreatedAt(entity.getCreatedAt());
        return dto;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\service\impl\ProductServiceImpl.java ---
// File: milktea-backend/src/main/java/com.milktea.app/service/impl/ProductServiceImpl.java
package com.milktea.app.service.impl;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.milktea.app.common.constant.ErrorCode;
import com.milktea.app.common.exception.BusinessException;
import com.milktea.app.dto.product.ProductDetailResDTO;
import com.milktea.app.dto.product.ProductFavoriteStatusResDTO;
import com.milktea.app.dto.product.ProductListReqDTO;
import com.milktea.app.dto.product.ProductListResDTO;
import com.milktea.app.entity.*;
import com.milktea.app.repository.*;
import com.milktea.app.service.ProductService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.data.jpa.domain.Specification;
import jakarta.persistence.criteria.Predicate;


import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class ProductServiceImpl implements ProductService {

    private final ProductRepository productRepository;
    private final CategoryRepository categoryRepository;
    private final ProductImageRepository productImageRepository;
    private final ProductCustomizationTypeRepository customizationTypeRepository;
    private final ProductCustomizationOptionRepository customizationOptionRepository; // Added
    private final ProductNutritionRepository productNutritionRepository;
    private final UserFavoriteProductRepository userFavoriteProductRepository;
    private final UserRepository userRepository;
    private final ObjectMapper objectMapper;
    private final AllergenRepository allergenRepository; // Added for eager loading in detail
    private final IngredientRepository ingredientRepository; // Added for eager loading in detail

    @Override
    @Transactional(readOnly = true)
    public ProductListResDTO getProducts(ProductListReqDTO reqDTO, Pageable pageable) {
        // Apply sorting
        Sort sort = Sort.unsorted();
        if (reqDTO.getSort() != null) {
            switch (reqDTO.getSort()) {
                case "sales":
                    sort = Sort.by(Sort.Direction.DESC, "sales");
                    break;
                case "price_asc":
                    sort = Sort.by(Sort.Direction.ASC, "price");
                    break;
                case "price_desc":
                    sort = Sort.by(Sort.Direction.DESC, "price");
                    break;
                case "newest":
                    sort = Sort.by(Sort.Direction.DESC, "createdAt");
                    break;
                case "relevance": // Default for search, no specific entity field, handled in custom query
                default:
                    sort = Sort.by(Sort.Direction.DESC, "rating"); // Example default sort for relevance
                    break;
            }
        }
        pageable = PageRequest.of(pageable.getPageNumber(), pageable.getPageSize(), sort);

        // Apply filter if any
        Specification<ProductEntity> spec = (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();
            predicates.add(cb.equal(root.get("isActive"), true));

            if (reqDTO.getFilter() != null && !reqDTO.getFilter().isEmpty()) {
                switch (reqDTO.getFilter()) {
                    case "sugar_free":
                        // Assuming 'sugar_free' is a tag or a customization option that can be filtered
                        // For simplicity, let's assume it's a tag for now.
                        predicates.add(cb.like(root.get("tags"), "%\"sugar_free\"%")); // Crude JSONB search
                        break;
                    case "hot":
                        // Assuming 'hot' is a customization option or product property
                        // For simplicity, let's assume `isHot` flag
                        predicates.add(cb.equal(root.get("isHot"), true));
                        break;
                    case "ice":
                        // Assuming 'ice' is a customization option or product property
                        // For simplicity, no direct flag, so this might need joining customization options or tag
                        // For now, no specific filter for 'ice'
                        log.warn("Product filter 'ice' not fully implemented yet.");
                        break;
                }
            }
            return cb.and(predicates.toArray(new Predicate[0]));
        };

        Page<ProductEntity> productPage = productRepository.findAll(spec, pageable);

        List<ProductListResDTO.ProductItemDTO> productItemDTOs = productPage.getContent().stream()
                .map(this::mapToProductItemDTO)
                .collect(Collectors.toList());

        ProductListResDTO resDTO = new ProductListResDTO();
        resDTO.setProducts(productItemDTOs);
        resDTO.setTotal((int) productPage.getTotalElements());
        resDTO.setPage(productPage.getNumber() + 1);
        resDTO.setLimit(pageable.getPageSize());
        return resDTO;
    }

    @Override
    @Transactional(readOnly = true)
    public ProductListResDTO getCategoryProducts(Long categoryId, ProductListReqDTO reqDTO, Pageable pageable) {
        categoryRepository.findById(categoryId)
                .orElseThrow(() -> new BusinessException(ErrorCode.NOT_FOUND, "Category not found."));

        // Apply sorting
        Sort sort = Sort.unsorted();
        if (reqDTO.getSort() != null) {
            switch (reqDTO.getSort()) {
                case "sales":
                    sort = Sort.by(Sort.Direction.DESC, "sales");
                    break;
                case "price_asc":
                    sort = Sort.by(Sort.Direction.ASC, "price");
                    break;
                case "price_desc":
                    sort = Sort.by(Sort.Direction.DESC, "price");
                    break;
                case "newest":
                    sort = Sort.by(Sort.Direction.DESC, "createdAt");
                    break;
                default:
                    break;
            }
        }
        pageable = PageRequest.of(pageable.getPageNumber(), pageable.getPageSize(), sort);

        // Apply filters
        Specification<ProductEntity> spec = (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();
            predicates.add(cb.equal(root.get("isActive"), true));
            predicates.add(cb.equal(root.get("category").get("id"), categoryId));

            if (reqDTO.getFilter() != null && !reqDTO.getFilter().isEmpty()) {
                switch (reqDTO.getFilter()) {
                    case "sugar_free":
                        predicates.add(cb.like(root.get("tags"), "%\"sugar_free\"%"));
                        break;
                    case "hot":
                        predicates.add(cb.equal(root.get("isHot"), true));
                        break;
                    case "ice":
                        log.warn("Product filter 'ice' not fully implemented yet for category products.");
                        break;
                }
            }
            return cb.and(predicates.toArray(new Predicate[0]));
        };

        Page<ProductEntity> productPage = productRepository.findAll(spec, pageable);

        List<ProductListResDTO.ProductItemDTO> productItemDTOs = productPage.getContent().stream()
                .map(this::mapToProductItemDTO)
                .collect(Collectors.toList());

        ProductListResDTO resDTO = new ProductListResDTO();
        resDTO.setProducts(productItemDTOs);
        resDTO.setTotal((int) productPage.getTotalElements());
        resDTO.setPage(productPage.getNumber() + 1);
        resDTO.setLimit(pageable.getPageSize());
        return resDTO;
    }


    @Override
    @Transactional(readOnly = true)
    public ProductDetailResDTO getProductDetail(Long userId, Long productId) {
        // Fetch product with eager loading for related entities to avoid N+1 problem
        ProductEntity product = productRepository.findById(productId) // Simplified: Ideally use a custom query with FETCH JOIN
                .orElseThrow(() -> new BusinessException(ErrorCode.PRODUCT_NOT_FOUND, "Product not found."));
        // Manually load related entities if not eagerly fetched by default for this boilerplate.
        // For production, configure fetch types or write specific queries.
        // product.getImages().size(); // Trigger loading
        // product.getCustomizationTypes().size(); // Trigger loading
        // product.getCustomizationTypes().forEach(type -> type.getOptions().size()); // Trigger loading of options
        // product.getNutritions().size(); // Trigger loading
        // product.getIngredients().size(); // Trigger loading
        // product.getAllergens().size(); // Trigger loading
        // product.getRelatedProducts().size(); // Trigger loading

        if (!product.getIsActive()) {
            throw new BusinessException(ErrorCode.PRODUCT_OFFLINE, "Product is offline.");
        }

        ProductDetailResDTO dto = new ProductDetailResDTO();
        dto.setId(product.getId());
        dto.setName(product.getName());
        dto.setSubtitle(product.getSubtitle());
        dto.setMainImage(product.getMainImageUrl());
        dto.setPrice(product.getPrice());
        dto.setOriginalPrice(product.getOriginalPrice());
        dto.setUnit(product.getUnit());
        dto.setStock(product.getStock());
        dto.setSales(product.getSales());
        dto.setMonthlySales(product.getMonthlySales());
        dto.setRating(product.getRating());
        dto.setRatingCount(product.getRatingCount());
        dto.setFavoriteCount(product.getFavoriteCount());
        dto.setIsHot(product.getIsHot());
        dto.setIsNew(product.getIsNew());
        dto.setIsRecommend(product.getIsRecommend());
        dto.setDescription(product.getDescription());
        dto.setDetailHtml(product.getDetailHtml());
        dto.setStorage(product.getStorageMethod());
        dto.setShelfLife(product.getShelfLife());
        dto.setCreatedAt(product.getCreatedAt());
        dto.setUpdatedAt(product.getUpdatedAt());

        // Category info
        if (product.getCategory() != null) {
            dto.setCategoryId(product.getCategory().getId());
            dto.setCategoryName(product.getCategory().getName());
        }

        // Images
        List<ProductImageEntity> images = productImageRepository.findByProductIdOrderBySortOrderAsc(productId);
        dto.setImages(images.stream().map(ProductImageEntity::getImageUrl).collect(Collectors.toList()));

        // Tags
        if (product.getTags() != null) {
            try {
                dto.setTags(objectMapper.readValue(product.getTags(), new TypeReference<List<String>>() {}));
            } catch (Exception e) {
                log.error("Failed to parse product tags for product {}: {}", product.getId(), e.getMessage());
                dto.setTags(new ArrayList<>());
            }
        } else {
            dto.setTags(new ArrayList<>());
        }


        // Customizations
        ProductDetailResDTO.CustomizationsDTO customizationsDTO = new ProductDetailResDTO.CustomizationsDTO();
        List<ProductCustomizationTypeEntity> customizationTypes = customizationTypeRepository.findByProductIdAndIsEnabledTrueOrderBySortOrderAsc(productId);

        for (ProductCustomizationTypeEntity type : customizationTypes) {
            List<ProductCustomizationOptionEntity> options = customizationOptionRepository.findByCustomizationType_IdOrderBySortOrderAsc(type.getId());
            List<ProductDetailResDTO.OptionDTO> optionDTOs = options.stream()
                    .map(option -> new ProductDetailResDTO.OptionDTO(
                            option.getValue(),
                            option.getLabel(),
                            option.getPriceAdjustment(),
                            option.getIsDefault()
                    )).collect(Collectors.toList());

            if ("sweetness".equals(type.getTypeName())) {
                customizationsDTO.setSweetness(new ProductDetailResDTO.CustomizationTypeDTO(
                        type.getIsEnabled(), type.getIsRequired(), optionDTOs
                ));
            } else if ("temperature".equals(type.getTypeName())) {
                customizationsDTO.setTemperature(new ProductDetailResDTO.CustomizationTypeDTO(
                        type.getIsEnabled(), type.getIsRequired(), optionDTOs
                ));
            } else if ("toppings".equals(type.getTypeName())) {
                List<ProductDetailResDTO.ToppingOptionDTO> toppingOptionDTOs = options.stream()
                        .map(option -> new ProductDetailResDTO.ToppingOptionDTO(
                                String.valueOf(option.getId()), // Use ID for toppings
                                option.getLabel(),
                                option.getPriceAdjustment(),
                                option.getStock(),
                                option.getIconUrl()
                        )).collect(Collectors.toList());
                customizationsDTO.setToppings(new ProductDetailResDTO.ToppingsCustomizationDTO(
                        type.getIsEnabled(), type.getIsRequired(), type.getMaxQuantity(), toppingOptionDTOs
                ));
            }
        }
        dto.setCustomizations(customizationsDTO);

        // Nutrition
        List<ProductNutritionEntity> nutritions = productNutritionRepository.findByProductId(productId);
        dto.setNutrition(nutritions.stream()
                .map(n -> new ProductDetailResDTO.NutritionDTO(n.getName(), n.getValue(), n.getUnit()))
                .collect(Collectors.toList()));

        // Ingredients & Allergens (assuming these are loaded eagerly or via a custom query)
        dto.setIngredients(product.getIngredients().stream().map(IngredientEntity::getName).collect(Collectors.toList()));
        dto.setAllergens(product.getAllergens().stream().map(AllergenEntity::getName).collect(Collectors.toList()));

        // Related Products
        dto.setRelatedProducts(product.getRelatedProducts().stream()
                .map(rp -> new ProductDetailResDTO.RelatedProductDTO(rp.getId(), rp.getName(), rp.getMainImageUrl(), rp.getPrice()))
                .collect(Collectors.toList()));

        return dto;
    }

    @Override
    @Transactional
    public void addFavoriteProduct(Long userId, Long productId) {
        UserEntity user = userRepository.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_EXIST, "User not found."));
        ProductEntity product = productRepository.findById(productId)
                .orElseThrow(() -> new BusinessException(ErrorCode.PRODUCT_NOT_FOUND, "Product not found."));

        if (userFavoriteProductRepository.existsByUserIdAndProductId(userId, productId)) {
            log.info("Product {} is already favorited by user {}", productId, userId);
            return; // Already favorited, no action needed
        }

        UserFavoriteProductEntity favorite = new UserFavoriteProductEntity();
        favorite.setUser(user);
        favorite.setProduct(product);
        favorite.setCreatedAt(Instant.now());
        userFavoriteProductRepository.save(favorite);

        // Increment product's favorite count
        product.setFavoriteCount(product.getFavoriteCount() + 1);
        productRepository.save(product);
        log.info("User {} favorited product {}", userId, productId);
    }

    @Override
    @Transactional
    public void removeFavoriteProduct(Long userId, Long productId) {
        userRepository.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_EXIST, "User not found."));
        ProductEntity product = productRepository.findById(productId)
                .orElseThrow(() -> new BusinessException(ErrorCode.PRODUCT_NOT_FOUND, "Product not found."));

        Optional<UserFavoriteProductEntity> favoriteOptional = userFavoriteProductRepository.findByUserIdAndProductId(userId, productId);
        if (favoriteOptional.isEmpty()) {
            log.info("Product {} is not favorited by user {}", productId, userId);
            return; // Not favorited, no action needed
        }

        userFavoriteProductRepository.delete(favoriteOptional.get());

        // Decrement product's favorite count
        product.setFavoriteCount(product.getFavoriteCount() - 1);
        productRepository.save(product);
        log.info("User {} unfavorited product {}", userId, productId);
    }

    @Override
    @Transactional(readOnly = true)
    public ProductFavoriteStatusResDTO getProductFavoriteStatus(Long userId, Long productId) {
        userRepository.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_EXIST, "User not found."));
        productRepository.findById(productId)
                .orElseThrow(() -> new BusinessException(ErrorCode.PRODUCT_NOT_FOUND, "Product not found."));

        Optional<UserFavoriteProductEntity> favorite = userFavoriteProductRepository.findByUserIdAndProductId(userId, productId);

        return new ProductFavoriteStatusResDTO(
                favorite.isPresent(),
                favorite.map(UserFavoriteProductEntity::getId).orElse(null)
        );
    }

    private ProductListResDTO.ProductItemDTO mapToProductItemDTO(ProductEntity entity) {
        ProductListResDTO.ProductItemDTO dto = new ProductListResDTO.ProductItemDTO();
        dto.setId(entity.getId());
        dto.setName(entity.getName());
        dto.setImage(entity.getMainImageUrl());
        dto.setPrice(entity.getPrice());
        dto.setOriginalPrice(entity.getOriginalPrice());
        dto.setSales(entity.getSales());
        if (entity.getTags() != null) {
            try {
                dto.setTags(objectMapper.readValue(entity.getTags(), new TypeReference<List<String>>() {}));
            } catch (Exception e) {
                log.error("Failed to parse product tags for product {}: {}", entity.getId(), e.getMessage());
                dto.setTags(new ArrayList<>());
            }
        } else {
            dto.setTags(new ArrayList<>());
        }
        dto.setDescription(entity.getDescription());
        return dto;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\service\impl\SearchServiceImpl.java ---
// File: milktea-backend/src/main/java/com.milktea.app/service/impl/SearchServiceImpl.java
package com.milktea.app.service.impl;

import com.milktea.app.common.constant.ErrorCode;
import com.milktea.app.common.exception.BusinessException;
import com.milktea.app.dto.category.CategoryTreeResDTO;
import com.milktea.app.dto.product.ProductListResDTO;
import com.milktea.app.dto.search.ProductSearchReqDTO;
import com.milktea.app.dto.search.ProductSearchResDTO;
import com.milktea.app.dto.search.SearchHistoryReqDTO;
import com.milktea.app.dto.search.SearchHotKeywordsResDTO;
import com.milktea.app.dto.search.SearchSuggestResDTO;
import com.milktea.app.entity.CategoryEntity;
import com.milktea.app.entity.ProductEntity;
import com.milktea.app.entity.SearchKeywordEntity;
import com.milktea.app.entity.UserEntity;
import com.milktea.app.entity.UserSearchHistoryEntity;
import com.milktea.app.repository.CategoryRepository;
import com.milktea.app.repository.ProductRepository;
import com.milktea.app.repository.SearchKeywordRepository;
import com.milktea.app.repository.UserRepository;
import com.milktea.app.repository.UserSearchHistoryRepository;
import com.milktea.app.service.SearchService;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class SearchServiceImpl implements SearchService {

    private final ProductRepository productRepository;
    private final CategoryRepository categoryRepository;
    private final SearchKeywordRepository searchKeywordRepository;
    private final UserSearchHistoryRepository userSearchHistoryRepository;
    private final UserRepository userRepository;
    private final ObjectMapper objectMapper;

    @Override
    @Transactional(readOnly = true)
    public ProductSearchResDTO searchProducts(Long userId, ProductSearchReqDTO reqDTO, Pageable pageable) {
        // Record search history
        if (userId != null && reqDTO.getKeyword() != null && !reqDTO.getKeyword().trim().isEmpty()) {
            addSearchHistory(userId, new SearchHistoryReqDTO(reqDTO.getKeyword(), "product"));
        }
        if (reqDTO.getKeyword() != null && !reqDTO.getKeyword().trim().isEmpty()) {
            updateSearchKeywordCount(reqDTO.getKeyword());
        }

        // Apply sorting
        Sort sort = Sort.unsorted();
        if (reqDTO.getSort() != null) {
            switch (reqDTO.getSort()) {
                case "sales":
                    sort = Sort.by(Sort.Direction.DESC, "sales");
                    break;
                case "price_asc":
                    sort = Sort.by(Sort.Direction.ASC, "price");
                    break;
                case "price_desc":
                    sort = Sort.by(Sort.Direction.DESC, "price");
                    break;
                case "relevance": // Default or no specific field
                default:
                    sort = Sort.by(Sort.Direction.DESC, "rating"); // Example default sort for relevance
                    break;
            }
        }
        pageable = PageRequest.of(pageable.getPageNumber(), pageable.getPageSize(), sort);

        Page<ProductEntity> productPage = productRepository.searchProducts(
                reqDTO.getKeyword(),
                reqDTO.getCategoryId(),
                reqDTO.getMinPrice(),
                reqDTO.getMaxPrice(),
                pageable
        );

        List<ProductListResDTO.ProductItemDTO> productItemDTOs = productPage.getContent().stream()
                .map(this::mapToProductItemDTO)
                .collect(Collectors.toList());

        ProductSearchResDTO resDTO = new ProductSearchResDTO();
        resDTO.setProducts(productItemDTOs);
        resDTO.setTotal((int) productPage.getTotalElements());

        // Search suggestions (can be derived from keyword and related products/categories)
        resDTO.setSuggestions(getSearchSuggestions(reqDTO.getKeyword(), 5).getSuggestions()); // Default limit 5

        // Related categories (if keyword is broad or no category filter applied)
        resDTO.setRelatedCategories(findRelatedCategories(reqDTO.getKeyword()));

        return resDTO;
    }

    @Override
    @Transactional(readOnly = true)
    public SearchHotKeywordsResDTO getHotKeywordsAndHistory(Long userId, Integer limit) {
        SearchHotKeywordsResDTO resDTO = new SearchHotKeywordsResDTO();

        // Hot keywords
        List<SearchKeywordEntity> hotKeywords = searchKeywordRepository.findByTypeOrderByCountDesc("hot");
        resDTO.setKeywords(hotKeywords.stream()
                .limit(limit != null ? limit : 10) // Apply limit from param or default 10
                .map(k -> new SearchHotKeywordsResDTO.KeywordDTO(k.getKeyword(), k.getCount(), k.getType()))
                .collect(Collectors.toList()));

        // User search history
        List<String> userHistory = new ArrayList<>();
        if (userId != null) {
            userHistory = userSearchHistoryRepository.findByUserIdOrderByCreatedAtDesc(userId).stream()
                    .map(UserSearchHistoryEntity::getKeyword)
                    .distinct() // Remove duplicates if any
                    .limit(10) // Limit to latest 10 (hardcoded or configurable)
                    .collect(Collectors.toList());
        }
        resDTO.setHistory(userHistory);
        return resDTO;
    }

    @Override
    @Transactional(readOnly = true)
    public SearchSuggestResDTO getSearchSuggestions(String keyword, Integer limit) {
        if (keyword == null || keyword.trim().isEmpty()) {
            return new SearchSuggestResDTO(Collections.emptyList());
        }
        List<SearchKeywordEntity> suggestedKeywords = searchKeywordRepository.findTop5ByKeywordStartingWithOrderByCountDesc(keyword); // Default 5
        List<String> suggestions = suggestedKeywords.stream()
                .limit(limit != null ? limit : 5) // Apply limit from param or default 5
                .map(SearchKeywordEntity::getKeyword)
                .collect(Collectors.toList());
        return new SearchSuggestResDTO(suggestions);
    }

    @Override
    @Transactional
    public void addSearchHistory(Long userId, SearchHistoryReqDTO reqDTO) {
        UserEntity user = userRepository.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_EXIST, "User not found."));

        // Limit history size to prevent too many entries
        List<UserSearchHistoryEntity> existingHistory = userSearchHistoryRepository.findByUserIdOrderByCreatedAtDesc(userId);
        if (existingHistory.size() >= 50) { // Keep max 50 entries per user
            userSearchHistoryRepository.delete(existingHistory.get(existingHistory.size() - 1));
        }

        UserSearchHistoryEntity newHistory = new UserSearchHistoryEntity();
        newHistory.setUser(user);
        newHistory.setKeyword(reqDTO.getKeyword());
        newHistory.setType(reqDTO.getType());
        newHistory.setCreatedAt(Instant.now());
        userSearchHistoryRepository.save(newHistory);
        log.info("Added search history for user {}: {}", userId, reqDTO.getKeyword());
    }

    @Override
    @Transactional
    public void clearSearchHistory(Long userId) {
        userRepository.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_EXIST, "User not found."));
        userSearchHistoryRepository.deleteByUserId(userId);
        log.info("Cleared search history for user {}", userId);
    }

    private void updateSearchKeywordCount(String keyword) {
        Optional<SearchKeywordEntity> existingKeyword = searchKeywordRepository.findByKeyword(keyword);
        SearchKeywordEntity searchKeyword = existingKeyword.orElseGet(SearchKeywordEntity::new);
        searchKeyword.setKeyword(keyword);
        searchKeyword.setCount(searchKeyword.getCount() + 1);
        if (searchKeyword.getId() == null) {
            searchKeyword.setType("new"); // Mark as new initially
            searchKeyword.setCreatedAt(Instant.now());
        }
        searchKeyword.setUpdatedAt(Instant.now());
        searchKeywordRepository.save(searchKeyword);
    }

    private ProductListResDTO.ProductItemDTO mapToProductItemDTO(ProductEntity entity) {
        ProductListResDTO.ProductItemDTO dto = new ProductListResDTO.ProductItemDTO();
        dto.setId(entity.getId());
        dto.setName(entity.getName());
        dto.setImage(entity.getMainImageUrl());
        dto.setPrice(entity.getPrice());
        dto.setOriginalPrice(entity.getOriginalPrice());
        dto.setSales(entity.getSales());
        if (entity.getTags() != null) {
            try {
                dto.setTags(objectMapper.readValue(entity.getTags(), new TypeReference<List<String>>() {}));
            } catch (Exception e) {
                log.error("Failed to parse product tags for product {}: {}", entity.getId(), e.getMessage());
                dto.setTags(new ArrayList<>());
            }
        } else {
            dto.setTags(new ArrayList<>());
        }
        dto.setDescription(entity.getDescription());
        return dto;
    }

    private List<CategoryTreeResDTO> findRelatedCategories(String keyword) {
        // Simple heuristic: search categories whose name contains the keyword
        if (keyword == null || keyword.trim().isEmpty()) {
            return Collections.emptyList();
        }
        List<CategoryEntity> matchingCategories = categoryRepository.findAll().stream()
                .filter(c -> c.getName().toLowerCase().contains(keyword.toLowerCase()))
                .limit(3) // Limit results
                .collect(Collectors.toList());

        return matchingCategories.stream()
                .map(this::mapToCategoryTreeDTO)
                .collect(Collectors.toList());
    }

    private CategoryTreeResDTO mapToCategoryTreeDTO(CategoryEntity entity) {
        CategoryTreeResDTO dto = new CategoryTreeResDTO();
        dto.setId(entity.getId());
        dto.setParentId(entity.getParent() != null ? entity.getParent().getId() : null);
        dto.setName(entity.getName());
        dto.setIcon(entity.getIconUrl());
        dto.setImage(entity.getImageUrl());
        dto.setSort(entity.getSortOrder());
        dto.setDescription(entity.getDescription());
        dto.setProductCount(0); // Placeholder
        dto.setChildren(Collections.emptyList()); // For related categories, usually don't need deep children
        return dto;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\service\impl\StoreServiceImpl.java ---
// File: milktea-backend/src/main/java/com.milktea.app/service/impl/StoreServiceImpl.java
package com.milktea.app.service.impl;

import com.milktea.app.common.constant.ErrorCode;
import com.milktea.app.common.exception.BusinessException;
import com.milktea.app.common.util.GeoUtil;
import com.milktea.app.dto.home.HomePageResDTO;
import com.milktea.app.dto.store.StoreDetailResDTO;
import com.milktea.app.dto.store.StoreNearbyReqDTO;
import com.milktea.app.dto.store.StoreNearbyResDTO;
import com.milktea.app.entity.StoreEntity;
import com.milktea.app.entity.StoreImageEntity;
import com.milktea.app.entity.StoreServiceEntity;
import com.milktea.app.entity.StoreTagEntity;
import com.milktea.app.entity.UserEntity;
import com.milktea.app.entity.UserFavoriteStoreEntity;
import com.milktea.app.repository.StoreRepository;
import com.milktea.app.repository.UserFavoriteStoreRepository;
import com.milktea.app.repository.UserRepository;
import com.milktea.app.service.StoreService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class StoreServiceImpl implements StoreService {

    private final StoreRepository storeRepository;
    private final UserFavoriteStoreRepository userFavoriteStoreRepository;
    private final UserRepository userRepository;

    @Override
    @Transactional(readOnly = true)
    public StoreNearbyResDTO getNearbyStores(Long userId, StoreNearbyReqDTO reqDTO) {
        List<StoreEntity> nearbyStores = storeRepository.findNearbyStoresNative(
                reqDTO.getLatitude(), reqDTO.getLongitude(), reqDTO.getRadius().doubleValue(), reqDTO.getLimit()
        );

        List<HomePageResDTO.NearbyStoreDTO> storeDTOs = nearbyStores.stream()
                .map(entity -> mapToNearbyStoreDTO(entity, reqDTO.getLatitude(), reqDTO.getLongitude(), userId))
                .collect(Collectors.toList());

        StoreNearbyResDTO resDTO = new StoreNearbyResDTO();
        resDTO.setStores(storeDTOs);
        resDTO.setCurrentLocation(new StoreNearbyResDTO.CurrentLocationDTO(
                reqDTO.getLongitude(), reqDTO.getLatitude(), "当前位置 (mock)"
        ));
        return resDTO;
    }

    @Override
    @Transactional(readOnly = true)
    public StoreDetailResDTO getStoreDetail(Long userId, Long storeId) {
        StoreEntity store = storeRepository.findById(storeId)
                .orElseThrow(() -> new BusinessException(ErrorCode.STORE_NOT_FOUND, "Store not found."));

        // Assume user's current location is needed for distance calculation, mock for now
        BigDecimal mockUserLat = BigDecimal.valueOf(39.916527);
        BigDecimal mockUserLon = BigDecimal.valueOf(116.397128);

        return mapToStoreDetailResDTO(store, mockUserLat, mockUserLon, userId);
    }

    @Override
    @Transactional
    public void addFavoriteStore(Long userId, Long storeId) {
        UserEntity user = userRepository.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_EXIST, "User not found."));
        StoreEntity store = storeRepository.findById(storeId)
                .orElseThrow(() -> new BusinessException(ErrorCode.STORE_NOT_FOUND, "Store not found."));

        if (userFavoriteStoreRepository.existsByUserIdAndStoreId(userId, storeId)) {
            log.info("Store {} is already favorited by user {}", storeId, userId);
            return;
        }

        UserFavoriteStoreEntity favorite = new UserFavoriteStoreEntity();
        favorite.setUser(user);
        favorite.setStore(store);
        favorite.setCreatedAt(Instant.now());
        userFavoriteStoreRepository.save(favorite);
        log.info("User {} favorited store {}", userId, storeId);
    }

    @Override
    @Transactional
    public void removeFavoriteStore(Long userId, Long storeId) {
        userRepository.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_EXIST, "User not found."));
        storeRepository.findById(storeId)
                .orElseThrow(() -> new BusinessException(ErrorCode.STORE_NOT_FOUND, "Store not found."));

        Optional<UserFavoriteStoreEntity> favoriteOptional = userFavoriteStoreRepository.findByUserIdAndStoreId(userId, storeId);
        if (favoriteOptional.isEmpty()) {
            log.info("Store {} is not favorited by user {}", storeId, userId);
            return;
        }

        userFavoriteStoreRepository.delete(favoriteOptional.get());
        log.info("User {} unfavorited store {}", userId, storeId);
    }

    @Override
    @Transactional(readOnly = true)
    public Boolean isStoreFavorite(Long userId, Long storeId) {
        userRepository.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_EXIST, "User not found."));
        storeRepository.findById(storeId)
                .orElseThrow(() -> new BusinessException(ErrorCode.STORE_NOT_FOUND, "Store not found."));
        return userFavoriteStoreRepository.existsByUserIdAndStoreId(userId, storeId);
    }

    private HomePageResDTO.NearbyStoreDTO mapToNearbyStoreDTO(StoreEntity entity, BigDecimal userLat, BigDecimal userLon, Long userId) {
        HomePageResDTO.NearbyStoreDTO dto = new HomePageResDTO.NearbyStoreDTO();
        dto.setId(String.valueOf(entity.getId()));
        dto.setName(entity.getName());
        dto.setAddress(entity.getAddress());

        double distance = GeoUtil.calculateDistance(
                userLat.doubleValue(), userLon.doubleValue(),
                entity.getLatitude().doubleValue(), entity.getLongitude().doubleValue()
        );
        dto.setDistance((int) Math.round(distance));

        dto.setBusinessHours(entity.getBusinessHours());
        dto.setStatus(entity.getStatus());
        dto.setPhone(entity.getPhone());
        dto.setServices(entity.getServices().stream().map(StoreServiceEntity::getServiceType).collect(Collectors.toList()));
        dto.setTags(entity.getTags().stream().map(StoreTagEntity::getTagName).collect(Collectors.toList()));
        dto.setDeliveryFee(entity.getDeliveryFee());
        dto.setMinimumOrderAmount(entity.getMinimumOrderAmount());
        dto.setRating(entity.getRating());
        dto.setImages(entity.getImages().stream().map(StoreImageEntity::getImageUrl).collect(Collectors.toList()));
        dto.setCurrentWaitTime(entity.getCurrentWaitTime());
        dto.setIsFavorite(userId != null && userFavoriteStoreRepository.existsByUserIdAndStoreId(userId, entity.getId()));

        return dto;
    }

    private StoreDetailResDTO mapToStoreDetailResDTO(StoreEntity entity, BigDecimal userLat, BigDecimal userLon, Long userId) {
        // StoreDetailResDTO extends HomePageResDTO.NearbyStoreDTO, so we can reuse the mapping logic
        // Then convert to StoreDetailResDTO
        HomePageResDTO.NearbyStoreDTO nearbyDto = mapToNearbyStoreDTO(entity, userLat, userLon, userId);
        StoreDetailResDTO detailDto = new StoreDetailResDTO();
        // Copy properties from nearbyDto to detailDto
        detailDto.setId(nearbyDto.getId());
        detailDto.setName(nearbyDto.getName());
        detailDto.setAddress(nearbyDto.getAddress());
        detailDto.setDistance(nearbyDto.getDistance());
        detailDto.setBusinessHours(nearbyDto.getBusinessHours());
        detailDto.setStatus(nearbyDto.getStatus());
        detailDto.setPhone(nearbyDto.getPhone());
        detailDto.setServices(nearbyDto.getServices());
        detailDto.setTags(nearbyDto.getTags());
        detailDto.setDeliveryFee(nearbyDto.getDeliveryFee());
        detailDto.setMinimumOrderAmount(nearbyDto.getMinimumOrderAmount());
        detailDto.setRating(nearbyDto.getRating());
        detailDto.setImages(nearbyDto.getImages());
        detailDto.setCurrentWaitTime(nearbyDto.getCurrentWaitTime());
        detailDto.setIsFavorite(nearbyDto.getIsFavorite());
        detailDto.setLongitude(entity.getLongitude()); // Add specific fields if any
        detailDto.setLatitude(entity.getLatitude()); // Add specific fields if any
        return detailDto;
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\service\impl\SystemServiceImpl.java ---
// File: milktea-backend/src/main/java/com.milktea.app/service/impl/SystemServiceImpl.java
package com.milktea.app.service.impl;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.milktea.app.common.constant.ErrorCode;
import com.milktea.app.common.exception.BusinessException;
import com.milktea.app.dto.system.PageConfigResDTO;
import com.milktea.app.dto.system.SystemConfigResDTO;
import com.milktea.app.entity.PageConfigEntity;
import com.milktea.app.entity.SystemConfigEntity;
import com.milktea.app.repository.PageConfigRepository;
import com.milktea.app.repository.SystemConfigRepository;
import com.milktea.app.service.SystemService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class SystemServiceImpl implements SystemService {

    private final SystemConfigRepository systemConfigRepository;
    private final PageConfigRepository pageConfigRepository;
    private final ObjectMapper objectMapper; // For parsing JSON values in configs

    @Override
    @Transactional(readOnly = true)
    public SystemConfigResDTO getSystemConfigs() {
        SystemConfigResDTO resDTO = new SystemConfigResDTO();

        // Fetch all configs and map to DTO fields
        // This can be done by fetching all and then filtering/mapping, or by specific queries.
        // For simplicity, fetching individual keys. In production, load all into a cache.
        resDTO.setAppName(getConfigValue("appName", "温馨奶茶小屋"));
        resDTO.setVersion(getConfigValue("version", "1.0.0"));
        resDTO.setApiVersion(getConfigValue("apiVersion", "v1"));
        resDTO.setMaintenance(Boolean.valueOf(getConfigValue("maintenance", "false")));
        resDTO.setMaintenanceMessage(getConfigValue("maintenanceMessage", ""));

        // Customer Service Config
        SystemConfigResDTO.CustomerServiceConfigDTO csConfig = new SystemConfigResDTO.CustomerServiceConfigDTO();
        csConfig.setPhone(getConfigValue("customerService.phone", "400-123-4567"));
        csConfig.setWechat(getConfigValue("customerService.wechat", "milktea_cs"));
        csConfig.setWorkTime(getConfigValue("customerService.workTime", "周一至周五 9:00-18:00"));
        resDTO.setCustomerService(csConfig);

        // Points Config
        SystemConfigResDTO.PointsConfigDTO pointsConfig = new SystemConfigResDTO.PointsConfigDTO();
        pointsConfig.setRate(Integer.valueOf(getConfigValue("pointsConfig.rate", "100")));
        pointsConfig.setEarnRate(new BigDecimal(getConfigValue("pointsConfig.earnRate", "0.1")));
        pointsConfig.setMaxUseRatio(new BigDecimal(getConfigValue("pointsConfig.maxUseRatio", "0.5")));
        resDTO.setPointsConfig(pointsConfig);

        // Delivery Config
        SystemConfigResDTO.DeliveryConfigDTO deliveryConfig = new SystemConfigResDTO.DeliveryConfigDTO();
        deliveryConfig.setDefaultFee(new BigDecimal(getConfigValue("deliveryConfig.defaultFee", "3.00")));
        deliveryConfig.setFreeThreshold(new BigDecimal(getConfigValue("deliveryConfig.freeThreshold", "30.00")));
        deliveryConfig.setMaxDistance(Integer.valueOf(getConfigValue("deliveryConfig.maxDistance", "5000")));
        resDTO.setDeliveryConfig(deliveryConfig);

        // Payment Config
        SystemConfigResDTO.PaymentConfigDTO paymentConfig = new SystemConfigResDTO.PaymentConfigDTO();
        // Assume supportedMethods is stored as a JSON array string in DB
        String supportedMethodsJson = getConfigValue("paymentConfig.supportedMethods", "[\"alipay\", \"wechat\", \"balance\"]");
        try {
            paymentConfig.setSupportedMethods(objectMapper.readValue(supportedMethodsJson, List.class));
        } catch (Exception e) {
            log.error("Failed to parse paymentConfig.supportedMethods JSON: {}", supportedMethodsJson, e);
            paymentConfig.setSupportedMethods(Collections.emptyList());
        }
        paymentConfig.setDefaultMethod(getConfigValue("paymentConfig.defaultMethod", "alipay"));
        resDTO.setPaymentConfig(paymentConfig);

        // Notification Config
        SystemConfigResDTO.NotificationConfigDTO notificationConfig = new SystemConfigResDTO.NotificationConfigDTO();
        notificationConfig.setOrderStatus(Boolean.valueOf(getConfigValue("notificationConfig.orderStatus", "true")));
        notificationConfig.setPromotion(Boolean.valueOf(getConfigValue("notificationConfig.promotion", "true")));
        notificationConfig.setSystem(Boolean.valueOf(getConfigValue("notificationConfig.system", "true")));
        resDTO.setNotificationConfig(notificationConfig);

        return resDTO;
    }

    @Override
    @Transactional(readOnly = true)
    public PageConfigResDTO getPageConfigs(String pageName) {
        List<PageConfigEntity> configs = pageConfigRepository.findByPageName(pageName);
        if (configs.isEmpty()) {
            // Or throw new BusinessException(ErrorCode.NOT_FOUND, "Page config not found for: " + pageName);
            return new PageConfigResDTO(pageName, Collections.emptyList());
        }

        List<PageConfigResDTO.ConfigItemDTO> configItemDTOs = configs.stream()
                .map(entity -> new PageConfigResDTO.ConfigItemDTO(entity.getKey(), entity.getValue()))
                .collect(Collectors.toList());

        return new PageConfigResDTO(pageName, configItemDTOs);
    }

    private String getConfigValue(String key, String defaultValue) {
        return systemConfigRepository.findByKey(key)
                .map(SystemConfigEntity::getValue)
                .orElse(defaultValue);
    }
}

--- 文件名: C:\Users\shark\Desktop\javaweb期末作业\milktea-backend\src\main\java\com\milktea\app\service\impl\UserServiceImpl.java ---
// File: milktea-backend/src/main/java/com.milktea.app/service/impl/UserServiceImpl.java
package com.milktea.app.service.impl;

import com.milktea.app.common.constant.ErrorCode;
import com.milktea.app.common.exception.BusinessException;
import com.milktea.app.common.util.DateUtil;
import com.milktea.app.common.util.GeoUtil;
import com.milktea.app.dto.home.HomePageResDTO; // For mapToNearbyStoreDTO
import com.milktea.app.dto.store.StoreNearbyReqDTO; // For getAddressesByLocation
import com.milktea.app.dto.user.*;
import com.milktea.app.entity.MemberLevelEntity;
import com.milktea.app.entity.StoreEntity;
import com.milktea.app.entity.StoreImageEntity; // Added for mapToNearbyStoreDTO
import com.milktea.app.entity.StoreServiceEntity; // Added for mapToNearbyStoreDTO
import com.milktea.app.entity.StoreTagEntity; // Added for mapToNearbyStoreDTO
import com.milktea.app.entity.UserAddressEntity;
import com.milktea.app.entity.UserEntity;
import com.milktea.app.entity.UserFavoriteStoreEntity; // For mapToNearbyStoreDTO
import com.milktea.app.entity.VerificationCodeEntity;
import com.milktea.app.repository.MemberLevelRepository;
import com.milktea.app.repository.StoreRepository; // For mapToNearbyStoreDTO
import com.milktea.app.repository.UserAddressRepository;
import com.milktea.app.repository.UserCouponRepository;
import com.milktea.app.repository.UserFavoriteStoreRepository; // For mapToNearbyStoreDTO
import com.milktea.app.repository.UserRepository;
import com.milktea.app.repository.UserShareRepository;
import com.milktea.app.repository.VerificationCodeRepository;
import com.milktea.app.service.UserService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import org.springframework.security.crypto.password.PasswordEncoder; // If password reset/change is involved
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Optional;
import java.util.Random;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class UserServiceImpl implements UserService {

    private final UserRepository userRepository;
    private final UserAddressRepository userAddressRepository;
    private final UserCouponRepository userCouponRepository;
    private final UserShareRepository userShareRepository;
    private final MemberLevelRepository memberLevelRepository;
    private final VerificationCodeRepository verificationCodeRepository;
    private final PasswordEncoder passwordEncoder; // For password related actions
    private final StoreRepository storeRepository; // For mapToNearbyStoreDTO
    private final UserFavoriteStoreRepository userFavoriteStoreRepository; // For mapToNearbyStoreDTO

    @Override
    @Transactional(readOnly = true)
    public UserProfileResDTO getUserProfile(Long userId) {
        UserEntity user = userRepository.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_EXIST, "User not found."));

        UserProfileResDTO resDTO = new UserProfileResDTO();
        resDTO.setId(user.getId());
        resDTO.setNickname(user.getNickname());
        resDTO.setAvatar(user.getAvatarUrl());
        resDTO.setPhone(user.getPhone());
        resDTO.setEmail(user.getEmail());
        resDTO.setGender(user.getGender() != null ? user.getGender().intValue() : 0);
        resDTO.setBirthday(user.getBirthday());
        resDTO.setPoints(user.getPoints());
        resDTO.setBalance(user.getBalance());
        resDTO.setGrowthValue(user.getGrowthValue());
        resDTO.setCreatedAt(user.getCreatedAt());

        // Member Level Info
        MemberLevelEntity currentLevel = user.getMemberLevel();
        if (currentLevel != null) {
            resDTO.setLevel(currentLevel.getName()); // Use name as code for DTO simplicity
            resDTO.setLevelName(currentLevel.getName());
        } else {
            resDTO.setLevel("normal");
            resDTO.setLevelName("普通会员");
        }

        Optional<MemberLevelEntity> nextLevelOptional = memberLevelRepository.findFirstByMinGrowthValueGreaterThanOrderByMinGrowthValueAsc(user.getGrowthValue());
        if (nextLevelOptional.isPresent()) {
            resDTO.setNextLevelPoints(nextLevelOptional.get().getMinGrowthValue() - user.getGrowthValue());
        } else {
            resDTO.setNextLevelPoints(0); // Already max level
        }

        // Computed counts
        resDTO.setCouponCount((int) userCouponRepository.countByUserIdAndStatus(userId, "available"));
        resDTO.setUnreadMessageCount((int) 0L); // Placeholder for actual unread message count

        // Member Card
        UserProfileResDTO.MemberCardDTO memberCardDTO = new UserProfileResDTO.MemberCardDTO();
        memberCardDTO.setCardNo(user.getMemberCardNo());
        memberCardDTO.setStatus(user.getMemberCardStatus());
        memberCardDTO.setExpireDate(user.getMemberCardExpireDate());
        resDTO.setMemberCard(memberCardDTO);

        return resDTO;
    }

    @Override
    @Transactional
    public UserProfileResDTO updateProfile(Long userId, UserProfileUpdateReqDTO reqDTO) {
        UserEntity user = userRepository.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_EXIST, "User not found."));

        user.setNickname(reqDTO.getNickname());
        user.setAvatarUrl(reqDTO.getAvatar());
        user.setGender(reqDTO.getGender() != null ? reqDTO.getGender().shortValue() : null);
        user.setBirthday(reqDTO.getBirthday());
        if (reqDTO.getEmail() != null && !reqDTO.getEmail().equals(user.getEmail())) {
            // Check for email uniqueness if changing
            if (userRepository.findByEmail(reqDTO.getEmail()).isPresent()) {
                throw new BusinessException(ErrorCode.CONFLICT, "Email is already in use.");
            }
            user.setEmail(reqDTO.getEmail());
        }
        user.setUpdatedAt(Instant.now());
        userRepository.save(user);

        return getUserProfile(userId); // Return updated profile
    }

    @Override
    @Transactional
    public void updatePhone(Long userId, UserPhoneUpdateReqDTO reqDTO) {
        UserEntity user = userRepository.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_EXIST, "User not found."));

        // Verify the captcha
        verifyVerificationCode(reqDTO.getPhone(), reqDTO.getCaptcha(), "update_phone");

        // Check if new phone is already bound to another user
        Optional<UserEntity> existingUserWithPhone = userRepository.findByPhone(reqDTO.getPhone());
        if (existingUserWithPhone.isPresent() && !existingUserWithPhone.get().getId().equals(userId)) {
            throw new BusinessException(ErrorCode.PHONE_ALREADY_BOUND, "Phone number is already bound to another account.");
        }

        user.setPhone(reqDTO.getPhone());
        user.setUpdatedAt(Instant.now());
        userRepository.save(user);
        log.info("User {} updated phone to {}", userId, reqDTO.getPhone());
    }

    @Override
    @Transactional(readOnly = true)
    public UserAddressResDTO getUserAddresses(Long userId, Pageable pageable) {
        userRepository.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_EXIST, "User not found."));

        List<UserAddressEntity> addresses = userAddressRepository.findByUserIdOrderByIsDefaultDescCreatedAtDesc(userId);

        // Manual pagination for simplicity as findByUserId returns all.
        // In a real app, the repository method would return a Page<UserAddressEntity>.
        int start = (int) pageable.getOffset();
        int end = Math.min((start + pageable.getPageSize()), addresses.size());
        List<UserAddressEntity> pagedAddresses = addresses.subList(start, end);


        List<UserAddressResDTO.AddressDTO> addressDTOs = pagedAddresses.stream()
                .map(this::mapToAddressDTO)
                .collect(Collectors.toList());

        UserAddressResDTO resDTO = new UserAddressResDTO();
        resDTO.setList(addressDTOs);
        resDTO.setTotal(addresses.size());
        resDTO.setPage(pageable.getPageNumber() + 1);
        resDTO.setLimit(pageable.getPageSize());
        return resDTO;
    }

    @Override
    @Transactional(readOnly = true)
    public UserAddressResDTO.AddressDTO getUserAddressDetail(Long userId, Long addressId) {
        UserAddressEntity address = userAddressRepository.findById(addressId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ADDRESS_NOT_FOUND, "Address not found."));

        if (!address.getUser().getId().equals(userId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN, "Access denied to address.");
        }
        return mapToAddressDTO(address);
    }

    @Override
    @Transactional
    public UserAddressResDTO.AddressDTO createUserAddress(Long userId, UserAddressCreateReqDTO reqDTO) {
        UserEntity user = userRepository.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_EXIST, "User not found."));

        if (reqDTO.getIsDefault() != null && reqDTO.getIsDefault()) {
            // Unset previous default address for this user
            userAddressRepository.findByUserIdAndIsDefaultTrue(userId)
                    .ifPresent(oldDefault -> {
                        oldDefault.setIsDefault(false);
                        userAddressRepository.save(oldDefault);
                    });
        } else {
            // If no default specified, and it's the first address, make it default
            if (userAddressRepository.findByUserId(userId).isEmpty()) {
                reqDTO.setIsDefault(true);
            }
        }


        UserAddressEntity address = new UserAddressEntity();
        address.setUser(user);
        address.setName(reqDTO.getName());
        address.setPhone(reqDTO.getPhone());
        address.setProvince(reqDTO.getProvince());
        address.setCity(reqDTO.getCity());
        address.setDistrict(reqDTO.getDistrict());
        address.setDetail(reqDTO.getDetail());
        address.setPostalCode(reqDTO.getPostalCode());
        address.setIsDefault(reqDTO.getIsDefault());
        address.setType(reqDTO.getType());
        address.setLabel(reqDTO.getLabel());
        address.setLongitude(reqDTO.getLongitude());
        address.setLatitude(reqDTO.getLatitude());
        address.setCreatedAt(Instant.now());
        address.setUpdatedAt(Instant.now());

        address = userAddressRepository.save(address);
        log.info("User {} created new address {}", userId, address.getId());
        return mapToAddressDTO(address);
    }

    @Override
    @Transactional
    public UserAddressResDTO.AddressDTO updateUserAddress(Long userId, Long addressId, UserAddressCreateReqDTO reqDTO) {
        UserAddressEntity address = userAddressRepository.findById(addressId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ADDRESS_NOT_FOUND, "Address not found."));

        if (!address.getUser().getId().equals(userId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN, "Access denied to address.");
        }

        if (reqDTO.getIsDefault() != null && reqDTO.getIsDefault() && !address.getIsDefault()) {
            // If setting to default, unset previous default for this user
            userAddressRepository.findByUserIdAndIsDefaultTrue(userId)
                    .ifPresent(oldDefault -> {
                        oldDefault.setIsDefault(false);
                        userAddressRepository.save(oldDefault);
                    });
        } else if (reqDTO.getIsDefault() != null && !reqDTO.getIsDefault() && address.getIsDefault()) {
            // If unsetting default, ensure there's at least one default left or prevent if it's the only one
            if (userAddressRepository.countByUserId(userId) == 1) { // This query needs to exist
                throw new BusinessException(ErrorCode.DEFAULT_ADDRESS_CANNOT_DELETE, "Cannot unset the only address as default.");
            }
        }

        address.setName(reqDTO.getName());
        address.setPhone(reqDTO.getPhone());
        address.setProvince(reqDTO.getProvince());
        address.setCity(reqDTO.getCity());
        address.setDistrict(reqDTO.getDistrict());
        address.setDetail(reqDTO.getDetail());
        address.setPostalCode(reqDTO.getPostalCode());
        address.setIsDefault(reqDTO.getIsDefault());
        address.setType(reqDTO.getType());
        address.setLabel(reqDTO.getLabel());
        address.setLongitude(reqDTO.getLongitude());
        address.setLatitude(reqDTO.getLatitude());
        address.setUpdatedAt(Instant.now());

        address = userAddressRepository.save(address);
        log.info("User {} updated address {}", userId, address.getId());
        return mapToAddressDTO(address);
    }

    @Override
    @Transactional
    public void deleteUserAddress(Long userId, Long addressId) {
        UserAddressEntity address = userAddressRepository.findById(addressId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ADDRESS_NOT_FOUND, "Address not found."));

        if (!address.getUser().getId().equals(userId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN, "Access denied to address.");
        }

        if (address.getIsDefault()) {
            // If deleting default, reassign default to another address if exists
            List<UserAddressEntity> otherAddresses = userAddressRepository.findByUserIdOrderByIsDefaultDescCreatedAtDesc(userId);
            if (otherAddresses.size() > 1) {
                UserAddressEntity newDefault = otherAddresses.stream()
                        .filter(a -> !a.getId().equals(addressId))
                        .findFirst() // Pick the first available non-default as new default
                        .orElseThrow(() -> new BusinessException(ErrorCode.SYSTEM_ERROR, "Could not assign new default address."));
                newDefault.setIsDefault(true);
                userAddressRepository.save(newDefault);
            } else if (otherAddresses.size() == 1) { // Only one address is left, it's the default being deleted
                // No other address to assign default to, which is fine if user has no addresses left.
            }
        }
        userAddressRepository.delete(address);
        log.info("User {} deleted address {}", userId, address.getId());
    }

    @Override
    @Transactional
    public void setDefaultUserAddress(Long userId, Long addressId) {
        UserAddressEntity addressToSetDefault = userAddressRepository.findById(addressId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ADDRESS_NOT_FOUND, "Address not found."));

        if (!addressToSetDefault.getUser().getId().equals(userId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN, "Access denied to address.");
        }

        if (!addressToSetDefault.getIsDefault()) {
            // Unset previous default address for this user
            userAddressRepository.findByUserIdAndIsDefaultTrue(userId)
                    .ifPresent(oldDefault -> {
                        oldDefault.setIsDefault(false);
                        userAddressRepository.save(oldDefault);
                    });
            // Set new default
            addressToSetDefault.setIsDefault(true);
            userAddressRepository.save(addressToSetDefault);
            log.info("User {} set address {} as default", userId, addressId);
        }
    }

    @Override
    @Transactional(readOnly = true)
    public UserAddressResDTO getAddressesByLocation(Long userId, BigDecimal longitude, BigDecimal latitude, Integer radius, Integer limit) {
        // Find stores near the given location
        List<StoreEntity> nearbyStores = storeRepository.findNearbyStoresNative(latitude, longitude, radius.doubleValue(), limit);

        List<UserAddressResDTO.AddressDTO> addressDTOs = new ArrayList<>();
        // Add a "current location" mock address
        addressDTOs.add(new UserAddressResDTO.AddressDTO(
                null, "当前位置", null, null, null, null, "当前位置", null,
                true, "current", "当前位置", longitude, latitude, Instant.now()
        ));

        // Convert nearby stores to address DTOs, potentially adding them as "suggested addresses"
        nearbyStores.stream()
                .map(store -> new UserAddressResDTO.AddressDTO(
                        null, store.getName(), store.getPhone(),
                        store.getAddress().split(" ")[0], // Simplified province/city
                        store.getAddress().split(" ")[1],
                        store.getAddress().split(" ").length > 2 ? store.getAddress().split(" ")[2] : null,
                        store.getAddress(), null, false, "store", store.getName(),
                        store.getLongitude(), store.getLatitude(), Instant.now()
                ))
                .forEach(addressDTOs::add);

        // For a full implementation, you'd integrate with a real geo-coding service to get address from lat/lon.
        // The DTO format requires a list, total, page, limit.
        return new UserAddressResDTO(addressDTOs, addressDTOs.size(), 1, addressDTOs.size());
    }


    @Override
    @Transactional(readOnly = true)
    public ShareInfoResDTO getShareInfo(Long userId) {
        UserEntity user = userRepository.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_EXIST, "User not found."));

        ShareInfoResDTO resDTO = new ShareInfoResDTO();
        resDTO.setTitle("邀请好友喝奶茶");
        resDTO.setDescription("邀请好友注册,各得20元优惠券");
        resDTO.setImage("https://example.com/share_image.jpg"); // Placeholder
        resDTO.setInviteCode("INVITE" + String.format("%04d", user.getId())); // Simple invite code based on user ID
        resDTO.setPath("/pages/invite/invite?code=" + resDTO.getInviteCode());
        resDTO.setInviteCount((int) userShareRepository.countByUserIdAndType(userId, "invite"));
        resDTO.setRewardPoints(100); // Placeholder
        resDTO.setRewardCoupon(new ShareInfoResDTO.RewardCouponDTO("coupon_id_123", "20元优惠券", BigDecimal.valueOf(20.00)));

        return resDTO;
    }

    @Override
    public GeneratePosterResDTO generateSharePoster(Long userId, GeneratePosterReqDTO reqDTO) {
        // 这是微信实现的: This typically involves calling a WeChat API or a backend image generation service
        // that integrates with WeChat to generate posters with QR codes pointing to mini-program paths.
        userRepository.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_EXIST, "User not found."));

        // Placeholder for image generation service
        log.info("Generating share poster for user {} with QR content {}", userId, reqDTO.getQrCodeContent());
        String mockPosterUrl = "https://example.com/generated_poster_" + UUID.randomUUID().toString() + ".png";
        Instant expireAt = Instant.now().plus(7, ChronoUnit.DAYS); // Poster valid for 7 days

        return new GeneratePosterResDTO(mockPosterUrl, expireAt);
    }

    @Override
    @Transactional
    public void recordShare(Long userId, ShareRecordReqDTO reqDTO) {
        // 这是微信实现的: This often corresponds to client-side sharing events reported back to the backend.
        UserEntity user = userRepository.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_EXIST, "User not found."));

        UserShareEntity share = new UserShareEntity();
        share.setUser(user);
        share.setType(reqDTO.getType());
        share.setTargetId(reqDTO.getTargetId());
        share.setChannel(reqDTO.getChannel());
        if ("invite".equals(reqDTO.getType())) {
            share.setInviteCode("INVITE" + String.format("%04d", user.getId())); // Ensure invite code is consistent
        }
        share.setCreatedAt(Instant.now());
        userShareRepository.save(share);
        log.info("User {} recorded share of type {} on channel {}", userId, reqDTO.getType(), reqDTO.getChannel());

        // Further logic for rewards (e.g., if it's an invite and the invitee registers)
    }

    @Override
    @Transactional
    public void sendVerificationCode(String phone, String type) {
        // Placeholder for SMS sending service integration
        log.info("Sending verification code to phone {} for type {}", phone, type);
        // Generate a 6-digit code
        String code = String.format("%06d", new Random().nextInt(999999));

        // Invalidate any previous unused codes of the same type for this phone
        verificationCodeRepository.findTopByPhoneAndTypeAndExpiresAtAfterAndIsUsedFalseOrderBySentAtDesc(phone, type, Instant.now())
                .ifPresent(prevCode -> {
                    prevCode.setIsUsed(true); // Mark as used/invalidated
                    verificationCodeRepository.save(prevCode);
                });

        VerificationCodeEntity verificationCode = new VerificationCodeEntity();
        verificationCode.setPhone(phone);
        verificationCode.setCode(code);
        verificationCode.setType(type);
        verificationCode.setSentAt(Instant.now());
        verificationCode.setExpiresAt(Instant.now().plus(5, ChronoUnit.MINUTES)); // Expires in 5 minutes
        verificationCode.setIsUsed(false);
        verificationCode.setCreatedAt(Instant.now());
        verificationCodeRepository.save(verificationCode);

        // Here you would call an actual SMS gateway service
        log.info("Mock SMS sent: Phone={}, Code={}", phone, code);
    }

    @Override
    @Transactional
    public void verifyVerificationCode(String phone, String inputCode, String type) {
        VerificationCodeEntity latestCode = verificationCodeRepository.findTopByPhoneAndTypeAndExpiresAtAfterAndIsUsedFalseOrderBySentAtDesc(
                phone, type, Instant.now()
        ).orElseThrow(() -> new BusinessException(ErrorCode.INVALID_VERIFICATION_CODE, "Verification code not found or expired."));

        if (!latestCode.getCode().equals(inputCode)) {
            throw new BusinessException(ErrorCode.INVALID_VERIFICATION_CODE, "Verification code is incorrect.");
        }

        // Mark code as used
        latestCode.setIsUsed(true);
        verificationCodeRepository.save(latestCode);
        log.info("Verification code verified successfully for phone {}", phone);
    }

    private UserAddressResDTO.AddressDTO mapToAddressDTO(UserAddressEntity entity) {
        UserAddressResDTO.AddressDTO dto = new UserAddressResDTO.AddressDTO();
        dto.setId(entity.getId());
        dto.setName(entity.getName());
        dto.setPhone(entity.getPhone());
        dto.setProvince(entity.getProvince());
        dto.setCity(entity.getCity());
        dto.setDistrict(entity.getDistrict());
        dto.setDetail(entity.getDetail());
        dto.setPostalCode(entity.getPostalCode());
        dto.setIsDefault(entity.getIsDefault());
        dto.setType(entity.getType());
        dto.setLabel(entity.getLabel());
        dto.setLongitude(entity.getLongitude());
        dto.setLatitude(entity.getLatitude());
        dto.setCreatedAt(entity.getCreatedAt());
        return dto;
    }

    private HomePageResDTO.NearbyStoreDTO mapToNearbyStoreDTO(StoreEntity entity, BigDecimal userLat, BigDecimal userLon, Long userId) {
        HomePageResDTO.NearbyStoreDTO dto = new HomePageResDTO.NearbyStoreDTO();
        dto.setId(String.valueOf(entity.getId()));
        dto.setName(entity.getName());
        dto.setAddress(entity.getAddress());

        double distance = GeoUtil.calculateDistance(
                userLat.doubleValue(), userLon.doubleValue(),
                entity.getLatitude().doubleValue(), entity.getLongitude().doubleValue()
        );
        dto.setDistance((int) Math.round(distance));

        dto.setBusinessHours(entity.getBusinessHours());
        dto.setStatus(entity.getStatus());
        dto.setPhone(entity.getPhone());
        dto.setServices(entity.getServices().stream().map(StoreServiceEntity::getServiceType).collect(Collectors.toList()));
        dto.setTags(entity.getTags().stream().map(StoreTagEntity::getTagName).collect(Collectors.toList()));
        dto.setDeliveryFee(entity.getDeliveryFee());
        dto.setMinimumOrderAmount(entity.getMinimumOrderAmount());
        dto.setRating(entity.getRating());
        // For images, ensure it's loaded from StoreImageEntity
        dto.setImages(entity.getImages() != null ? entity.getImages().stream().map(StoreImageEntity::getImageUrl).collect(Collectors.toList()) : Collections.emptyList());
        dto.setCurrentWaitTime(entity.getCurrentWaitTime());
        // This 'isFavorite' cannot be directly determined without knowing the requesting user's favorites
        dto.setIsFavorite(userId != null && userFavoriteStoreRepository.existsByUserIdAndStoreId(userId, entity.getId()));
        dto.setLongitude(entity.getLongitude()); // Added from StoreDetailResDTO
        dto.setLatitude(entity.getLatitude());   // Added from StoreDetailResDTO
        return dto;
    }
}

